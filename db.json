{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/images/assetsprocessor/icn-cross@2x.png","path":"images/assetsprocessor/icn-cross@2x.png","modified":0,"renderable":0},{"_id":"source/images/assetsprocessor/icn-check-green.png","path":"images/assetsprocessor/icn-check-green.png","modified":0,"renderable":0},{"_id":"source/images/assetsprocessor/icn-check-yellow.png","path":"images/assetsprocessor/icn-check-yellow.png","modified":0,"renderable":0},{"_id":"source/images/assetsprocessor/icn-none@2x.png","path":"images/assetsprocessor/icn-none@2x.png","modified":0,"renderable":0},{"_id":"themes/archer/source/assets/favicon.jpg","path":"assets/favicon.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/example_qr.png","path":"assets/example_qr.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon.png","path":"assets/favicon.png","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/qq.jpg","path":"assets/qq.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/wechat.jpg","path":"assets/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/avatar.jpg","path":"avatar/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":0,"renderable":1},{"_id":"source/images/cookiecutter/619631-e4d5989e654025cc.png","path":"images/cookiecutter/619631-e4d5989e654025cc.png","modified":0,"renderable":0},{"_id":"source/images/cookiecutter/QQ20190314-142619@2x.png","path":"images/cookiecutter/QQ20190314-142619@2x.png","modified":0,"renderable":0},{"_id":"themes/archer/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":0,"renderable":1},{"_id":"source/images/cookiecutter/QQ20190314-142251@2x.png","path":"images/cookiecutter/QQ20190314-142251@2x.png","modified":0,"renderable":0},{"_id":"themes/archer/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/wechat.png","path":"assets/wechat.png","modified":0,"renderable":1},{"_id":"source/images/cookiecutter/QQ20190314-153222@2x.png","path":"images/cookiecutter/QQ20190314-153222@2x.png","modified":0,"renderable":0},{"_id":"source/images/cookiecutter/619631-d6add963dcab88b4.png","path":"images/cookiecutter/619631-d6add963dcab88b4.png","modified":0,"renderable":0},{"_id":"source/images/cookiecutter/QQ20190314-152801@2x.png","path":"images/cookiecutter/QQ20190314-152801@2x.png","modified":0,"renderable":0},{"_id":"source/images/assetsprocessor/AssetsProcessorExample.gif","path":"images/assetsprocessor/AssetsProcessorExample.gif","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"a9ed088b1fed0a98910bd7340b3856ab1791326d","modified":1580440135531},{"_id":"themes/archer/.gitattributes","hash":"82c1a621642d5b620275ae1ed59845c3f7015a64","modified":1580435013032},{"_id":"themes/archer/.eslintrc.json","hash":"35eeca97fa5a2d0c6d78ef1257c58f03c42d43df","modified":1580435013032},{"_id":"themes/archer/.gitignore","hash":"e2d7fa953bade3b94ed1cab25ffcf442c7540433","modified":1580435013032},{"_id":"themes/archer/.prettierignore","hash":"58caf761f07e5df9cdc21f7f19f0670fde41089b","modified":1580435013033},{"_id":"themes/archer/_config.yml","hash":"971f3b79d7c82f1d3afb9ffdfdfdfc8129170f8d","modified":1580607886568},{"_id":"themes/archer/.prettierrc.js","hash":"875b0b95f6eb24a23e4ea83a75709b97897135e0","modified":1580435013033},{"_id":"themes/archer/LICENSE","hash":"0da0c361bf299375739c6b668a44af0f5faf37bb","modified":1580435013033},{"_id":"themes/archer/README.md","hash":"97edb54cb7aecff714f132110ed4ba8215da7136","modified":1580435013033},{"_id":"themes/archer/gulpfile.js","hash":"46dfe693b00ac4dea4d1b1af56f5ced4ee095c10","modified":1580435013035},{"_id":"themes/archer/package.json","hash":"531fe40833ca63493f62adfa249b6434310a2d0a","modified":1580435013042},{"_id":"themes/archer/webpack.config.js","hash":"d20b6350c50e2981484cb9356a3e21a2124bcd72","modified":1580435013062},{"_id":"themes/archer/webpack.prod.js","hash":"48de76cfa6274895801d3afc89ecbf04ee182a1c","modified":1580435013062},{"_id":"source/_posts/chrysan.md","hash":"a30e18f5849ce9ccce23c109e8e31dfe93574f2f","modified":1580444091100},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1580444809537},{"_id":"source/_posts/cookiecutter.md","hash":"2224f246c63d4c74825e0423e6483d485b463a59","modified":1580450021352},{"_id":"source/images/.DS_Store","hash":"5980d3676709dadd8a5f266c3f820fc6e68dc061","modified":1580440140533},{"_id":"source/_posts/status-bar-styles.md","hash":"e13d22d2778f70f9e1d2fbaf12401c04f6b498a9","modified":1580442167254},{"_id":"source/_posts/maliang.md","hash":"ef9deb0fd2072a36b3e312313b07154fffd5108d","modified":1580444681942},{"_id":"source/_posts/assets-processor.md","hash":"ab65d1743ddf9324e9909343af1b5988f6558d61","modified":1580443562137},{"_id":"source/_posts/codable-swift-4.md","hash":"f7ed34c7a148b949d639e5bbe9385ef2ff1d1a8b","modified":1580443821827},{"_id":"source/_posts/tableview-cell-row-actions.md","hash":"4326a553a10d394a7e15fd7efd56a5888a3e57a9","modified":1580441869645},{"_id":"source/_posts/swift-lint.md","hash":"22e0e95e6228e49ad65787e75a02eb5c59b03142","modified":1580439601453},{"_id":"themes/archer/dev/archer.sh","hash":"4065c4e55462d5ecf016464adea0d1db967ef4b4","modified":1580435013033},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"effc2bc9e0cecfd228b19283337ff29649ea5985","modified":1580435013034},{"_id":"themes/archer/docs/README-en.md","hash":"f325565c0bb94501fd046268659c7752709895d1","modified":1580435013034},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"0bb09c3c9d5f56820cb84e3316f60352b731d70c","modified":1580435013034},{"_id":"themes/archer/languages/default.yml","hash":"5bea8e20a39394119097a218e48ec0ff0871916a","modified":1580448493991},{"_id":"themes/archer/languages/en.yml","hash":"ad75d3e5f7f5f0463d3077e1b5a26f40938a1faa","modified":1580435013036},{"_id":"themes/archer/layout/404.ejs","hash":"879641b1b5e49c43f2e096cad281f7d74df05127","modified":1580435013036},{"_id":"themes/archer/layout/about.ejs","hash":"06019d835c0a51fed8aa086d1dfcf368f9921b42","modified":1580435013039},{"_id":"themes/archer/layout/layout.ejs","hash":"25d818db3357f4c581cd098c571ff02e78960a77","modified":1580451610837},{"_id":"themes/archer/layout/index.ejs","hash":"716ba4a30860e36077dfdfffa02c1cd60301d8a3","modified":1580435013039},{"_id":"themes/archer/layout/site-meta.ejs","hash":"d866aa1a892d4bfe3368f6dbd0f1baa8c5831947","modified":1580435013040},{"_id":"themes/archer/layout/post.ejs","hash":"b61156aff41641a14d5e4e45d9fd776309f2801a","modified":1580435013040},{"_id":"source/images/assetsprocessor/icn-cross@2x.png","hash":"0c70d1d931bff56fec7ddd6519a4fe1edb828d1e","modified":1580443228809},{"_id":"source/images/assetsprocessor/icn-check-green.png","hash":"2f1ffb3b5ca1f50b1dd2e5dfc84acad647b2e271","modified":1580443397137},{"_id":"source/images/assetsprocessor/icn-check-yellow.png","hash":"2de1013fb734c2bcba13d14ff83ed2a59bff17ef","modified":1580443428020},{"_id":"source/images/assetsprocessor/icn-none@2x.png","hash":"fabfa40f57c625eaea9d870e10d53ccb766af722","modified":1580443189309},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----------bug--help-wanted-or-bug-report-.md","hash":"012bd3afea5565204f75d8c89048ad33b9c2f948","modified":1580435013032},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----feature-request-.md","hash":"886fb1252702d46c89536b579d35ce49e53ec54d","modified":1580435013032},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----other-issue-.md","hash":"4bf3c8ebef14a81bb55e8e0468d816e83c4133ac","modified":1580435013032},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"2f5f9073378f628a9124792b5301c1540bc5a264","modified":1580435013036},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"82203d9a1c6e16ef2d37b8b587f56bf6d16edaf2","modified":1580435013036},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"f2e8d4dfd11d879491a4b10f74f8c886cd392240","modified":1580435013036},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"2aea84cb43f4479131620b3c3dfd7cebe9be36ba","modified":1580435013037},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"12e28693dc53cab5f6fd389f15ea0f811c9c37e9","modified":1580435013036},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"e704b7c850a0192f4041bb3e3ce43234f085d636","modified":1580454871392},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"743d97452d4ac358e631c43c9c2120aafdfd3e24","modified":1580435013037},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"418559ab11726f69621c3a58cd21903adff1e48e","modified":1580435013037},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"2d068432031b3bebf9438c775370a2d1b4492d6b","modified":1580435013037},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"cd0d34a811dc4666980d57c00d70dd82bd5450eb","modified":1580435013038},{"_id":"themes/archer/src/js/browser.js","hash":"ce061db99db5b880db0ddb768246352ca885b13c","modified":1580435013055},{"_id":"themes/archer/src/js/init.js","hash":"346c6ef75ae85e4350c1b0811985172fdaa0d3a5","modified":1580435013055},{"_id":"themes/archer/src/js/fancybox.js","hash":"0daf0e83deca055102268e3bd95cb1962acc2264","modified":1580435013055},{"_id":"themes/archer/src/js/initSidebar.js","hash":"b25615ff254913db83e2a20263d445f35083843b","modified":1580435013055},{"_id":"themes/archer/src/js/scroll.js","hash":"aa2315a80daaa183a7e462c7e879ff9d2f050933","modified":1580435013056},{"_id":"themes/archer/src/js/search.js","hash":"2e59ac745da7c22801d9029cf9904a4fc3c384f1","modified":1580435013056},{"_id":"themes/archer/src/js/mobile.js","hash":"228a68d851517b5e47d2132f1d499cb812a64171","modified":1580435013056},{"_id":"themes/archer/src/js/main.js","hash":"e1a48d5822326792e38d44efee86e01473549eba","modified":1580435013055},{"_id":"themes/archer/src/js/share.js","hash":"1314b19a852e291e35d6809f7f58652d3e7c524c","modified":1580435013056},{"_id":"themes/archer/src/js/toc.js","hash":"b3482031e4c8728535d480bfaec76229469e3aba","modified":1580435013057},{"_id":"themes/archer/src/js/tag.js","hash":"e0f0a914c02922e42977d78dc4993b3855167cd8","modified":1580435013057},{"_id":"themes/archer/src/js/sidebar.js","hash":"68d5fe0ee5e86df810d304e5efe11e5e1fddc46d","modified":1580435013056},{"_id":"themes/archer/src/js/util.js","hash":"27de6446892bcf399430dd5776df0b8759ca0eea","modified":1580435013057},{"_id":"themes/archer/src/scss/_common.scss","hash":"dedc313b082e0a16daf87213badd21b13be11af8","modified":1580435013057},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"e7deb20a16868ae9d3e35ba3c5693de71fdf6999","modified":1580435013058},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"a2dbeb38ad08bb8975856d75954cc697bf8e5ff7","modified":1580435013058},{"_id":"themes/archer/src/scss/_variables.scss","hash":"136e5d990c4f8eadf6cabdfa5a053941e90bcd20","modified":1580435013061},{"_id":"themes/archer/src/scss/style.scss","hash":"78e31370d45089b97fa91929345f1a29f2e6a0a2","modified":1580435013062},{"_id":"themes/archer/src/scss/mobile.scss","hash":"aadc2fbf37fefc2ad391d8172d5b61817f9db0c5","modified":1580448554852},{"_id":"themes/archer/source/assets/favicon.jpg","hash":"271e3588feb548dd968d6e896af382a752d7d70c","modified":1580437184314},{"_id":"themes/archer/source/assets/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1580438168111},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1580435013042},{"_id":"themes/archer/source/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1580435013042},{"_id":"themes/archer/source/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1580435013042},{"_id":"themes/archer/source/assets/favicon.png","hash":"09cb357d872496449e0698a4a48566b6175561b4","modified":1580437466169},{"_id":"themes/archer/source/avatar/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1580437173631},{"_id":"themes/archer/source/css/mobile.css","hash":"00585a9fdad4e1c5cf0f798e1f4ce7b1de86c901","modified":1580449924625},{"_id":"themes/archer/source/css/style.css","hash":"e379b6511003c667d46a0815f40c79c6dd128bc8","modified":1580455599946},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1580435013044},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1580435013044},{"_id":"themes/archer/source/intro/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1580445133208},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"bc6ffe9c0d8b3285564619a445c6ca575eb9d0f5","modified":1580435013053},{"_id":"themes/archer/source/scripts/main.js","hash":"e89a9651131684204118fa74bd19cb781d76a372","modified":1580435013054},{"_id":"themes/archer/source/scripts/search.js","hash":"d5f739e261e8ce74f993c6157b248663bda122bf","modified":1580435013054},{"_id":"themes/archer/source/scripts/share.js","hash":"bb5bb37ce7f47f8c084b232df3e5fe2378d7ca01","modified":1580435013054},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1580435013037},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1580435013044},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1580435013045},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1580435013045},{"_id":"themes/archer/source/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1580435013046},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1580435013053},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"794647a8a4ac9e1d01d74c07717175a141b1e01c","modified":1580435013038},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"b27469f19f35ec2037c7bce736a12e9dfb5e360b","modified":1580435013038},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"7691642fb9375607e0ac988a7420999e242cb2c9","modified":1580435013037},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"2154360e330dab94540e168e9d301c7b7091968e","modified":1580435013038},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"c03e16a7741908c207bf58363dcd1349cb639ef8","modified":1580435013038},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"cadd97820a23d01d8b7e2f19a86e5290cef5a8a6","modified":1580435013038},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"790d76f2667377db78a7d04bad8d629e47e7aab0","modified":1580435013038},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"291cc0a4a444a93b93c32e2c39383c70e36e46de","modified":1580435013039},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"147214469c4909eb94943599883f9fa0f3cc090d","modified":1580435013039},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"2d38af7cb5aabc0af99de239bd180c516ec4c56c","modified":1580435013039},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"daa78b17a773bca569f1c8ca2c916495ca138da6","modified":1580435013039},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"d6e1a192cac5dcf365ce1a52df4f23feafeeb849","modified":1580435013039},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"c679578d2feb0bd7d3f80c2f693ba58cbca4428b","modified":1580435013058},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"fa993cf0bbe0086cd8ec3d9a639b2d5b28ccfa8e","modified":1580435013058},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"a2b56f441a9a44d7f5b9b41eaa8136321328d7e9","modified":1580435013058},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"7c557844850d53cc4fc36aaf6d59847d8f238947","modified":1580435013060},{"_id":"themes/archer/source/assets/qq.jpg","hash":"fb3fa842144bebf9da357b893094801242fa73ac","modified":1580438161808},{"_id":"themes/archer/source/assets/wechat.jpg","hash":"f0fdde48a7c24e45e8f17d74731af3014b5d0833","modified":1580437879468},{"_id":"themes/archer/source/avatar/avatar.jpg","hash":"9e18ff7da3fb45d23c8ef3b2dc633d06e08c22fa","modified":1433465684000},{"_id":"themes/archer/package-lock.json","hash":"89a3b67d32f6916cdc21d590d87e43d8a44be8c3","modified":1580435013041},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1580435013035},{"_id":"themes/archer/source/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1580435013052},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"a1569f39eccd64a12425d81b794c53df126a4d87","modified":1580447763813},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"726c543ee066e0b3222b236d9b4ef0109c0bdddf","modified":1580435013059},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"0c986b52ce9083f08c37c5c9b5de045ac5e1d2fa","modified":1580435013059},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"77003ff22b1a10fae2d2768938277959b3f93a72","modified":1580435013059},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"67c2e697a5fbb3b8006cf358ea45eb7f75b496f8","modified":1580435013059},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"9c9a4e470da8732c9a3be3d5ce0d2f80f53714fe","modified":1580435013060},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"f2514031f9d7e4ed4a126694e78618ce6ff3a574","modified":1580435013060},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"14bc42292873880c61b5fa9f47ee9d2e08d46871","modified":1580435013061},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"981a94978535769cb51c29e12b627f83c6fcedc5","modified":1580435013061},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"9ab6f96d0df0c4ad4c72e2515fa2599d487d8f1a","modified":1580435013061},{"_id":"source/images/cookiecutter/619631-e4d5989e654025cc.png","hash":"366da57b0d4d04dbfcfd9aec1110a4e46a637a66","modified":1580440911654},{"_id":"source/images/cookiecutter/QQ20190314-142619@2x.png","hash":"366da57b0d4d04dbfcfd9aec1110a4e46a637a66","modified":1580440299329},{"_id":"themes/archer/source/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1580435013048},{"_id":"source/images/cookiecutter/QQ20190314-142251@2x.png","hash":"1a050124c7554ac6b8802c53eeb411e05feb3e02","modified":1580440285663},{"_id":"themes/archer/source/intro/index-bg.jpg","hash":"a085c37df1bc532cf4dfc2be0645dad8bb3e810f","modified":1580455239294},{"_id":"themes/archer/source/assets/wechat.png","hash":"7705895bda3a266ed765c6cde66a8750343d7e02","modified":1580438001897},{"_id":"themes/archer/source/intro/kari-shea-1SAnrIxw5OY-unsplash.jpg","hash":"d90a5c98e8616b075e26b2791eda280c9c2ff9ec","modified":1580444610998},{"_id":"source/images/cookiecutter/QQ20190314-153222@2x.png","hash":"824d273d12fe05b91e74f7b056f6016d0c196031","modified":1580440306938},{"_id":"source/images/cookiecutter/619631-d6add963dcab88b4.png","hash":"b22e9ba2de4860bc625ec20841c683fed1bfc958","modified":1580441179423},{"_id":"source/images/cookiecutter/QQ20190314-152801@2x.png","hash":"b22e9ba2de4860bc625ec20841c683fed1bfc958","modified":1580440303721},{"_id":"themes/archer/source/intro/jessy-smith-zFOm6KzA-7g-unsplash.jpg","hash":"fd0f092e2d7f2c443e32b95e21f71e8c405eed63","modified":1580446888548},{"_id":"source/images/assetsprocessor/AssetsProcessorExample.gif","hash":"5c9e213f68494bc6937f52ae80731b11b50c8e64","modified":1580442818068},{"_id":"themes/archer/source/intro/anastasia-dulgier-OKOOGO578eo-unsplash.jpg","hash":"cb5928599fbd0689c8c2b6b91422744493599cfc","modified":1580447008425},{"_id":"public/content.json","hash":"921d18a9cb8e58b106c7a025e2c420d480845572","modified":1580454890578},{"_id":"public/2019/03/14/cookiecutter/index.html","hash":"c1c56b287f355e1d0e56369536d31a58e85a2047","modified":1580607897085},{"_id":"public/2018/05/07/maliang/index.html","hash":"f938f7019a76fb9870c69abaf4f8051fd7b74603","modified":1580607897085},{"_id":"public/2017/11/13/chrysan/index.html","hash":"843c933cb66efdd1a2b642db0cf826fe0bc49c81","modified":1580607897085},{"_id":"public/2017/07/05/codable-swift-4/index.html","hash":"e25e894fddf4ff5d587a94f740d7f6467f2bb795","modified":1580607897085},{"_id":"public/2017/05/26/assets-processor/index.html","hash":"aa138f38542b7aa0b40bb04b32484be493c278cd","modified":1580607897085},{"_id":"public/2017/04/25/status-bar-styles/index.html","hash":"f9a3a124b6a3558e2e75da5f5b280de7613dc081","modified":1580607897085},{"_id":"public/2017/04/07/tableview-cell-row-actions/index.html","hash":"70824d28e1dba24d55720352dab803f7a8762712","modified":1580607897085},{"_id":"public/2017/04/04/swift-lint/index.html","hash":"0ee67a2d90d6838aca105ce06bd7c34b49c50676","modified":1580607897085},{"_id":"public/archives/index.html","hash":"6e22ffdf3eefb7fdc3c9e49b538287d9b2a0e617","modified":1580520873308},{"_id":"public/archives/2017/index.html","hash":"33ca60bc76f57cef09599e2c51e55b2666bf9b42","modified":1580520873308},{"_id":"public/archives/2017/04/index.html","hash":"e2f4c0bb13abb66dd53f55f6bee794ea79d2a403","modified":1580520873308},{"_id":"public/archives/2017/05/index.html","hash":"04dad8fb43cbdea36f450c544e64af8b48801eb6","modified":1580520873308},{"_id":"public/archives/2017/07/index.html","hash":"8fdf8e80bbe746babd021531808555398668540d","modified":1580520873308},{"_id":"public/archives/2017/11/index.html","hash":"7703b2e7c437939c22489d451025e4379917a595","modified":1580520873308},{"_id":"public/archives/2018/index.html","hash":"c69f1d6734b7152e8c26e1aaf4e619b4ddf87697","modified":1580520873308},{"_id":"public/archives/2018/05/index.html","hash":"c69f1d6734b7152e8c26e1aaf4e619b4ddf87697","modified":1580520873308},{"_id":"public/archives/2019/index.html","hash":"cc6977a04238d921f0cc5a89bb0ffa23fcf823d4","modified":1580520873308},{"_id":"public/archives/2019/03/index.html","hash":"cc6977a04238d921f0cc5a89bb0ffa23fcf823d4","modified":1580520873308},{"_id":"public/index.html","hash":"543300c86ed7b3517a560711a894d5a48b6fdf71","modified":1580520873308},{"_id":"public/tags/Swift/index.html","hash":"cc6977a04238d921f0cc5a89bb0ffa23fcf823d4","modified":1580520873308},{"_id":"public/tags/iOS/index.html","hash":"cc6977a04238d921f0cc5a89bb0ffa23fcf823d4","modified":1580520873308},{"_id":"public/tags/Cookiecutter/index.html","hash":"cc6977a04238d921f0cc5a89bb0ffa23fcf823d4","modified":1580520873308},{"_id":"public/images/assetsprocessor/icn-check-yellow.png","hash":"2de1013fb734c2bcba13d14ff83ed2a59bff17ef","modified":1580454890578},{"_id":"public/images/assetsprocessor/icn-none@2x.png","hash":"fabfa40f57c625eaea9d870e10d53ccb766af722","modified":1580454890578},{"_id":"public/images/assetsprocessor/icn-check-green.png","hash":"2f1ffb3b5ca1f50b1dd2e5dfc84acad647b2e271","modified":1580454890578},{"_id":"public/images/assetsprocessor/icn-cross@2x.png","hash":"0c70d1d931bff56fec7ddd6519a4fe1edb828d1e","modified":1580454890578},{"_id":"public/assets/favicon.jpg","hash":"271e3588feb548dd968d6e896af382a752d7d70c","modified":1580454890578},{"_id":"public/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1580454890578},{"_id":"public/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1580454890578},{"_id":"public/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1580454890578},{"_id":"public/assets/favicon.png","hash":"09cb357d872496449e0698a4a48566b6175561b4","modified":1580454890578},{"_id":"public/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1580454890578},{"_id":"public/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1580454890578},{"_id":"public/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1580454890578},{"_id":"public/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1580454890578},{"_id":"public/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1580454890578},{"_id":"public/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1580454890578},{"_id":"public/css/mobile.css","hash":"00585a9fdad4e1c5cf0f798e1f4ce7b1de86c901","modified":1580454890578},{"_id":"public/lib/webfontloader.min.js","hash":"bc6ffe9c0d8b3285564619a445c6ca575eb9d0f5","modified":1580454890578},{"_id":"public/scripts/search.js","hash":"d5f739e261e8ce74f993c6157b248663bda122bf","modified":1580454890578},{"_id":"public/css/style.css","hash":"e379b6511003c667d46a0815f40c79c6dd128bc8","modified":1580455656129},{"_id":"public/scripts/main.js","hash":"e89a9651131684204118fa74bd19cb781d76a372","modified":1580454890578},{"_id":"public/scripts/share.js","hash":"bb5bb37ce7f47f8c084b232df3e5fe2378d7ca01","modified":1580454890578},{"_id":"public/lib/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1580454890578},{"_id":"public/assets/qq.jpg","hash":"fb3fa842144bebf9da357b893094801242fa73ac","modified":1580454890578},{"_id":"public/assets/wechat.jpg","hash":"f0fdde48a7c24e45e8f17d74731af3014b5d0833","modified":1580454890578},{"_id":"public/avatar/avatar.jpg","hash":"9e18ff7da3fb45d23c8ef3b2dc633d06e08c22fa","modified":1580454890578},{"_id":"public/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1580454890578},{"_id":"public/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1580454890578},{"_id":"public/images/cookiecutter/619631-e4d5989e654025cc.png","hash":"366da57b0d4d04dbfcfd9aec1110a4e46a637a66","modified":1580454890578},{"_id":"public/images/cookiecutter/QQ20190314-142619@2x.png","hash":"366da57b0d4d04dbfcfd9aec1110a4e46a637a66","modified":1580454890578},{"_id":"public/images/cookiecutter/QQ20190314-142251@2x.png","hash":"1a050124c7554ac6b8802c53eeb411e05feb3e02","modified":1580454890578},{"_id":"public/intro/index-bg.jpg","hash":"a085c37df1bc532cf4dfc2be0645dad8bb3e810f","modified":1580455656129},{"_id":"public/assets/wechat.png","hash":"7705895bda3a266ed765c6cde66a8750343d7e02","modified":1580454890578},{"_id":"public/intro/kari-shea-1SAnrIxw5OY-unsplash.jpg","hash":"d90a5c98e8616b075e26b2791eda280c9c2ff9ec","modified":1580454890578},{"_id":"public/images/cookiecutter/QQ20190314-153222@2x.png","hash":"824d273d12fe05b91e74f7b056f6016d0c196031","modified":1580454890578},{"_id":"public/images/cookiecutter/QQ20190314-152801@2x.png","hash":"b22e9ba2de4860bc625ec20841c683fed1bfc958","modified":1580454890578},{"_id":"public/images/cookiecutter/619631-d6add963dcab88b4.png","hash":"b22e9ba2de4860bc625ec20841c683fed1bfc958","modified":1580454890578},{"_id":"public/intro/jessy-smith-zFOm6KzA-7g-unsplash.jpg","hash":"fd0f092e2d7f2c443e32b95e21f71e8c405eed63","modified":1580454890578},{"_id":"public/images/assetsprocessor/AssetsProcessorExample.gif","hash":"5c9e213f68494bc6937f52ae80731b11b50c8e64","modified":1580454890578},{"_id":"public/intro/anastasia-dulgier-OKOOGO578eo-unsplash.jpg","hash":"cb5928599fbd0689c8c2b6b91422744493599cfc","modified":1580454890578}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Swift 造轮子之自制 HUD","date":"2017-11-13T09:16:00.000Z","abstract":"HUD 是每个 iOS App 的必备组件之一，市面上 Objective-C 的版本也是五花八门。然而转入 Swift 之后并没有一个明星组件出现，仅有的那几个也不能完全满足需求，无奈只能自己造轮子了","_content":"\n> HUD 是每个 iOS App 的必备组件之一，市面上 Objective-C 的版本也是五花八门。然而转入 Swift 之后并没有一个明星组件出现，仅有的那几个也不能完全满足需求，无奈只能自己造轮子了。\n\n## Chrysan\n\nChrysan 取自单词 chrysanthemum 的前半部分，意为菊花，也是 HUD 的通俗称呼。所以就这么叫着吧～\n\n其实 Chrysan 这个库写完已经有一段时间了，经过了好几个线上项目的考验，暂时没有发现什么重大问题，所以最近把它推送到了 CocoaPods，打算分享出来造福大众，顺便骗一波 star 😂\n\n## 安装\n\nChrysan 已经推送到 pod repo，所以集成非常简单：\n\n```ruby\npod 'Chrysan'\n```\n\n当然，也可以在我的 [Github](https://github.com/Harley-xk/) 上直接下载源代码：https://github.com/Harley-xk/Chrysan\n\n## 使用\n\nChrysan 设计为每个 View 都可以创建出 HUD，实践证明这个特性在某些特殊情况下非常有用。每个 View 都有一个 chrysan 属性，通过它可以创建当前 View 的独立的菊花。只有当第一次访问 chrysan 属性时才会真实地创建 ChrysanView 实例，避免不必要的开销和内存占用。\n\n通过访问 ViewController 的 chrysan 属性，可以访问 ViewController 的根 View 的菊花并自动创建。\n\n### 显示\n\n```swift\npublic func show(_ status: Status = .running, message: String? = nil, hideDelay delay: Double = 0)\n```\n\n这个方法用来显示一个菊花，各参数说明如下：\n\n***message*** - 显示在图标下方的说明文字，说明文字支持多行文本\n\n***hideDelay*** - 自动隐藏的时间，传入0则表示不自动隐藏\n\n***status*** - 显示菊花的状态，属于 Status 枚举类型，可以控制显示不同的状态\n\n```swift\n/// 菊花的状态，不同的状态显示不同的icon\n    public enum Status {\n        /// 无状态，显示纯文字\n        case plain\n        /// 执行中，显示菊花\n        case running\n        /// 进度，环形进度条\n        case progress\n        /// 成功，显示勾\n        case succeed\n        /// 错误，显示叉\n        case error\n        /// 自定义，显示自定义的 icon\n        case custom\n    }\n```\n\n### 显示菊花\n\n由于 show 方法的各个参数都支持默认值，因此可以调用所有参数都是默认值的最简形式，此时显示一个单纯的不会隐藏的菊花。\n\n```swift\nchrysan.show()\n```\n\n如果需要显示带文字的菊花，只需要简单加上一个 `message` 参数就可以了：\n\n``` swift\nchrysan.show(message: \"正在处理\")\n```\n\n### 显示纯文本\n\n```swift\n// 显示纯文字\nchrysan.show(.plain, message:\"这是一段纯文字\")\n// 显示纯文字，1 秒后隐藏\nchrysan.show(.plain, message:\"这是一段纯文字\", hideDelay: 1)\n```\n\n### 显示图案\n\n```swift\n// 任务完成后给予用户反馈\nchrysan.show(.succeed, message: \"处理完毕\", hideDelay: 1)\n// 显示自定义图案\nlet image = UIImage(named: \"myImage\")\nchrysan.show(customIcon: image, message: \"自定义图案\", hideDelay: 1)\n```\n\n### 显示任务进度\n\n```swift\n// 显示环形的任务进度，会在中心显示进度百分比，progress 取值 0-1\nchrysan.show(progress: progress, message: \"下载中...\")\n```\n\n## 自定义样式\n\nChrysan 支持有限的自定义样式\n\n菊花背景支持 UIBlurEffect 的所有样式\n\n```swift\n/// 菊花背景样式，使用系统自带的毛玻璃特效，默认为黑色样式\npublic var hudStyle = UIBlurEffectStyle.dark\n```\n\n菊花使用系统的 UIActivityIndicatorView，支持 UIActivityIndicatorViewStyle 的所有类型，默认为 large white\n\n```swift\npublic var chrysanStyle = UIActivityIndicatorViewStyle.whiteLarge\n```\n\n颜色，影响 icon（不包含菊花）、说明文字、进度条和进度数值的颜色\n\n```swift\n/// icon 及文字颜色，默认为白色\npublic var color = UIColor.white\n```\n\n支持自定义图片，图片会被强制转换成 Template 渲染模式，因此必须使用包含 alpha 通道的图片\n\n```swift\n/// 自定义的 icon 图片\npublic var customIcon: UIImage? = nil\n```\n\n弹出 HUD 时，可以设置遮罩以遮住背景的内容，遮罩的颜色可以自定义，默认为全透明\n\n```swift\n/// 遮罩颜色，遮挡 UI 的视图层的颜色，默认透明\npublic var maskColor = UIColor.clear\n```\n\n可以自定义 HUD 在视图中央的偏移，可以在某些特殊情况下调整 HUD 的位置\n\n```swift\n/// 菊花在视图中水平方向上的偏移，默认为正中\npublic var offsetX: CGFloat = 0\n/// 菊花在视图中竖直方向上的偏移，默认为正中\npublic var offsetY: CGFloat = 0\n```\n\n更多内容请查看示例以及代码注释。\n","source":"_posts/chrysan.md","raw":"---\ntitle: Swift 造轮子之自制 HUD\ndate: 2017-11-13 17:16\nabstract: HUD 是每个 iOS App 的必备组件之一，市面上 Objective-C 的版本也是五花八门。然而转入 Swift 之后并没有一个明星组件出现，仅有的那几个也不能完全满足需求，无奈只能自己造轮子了\n---\n\n> HUD 是每个 iOS App 的必备组件之一，市面上 Objective-C 的版本也是五花八门。然而转入 Swift 之后并没有一个明星组件出现，仅有的那几个也不能完全满足需求，无奈只能自己造轮子了。\n\n## Chrysan\n\nChrysan 取自单词 chrysanthemum 的前半部分，意为菊花，也是 HUD 的通俗称呼。所以就这么叫着吧～\n\n其实 Chrysan 这个库写完已经有一段时间了，经过了好几个线上项目的考验，暂时没有发现什么重大问题，所以最近把它推送到了 CocoaPods，打算分享出来造福大众，顺便骗一波 star 😂\n\n## 安装\n\nChrysan 已经推送到 pod repo，所以集成非常简单：\n\n```ruby\npod 'Chrysan'\n```\n\n当然，也可以在我的 [Github](https://github.com/Harley-xk/) 上直接下载源代码：https://github.com/Harley-xk/Chrysan\n\n## 使用\n\nChrysan 设计为每个 View 都可以创建出 HUD，实践证明这个特性在某些特殊情况下非常有用。每个 View 都有一个 chrysan 属性，通过它可以创建当前 View 的独立的菊花。只有当第一次访问 chrysan 属性时才会真实地创建 ChrysanView 实例，避免不必要的开销和内存占用。\n\n通过访问 ViewController 的 chrysan 属性，可以访问 ViewController 的根 View 的菊花并自动创建。\n\n### 显示\n\n```swift\npublic func show(_ status: Status = .running, message: String? = nil, hideDelay delay: Double = 0)\n```\n\n这个方法用来显示一个菊花，各参数说明如下：\n\n***message*** - 显示在图标下方的说明文字，说明文字支持多行文本\n\n***hideDelay*** - 自动隐藏的时间，传入0则表示不自动隐藏\n\n***status*** - 显示菊花的状态，属于 Status 枚举类型，可以控制显示不同的状态\n\n```swift\n/// 菊花的状态，不同的状态显示不同的icon\n    public enum Status {\n        /// 无状态，显示纯文字\n        case plain\n        /// 执行中，显示菊花\n        case running\n        /// 进度，环形进度条\n        case progress\n        /// 成功，显示勾\n        case succeed\n        /// 错误，显示叉\n        case error\n        /// 自定义，显示自定义的 icon\n        case custom\n    }\n```\n\n### 显示菊花\n\n由于 show 方法的各个参数都支持默认值，因此可以调用所有参数都是默认值的最简形式，此时显示一个单纯的不会隐藏的菊花。\n\n```swift\nchrysan.show()\n```\n\n如果需要显示带文字的菊花，只需要简单加上一个 `message` 参数就可以了：\n\n``` swift\nchrysan.show(message: \"正在处理\")\n```\n\n### 显示纯文本\n\n```swift\n// 显示纯文字\nchrysan.show(.plain, message:\"这是一段纯文字\")\n// 显示纯文字，1 秒后隐藏\nchrysan.show(.plain, message:\"这是一段纯文字\", hideDelay: 1)\n```\n\n### 显示图案\n\n```swift\n// 任务完成后给予用户反馈\nchrysan.show(.succeed, message: \"处理完毕\", hideDelay: 1)\n// 显示自定义图案\nlet image = UIImage(named: \"myImage\")\nchrysan.show(customIcon: image, message: \"自定义图案\", hideDelay: 1)\n```\n\n### 显示任务进度\n\n```swift\n// 显示环形的任务进度，会在中心显示进度百分比，progress 取值 0-1\nchrysan.show(progress: progress, message: \"下载中...\")\n```\n\n## 自定义样式\n\nChrysan 支持有限的自定义样式\n\n菊花背景支持 UIBlurEffect 的所有样式\n\n```swift\n/// 菊花背景样式，使用系统自带的毛玻璃特效，默认为黑色样式\npublic var hudStyle = UIBlurEffectStyle.dark\n```\n\n菊花使用系统的 UIActivityIndicatorView，支持 UIActivityIndicatorViewStyle 的所有类型，默认为 large white\n\n```swift\npublic var chrysanStyle = UIActivityIndicatorViewStyle.whiteLarge\n```\n\n颜色，影响 icon（不包含菊花）、说明文字、进度条和进度数值的颜色\n\n```swift\n/// icon 及文字颜色，默认为白色\npublic var color = UIColor.white\n```\n\n支持自定义图片，图片会被强制转换成 Template 渲染模式，因此必须使用包含 alpha 通道的图片\n\n```swift\n/// 自定义的 icon 图片\npublic var customIcon: UIImage? = nil\n```\n\n弹出 HUD 时，可以设置遮罩以遮住背景的内容，遮罩的颜色可以自定义，默认为全透明\n\n```swift\n/// 遮罩颜色，遮挡 UI 的视图层的颜色，默认透明\npublic var maskColor = UIColor.clear\n```\n\n可以自定义 HUD 在视图中央的偏移，可以在某些特殊情况下调整 HUD 的位置\n\n```swift\n/// 菊花在视图中水平方向上的偏移，默认为正中\npublic var offsetX: CGFloat = 0\n/// 菊花在视图中竖直方向上的偏移，默认为正中\npublic var offsetY: CGFloat = 0\n```\n\n更多内容请查看示例以及代码注释。\n","slug":"chrysan","published":1,"updated":"2020-01-31T04:14:51.100Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck61tll280000ufqb07au73n3","content":"<blockquote>\n<p>HUD 是每个 iOS App 的必备组件之一，市面上 Objective-C 的版本也是五花八门。然而转入 Swift 之后并没有一个明星组件出现，仅有的那几个也不能完全满足需求，无奈只能自己造轮子了。</p>\n</blockquote>\n<h2 id=\"Chrysan\"><a href=\"#Chrysan\" class=\"headerlink\" title=\"Chrysan\"></a>Chrysan</h2><p>Chrysan 取自单词 chrysanthemum 的前半部分，意为菊花，也是 HUD 的通俗称呼。所以就这么叫着吧～</p>\n<p>其实 Chrysan 这个库写完已经有一段时间了，经过了好几个线上项目的考验，暂时没有发现什么重大问题，所以最近把它推送到了 CocoaPods，打算分享出来造福大众，顺便骗一波 star 😂</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>Chrysan 已经推送到 pod repo，所以集成非常简单：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod <span class=\"string\">'Chrysan'</span></span><br></pre></td></tr></table></figure>\n\n<p>当然，也可以在我的 <a href=\"https://github.com/Harley-xk/\" target=\"_blank\" rel=\"noopener\">Github</a> 上直接下载源代码：<a href=\"https://github.com/Harley-xk/Chrysan\" target=\"_blank\" rel=\"noopener\">https://github.com/Harley-xk/Chrysan</a></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>Chrysan 设计为每个 View 都可以创建出 HUD，实践证明这个特性在某些特殊情况下非常有用。每个 View 都有一个 chrysan 属性，通过它可以创建当前 View 的独立的菊花。只有当第一次访问 chrysan 属性时才会真实地创建 ChrysanView 实例，避免不必要的开销和内存占用。</p>\n<p>通过访问 ViewController 的 chrysan 属性，可以访问 ViewController 的根 View 的菊花并自动创建。</p>\n<h3 id=\"显示\"><a href=\"#显示\" class=\"headerlink\" title=\"显示\"></a>显示</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">show</span><span class=\"params\">(<span class=\"number\">_</span> status: Status = .running, message: String? = <span class=\"literal\">nil</span>, hideDelay delay: Double = <span class=\"number\">0</span>)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这个方法用来显示一个菊花，各参数说明如下：</p>\n<p><strong><em>message</em></strong> - 显示在图标下方的说明文字，说明文字支持多行文本</p>\n<p><strong><em>hideDelay</em></strong> - 自动隐藏的时间，传入0则表示不自动隐藏</p>\n<p><strong><em>status</em></strong> - 显示菊花的状态，属于 Status 枚举类型，可以控制显示不同的状态</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 菊花的状态，不同的状态显示不同的icon</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Status</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/// 无状态，显示纯文字</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> plain</span><br><span class=\"line\">        <span class=\"comment\">/// 执行中，显示菊花</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> running</span><br><span class=\"line\">        <span class=\"comment\">/// 进度，环形进度条</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> progress</span><br><span class=\"line\">        <span class=\"comment\">/// 成功，显示勾</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> succeed</span><br><span class=\"line\">        <span class=\"comment\">/// 错误，显示叉</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> error</span><br><span class=\"line\">        <span class=\"comment\">/// 自定义，显示自定义的 icon</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> custom</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"显示菊花\"><a href=\"#显示菊花\" class=\"headerlink\" title=\"显示菊花\"></a>显示菊花</h3><p>由于 show 方法的各个参数都支持默认值，因此可以调用所有参数都是默认值的最简形式，此时显示一个单纯的不会隐藏的菊花。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chrysan.show()</span><br></pre></td></tr></table></figure>\n\n<p>如果需要显示带文字的菊花，只需要简单加上一个 <code>message</code> 参数就可以了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chrysan.show(message: <span class=\"string\">\"正在处理\"</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"显示纯文本\"><a href=\"#显示纯文本\" class=\"headerlink\" title=\"显示纯文本\"></a>显示纯文本</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 显示纯文字</span></span><br><span class=\"line\">chrysan.show(.plain, message:<span class=\"string\">\"这是一段纯文字\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// 显示纯文字，1 秒后隐藏</span></span><br><span class=\"line\">chrysan.show(.plain, message:<span class=\"string\">\"这是一段纯文字\"</span>, hideDelay: <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"显示图案\"><a href=\"#显示图案\" class=\"headerlink\" title=\"显示图案\"></a>显示图案</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 任务完成后给予用户反馈</span></span><br><span class=\"line\">chrysan.show(.succeed, message: <span class=\"string\">\"处理完毕\"</span>, hideDelay: <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// 显示自定义图案</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> image = <span class=\"type\">UIImage</span>(named: <span class=\"string\">\"myImage\"</span>)</span><br><span class=\"line\">chrysan.show(customIcon: image, message: <span class=\"string\">\"自定义图案\"</span>, hideDelay: <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"显示任务进度\"><a href=\"#显示任务进度\" class=\"headerlink\" title=\"显示任务进度\"></a>显示任务进度</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 显示环形的任务进度，会在中心显示进度百分比，progress 取值 0-1</span></span><br><span class=\"line\">chrysan.show(progress: progress, message: <span class=\"string\">\"下载中...\"</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自定义样式\"><a href=\"#自定义样式\" class=\"headerlink\" title=\"自定义样式\"></a>自定义样式</h2><p>Chrysan 支持有限的自定义样式</p>\n<p>菊花背景支持 UIBlurEffect 的所有样式</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 菊花背景样式，使用系统自带的毛玻璃特效，默认为黑色样式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> hudStyle = <span class=\"type\">UIBlurEffectStyle</span>.dark</span><br></pre></td></tr></table></figure>\n\n<p>菊花使用系统的 UIActivityIndicatorView，支持 UIActivityIndicatorViewStyle 的所有类型，默认为 large white</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> chrysanStyle = <span class=\"type\">UIActivityIndicatorViewStyle</span>.whiteLarge</span><br></pre></td></tr></table></figure>\n\n<p>颜色，影响 icon（不包含菊花）、说明文字、进度条和进度数值的颜色</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// icon 及文字颜色，默认为白色</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> color = <span class=\"type\">UIColor</span>.white</span><br></pre></td></tr></table></figure>\n\n<p>支持自定义图片，图片会被强制转换成 Template 渲染模式，因此必须使用包含 alpha 通道的图片</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 自定义的 icon 图片</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> customIcon: <span class=\"type\">UIImage?</span> = <span class=\"literal\">nil</span></span><br></pre></td></tr></table></figure>\n\n<p>弹出 HUD 时，可以设置遮罩以遮住背景的内容，遮罩的颜色可以自定义，默认为全透明</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 遮罩颜色，遮挡 UI 的视图层的颜色，默认透明</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> maskColor = <span class=\"type\">UIColor</span>.clear</span><br></pre></td></tr></table></figure>\n\n<p>可以自定义 HUD 在视图中央的偏移，可以在某些特殊情况下调整 HUD 的位置</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 菊花在视图中水平方向上的偏移，默认为正中</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> offsetX: <span class=\"type\">CGFloat</span> = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">/// 菊花在视图中竖直方向上的偏移，默认为正中</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> offsetY: <span class=\"type\">CGFloat</span> = <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>更多内容请查看示例以及代码注释。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>HUD 是每个 iOS App 的必备组件之一，市面上 Objective-C 的版本也是五花八门。然而转入 Swift 之后并没有一个明星组件出现，仅有的那几个也不能完全满足需求，无奈只能自己造轮子了。</p>\n</blockquote>\n<h2 id=\"Chrysan\"><a href=\"#Chrysan\" class=\"headerlink\" title=\"Chrysan\"></a>Chrysan</h2><p>Chrysan 取自单词 chrysanthemum 的前半部分，意为菊花，也是 HUD 的通俗称呼。所以就这么叫着吧～</p>\n<p>其实 Chrysan 这个库写完已经有一段时间了，经过了好几个线上项目的考验，暂时没有发现什么重大问题，所以最近把它推送到了 CocoaPods，打算分享出来造福大众，顺便骗一波 star 😂</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>Chrysan 已经推送到 pod repo，所以集成非常简单：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod <span class=\"string\">'Chrysan'</span></span><br></pre></td></tr></table></figure>\n\n<p>当然，也可以在我的 <a href=\"https://github.com/Harley-xk/\" target=\"_blank\" rel=\"noopener\">Github</a> 上直接下载源代码：<a href=\"https://github.com/Harley-xk/Chrysan\" target=\"_blank\" rel=\"noopener\">https://github.com/Harley-xk/Chrysan</a></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>Chrysan 设计为每个 View 都可以创建出 HUD，实践证明这个特性在某些特殊情况下非常有用。每个 View 都有一个 chrysan 属性，通过它可以创建当前 View 的独立的菊花。只有当第一次访问 chrysan 属性时才会真实地创建 ChrysanView 实例，避免不必要的开销和内存占用。</p>\n<p>通过访问 ViewController 的 chrysan 属性，可以访问 ViewController 的根 View 的菊花并自动创建。</p>\n<h3 id=\"显示\"><a href=\"#显示\" class=\"headerlink\" title=\"显示\"></a>显示</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">show</span><span class=\"params\">(<span class=\"number\">_</span> status: Status = .running, message: String? = <span class=\"literal\">nil</span>, hideDelay delay: Double = <span class=\"number\">0</span>)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这个方法用来显示一个菊花，各参数说明如下：</p>\n<p><strong><em>message</em></strong> - 显示在图标下方的说明文字，说明文字支持多行文本</p>\n<p><strong><em>hideDelay</em></strong> - 自动隐藏的时间，传入0则表示不自动隐藏</p>\n<p><strong><em>status</em></strong> - 显示菊花的状态，属于 Status 枚举类型，可以控制显示不同的状态</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 菊花的状态，不同的状态显示不同的icon</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Status</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/// 无状态，显示纯文字</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> plain</span><br><span class=\"line\">        <span class=\"comment\">/// 执行中，显示菊花</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> running</span><br><span class=\"line\">        <span class=\"comment\">/// 进度，环形进度条</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> progress</span><br><span class=\"line\">        <span class=\"comment\">/// 成功，显示勾</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> succeed</span><br><span class=\"line\">        <span class=\"comment\">/// 错误，显示叉</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> error</span><br><span class=\"line\">        <span class=\"comment\">/// 自定义，显示自定义的 icon</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> custom</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"显示菊花\"><a href=\"#显示菊花\" class=\"headerlink\" title=\"显示菊花\"></a>显示菊花</h3><p>由于 show 方法的各个参数都支持默认值，因此可以调用所有参数都是默认值的最简形式，此时显示一个单纯的不会隐藏的菊花。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chrysan.show()</span><br></pre></td></tr></table></figure>\n\n<p>如果需要显示带文字的菊花，只需要简单加上一个 <code>message</code> 参数就可以了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chrysan.show(message: <span class=\"string\">\"正在处理\"</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"显示纯文本\"><a href=\"#显示纯文本\" class=\"headerlink\" title=\"显示纯文本\"></a>显示纯文本</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 显示纯文字</span></span><br><span class=\"line\">chrysan.show(.plain, message:<span class=\"string\">\"这是一段纯文字\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// 显示纯文字，1 秒后隐藏</span></span><br><span class=\"line\">chrysan.show(.plain, message:<span class=\"string\">\"这是一段纯文字\"</span>, hideDelay: <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"显示图案\"><a href=\"#显示图案\" class=\"headerlink\" title=\"显示图案\"></a>显示图案</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 任务完成后给予用户反馈</span></span><br><span class=\"line\">chrysan.show(.succeed, message: <span class=\"string\">\"处理完毕\"</span>, hideDelay: <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// 显示自定义图案</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> image = <span class=\"type\">UIImage</span>(named: <span class=\"string\">\"myImage\"</span>)</span><br><span class=\"line\">chrysan.show(customIcon: image, message: <span class=\"string\">\"自定义图案\"</span>, hideDelay: <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"显示任务进度\"><a href=\"#显示任务进度\" class=\"headerlink\" title=\"显示任务进度\"></a>显示任务进度</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 显示环形的任务进度，会在中心显示进度百分比，progress 取值 0-1</span></span><br><span class=\"line\">chrysan.show(progress: progress, message: <span class=\"string\">\"下载中...\"</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自定义样式\"><a href=\"#自定义样式\" class=\"headerlink\" title=\"自定义样式\"></a>自定义样式</h2><p>Chrysan 支持有限的自定义样式</p>\n<p>菊花背景支持 UIBlurEffect 的所有样式</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 菊花背景样式，使用系统自带的毛玻璃特效，默认为黑色样式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> hudStyle = <span class=\"type\">UIBlurEffectStyle</span>.dark</span><br></pre></td></tr></table></figure>\n\n<p>菊花使用系统的 UIActivityIndicatorView，支持 UIActivityIndicatorViewStyle 的所有类型，默认为 large white</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> chrysanStyle = <span class=\"type\">UIActivityIndicatorViewStyle</span>.whiteLarge</span><br></pre></td></tr></table></figure>\n\n<p>颜色，影响 icon（不包含菊花）、说明文字、进度条和进度数值的颜色</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// icon 及文字颜色，默认为白色</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> color = <span class=\"type\">UIColor</span>.white</span><br></pre></td></tr></table></figure>\n\n<p>支持自定义图片，图片会被强制转换成 Template 渲染模式，因此必须使用包含 alpha 通道的图片</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 自定义的 icon 图片</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> customIcon: <span class=\"type\">UIImage?</span> = <span class=\"literal\">nil</span></span><br></pre></td></tr></table></figure>\n\n<p>弹出 HUD 时，可以设置遮罩以遮住背景的内容，遮罩的颜色可以自定义，默认为全透明</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 遮罩颜色，遮挡 UI 的视图层的颜色，默认透明</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> maskColor = <span class=\"type\">UIColor</span>.clear</span><br></pre></td></tr></table></figure>\n\n<p>可以自定义 HUD 在视图中央的偏移，可以在某些特殊情况下调整 HUD 的位置</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 菊花在视图中水平方向上的偏移，默认为正中</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> offsetX: <span class=\"type\">CGFloat</span> = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">/// 菊花在视图中竖直方向上的偏移，默认为正中</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> offsetY: <span class=\"type\">CGFloat</span> = <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>更多内容请查看示例以及代码注释。</p>\n"},{"title":"基于 Cookiecutter 打造 iOS 项目模版","abstract":"每次新创建一个项目，我们总是要做这些事情：创建项目、初始化 pod、安装 pod、配置工程、写(或者引入)一些框架性的代码。当项目写的多了，会发现这里面基本上是大量的重复劳动，每次要做的事情几乎是一样的，但是又不可避免。特别是当有时候想写一些玩具性质的小项目时，创建项目所使用的劳动量相比就更加明显了...","_content":"\n## 前言\n\n> 每次新创建一个项目，我们总是要做这些事情：创建项目、初始化 pod、安装 pod、配置工程、写(或者引入)一些框架性的代码。当项目写的多了，会发现这里面基本上是大量的重复劳动，每次要做的事情几乎是一样的，但是又不可避免。特别是当有时候想写一些玩具性质的小项目时，创建项目所使用的劳动量相比就更加明显了。\n\n其实可以看出来，以上这些工作其实都属于模版性质的，如果我们能够先编辑好一个项目模版，然后每次都基于这个模版创建新项目的话就好了。其实 Xcode 本身就提供了模版功能，多年前我也曾基于 Xcode 的模版功能做过一些简单的文件模版和项目模版。但是 Xcode 模版配置比较繁琐，并且官方的文档基本找不到（也可能是我没认真找）。\n\n那么有没有什么别的好办法呢？这就引出这次要说的主角了：[Cookiecutter](https://cookiecutter.readthedocs.io/en/latest/)\n\n## 简介\n\nCookiecutter 是一个用 Python 开发的项目模版工具，在 [Github](https://github.com/audreyr/cookiecutter) 上可以找到它的源码，这个项目目前已经有将近一万个 star 了。\n\nCookiecutter 并不是一个 iOS 专用的工具，它的支持相当广泛，基本上所有主流的项目方案都可以使用它来建立模版，这源于它十分简单粗暴的实现原理：先创建一个项目框架作为模版，将项目名称等一系列参数以关键字的方式在配置文件中指定好，然后新建项目时根据配置好的模版参数，替换模版中所有目录和子目录的名称，以及所有文本中匹配到的关键字。当然了，Cookiecutter 还有很多高级用法，可以去查询它的文档(可能需要借助梯子😔)。\n\n这篇文章只是抛砖引玉，介绍一下我基于 Cookiecutter 创建一个简单的 App 模版的过程。\n\n## 安装\n\n首先需要安装 Cookiecutter，针对不同的平台和环境，Cookiecutter 提供了相当多的安装方式。不过 iOS 开发者基本都在 macOS 环境下工作，所以其他的就略过了。\n\nmac 下官方推荐使用 Homebrew 来安装：\n\n```bash\nbrew install Cookiecutter\n```\n\n整个安装过程都是自动的，非常简单。\n\n## 创建模版\n\n### 新建项目\n\n首先我们需要创建一个模版：打开 Xcode，新建一个单页应用。\n\n![新建单页应用](/images/cookiecutter/QQ20190314-142251%402x.png)\n\n点击 **next**，然后将对应属性设置为 template 关键字：\n  \n```txt\nProduct Name: {{cookiecutter.product_name}}\nOrganization Name: {{cookiecutter.organization_name}}\nOrganization Identifier: {{cookiecutter.organization_identifier}}\n```\n\n然后点击 `next` 创建项目，如下图所示：\n\n![创建项目](/images/cookiecutter/619631-e4d5989e654025cc.png)\n\n项目创建完毕后，打开 info.plist，将 Bundle identifier 指定为:\n\n```txt\ncom.{{cookiecutter.organization_identifier}}.{{cookiecutter.product_name}}\n```\n\n否则 Xcode 默认会将 `{` 和 `}` 替换为 `-`，导致后续创建项目时替换失败。\n\n### 配置文件\n\n接下来，在与刚创建完毕的项目根目录同级，也就是 `cookiecutter.product_name` 文件夹所在的目录，创建一个 **cookiecutter.json** 文件，内容如下：\n\n```JSON\n{\n    \"product_name\": \"Hello\",\n    \"organization_name\": \"Someone Co.,Ltd.\",\n    \"organization_identifier\": \"someone\"\n}\n```\n\nJSON 中的 key 就是我们刚才创建项目时填写的那几个用双括号包含起来的名称，并且去掉 `cookiecutter` 前缀，key 对应的值表示默认值。使用 Cookiecutter 从模版创建项目时，它会询问配置文件中的这几个 key，让我们给它指定名称，如果不指定，则使用配置文件中的默认值。\n\n另外，需要哪些 key，以及 key 的名称是不固定的，你可以根据自己的需要自己定义任意数量的 key，只要保证在模版项目中使用相同的名称，**并且需要带上 `cookiecutter` 前缀**。\n\n至此，一个最简单的项目模版就创建完了，你也可以根据自己的需要给这个项目添加一些额外的代码，新建项目时所有额外添加的内容都将原样保留。\n\n### 钩子\n\n上面创建的项目非常简单，但是我们实际开发中一般都需要使用 Cocoapods 来管理第三方依赖，并且有些库几乎是所有项目都需要用到的，比如 `Alamofire`、`SnapKit` 等等。那么能不能通过模版一并完成 pods 的配置和安装呢？\n\n这就可以用上 Cookiecutter 的钩子功能了，钩子通俗一点讲也叫回调，可以在某些特性情况下触发一些事件，执行一些操作等。\n\nCookiecutter 的钩子配置非常简单，只需要在配置文件同级目录下新建一个 `hooks` 目录，然后将写好的脚本放在该目录中，Cookiecutter 会自动调用。\n\n目前 Cookiecutter 支持两个事件，即创建项目之前和创建项目完成之后，会分别调用对应的脚本文件，目前支持 shell 脚本和 python 脚本。在安装前调用的脚本需要命名为 `pre_gen_project.sh` 或者 `pre_gen_project.py`；同样的，在安装之后调用的脚本需要命名为 `post_gen_project.sh` 或者 `post_gen_project.py`，取决于脚本使用的语言。\n\n#### 自动安装 pods\n\n首先需要在项目目录下，即 `{{cookiecutter.product_name}}/` 目录下创建 Podfile 文件，并配置好常用的依赖库：\n\n```Ruby\ntarget '{{cookiecutter.product_name}}' do\n\n  use_frameworks!\n\n  # Pods for {{cookiecutter.product_name}}\n\n  # Networking\n  pod 'Alamofire'\n  # ImageCache\n  pod 'Kingfisher'\n  # AutoLayout\n  pod 'SnapKit'\n\nend\n```\n\n好了，不要执行 `pod install`，因为这只是个模版，可能实际创建项目时这些库已经更新了，所以需要在创建项目时才安装依赖。\n\n接下来打开 `post_gen_project.sh`, 写上 pod 安装相关的命令：\n\n```bash\n#!/bin/bash\nGREEN='\\033[0;32m'\necho -e \"${GREEN}Project successfuly generated!\"\necho -e \"${GREEN}Installing Pods...\"\npod install\necho -e \"${GREEN}Pods Install Finished\"\n```\n\n其实只需要写一句 `pod install` 就够了，不过为了创建项目时命令行的输出内容能够更加友好，我添加了一些额外的状态输出的内容😏，你也可以在其中添加一些其他需要处理的事务。\n\n这时候我们的项目框架才算基本完成。此时，我们的项目模版目录应该是类似下面这样：\n\n```txt\nios_template/\n├── {{cookiecutter.product_name}}/\n│   ├── {{cookiecutter.product_name}}.xcodeproj\n│   ├── Podfile\n│   └── ...\n├── hooks\n│   ├── pre_gen_project.sh\n│   └── post_gen_project.sh\n└── cookiecutter.json\n```\n\n## 使用\n\n### 分发模版\n\n模版做完了，放到哪里呢？本地目录也是可以的，Cookiecutter 支持从任何可以访问的路径加载项目模版，不过为了方便使用和团队共享，最好是将模版推送到 git 仓库中，这样也方便后期修改以及多人维护等。\n\n另外，如果你的模版项目非常大，也可以打包成 zip 上传，Cookiecutter 支持从 zip 包创建项目，创建时会自动解压。\n\n### 创建项目\n\n创建项目也非常简单，确保 Cookiecutter 已经正确安装后，只需要 cd 到你准备创建项目的目录，然后执行以下命令就好了：\n\n```bash\ncookiecutter https://github.com/Harley-xk/iOS_Template_Comet.git\n```\n\n>后面的路径可以是本地路径也可以是远程路径，可以是 git，也可以是 zip。Cookiecutter 还支持很多其他的仓库形式，详细可以查看它的文档。\n\n命令执行后就开始创建项目了，Cookiecutter 会对你在配置文件中设置的每一个关键字进行询问，你可以输入新项目需要使用的值，或者也可以直接回车后使用默认值。\n\n可以看到命令行的输出如下：\n\n![创建项目](/images/cookiecutter/619631-d6add963dcab88b4.png)\n\nCookiecutter 会在用户目录下缓存所有安装过的项目模版，下次安装时会询问你是否需要更新模版：\n\n> You've downloaded /Users/Harley-xk/.cookiecutters/iOS_Template_Comet before. Is it okay to delete and re-download it?\n\n输入 `yes`，它会自动更新模版后创建项目。\n\n另外可以看到在创建项目之后 `pod install` 指令也自动执行了，我们在 Podfile 里面指定的三个依赖库都已经成功安装了。可以进入 MyApp 目录下面，打开 `MyApp.xcworkspace` 查看创建完毕的项目：\n\n![创建完毕的项目](/images/cookiecutter/QQ20190314-153222%402x.png)\n\n## 结束语\n\n其实可以发现 Cookiecutter 的原理和使用都非常简单。现在项目越做越庞大，架构也越来越复杂，虽然我们可以通过组件化的方式最大化的重用代码，减少工作量，但是依然需要写大量的胶水代码来整合各个组件，做大量的项目配置、项目初始化的工作，通过使用 Cookiecutter，可以进一步节省大量的工作。\n\n*ps. 我在 Github 上创建了我自己的 iOS 项目模版，你如果不想自己写，也可以使用[我的模版](https://github.com/Harley-xk/iOS_Template_Comet.git)*\n","source":"_posts/cookiecutter.md","raw":"---\ntitle: 基于 Cookiecutter 打造 iOS 项目模版\nabstract: 每次新创建一个项目，我们总是要做这些事情：创建项目、初始化 pod、安装 pod、配置工程、写(或者引入)一些框架性的代码。当项目写的多了，会发现这里面基本上是大量的重复劳动，每次要做的事情几乎是一样的，但是又不可避免。特别是当有时候想写一些玩具性质的小项目时，创建项目所使用的劳动量相比就更加明显了...\ntags:\n - iOS\n - Swift\n - Cookiecutter\n---\n\n## 前言\n\n> 每次新创建一个项目，我们总是要做这些事情：创建项目、初始化 pod、安装 pod、配置工程、写(或者引入)一些框架性的代码。当项目写的多了，会发现这里面基本上是大量的重复劳动，每次要做的事情几乎是一样的，但是又不可避免。特别是当有时候想写一些玩具性质的小项目时，创建项目所使用的劳动量相比就更加明显了。\n\n其实可以看出来，以上这些工作其实都属于模版性质的，如果我们能够先编辑好一个项目模版，然后每次都基于这个模版创建新项目的话就好了。其实 Xcode 本身就提供了模版功能，多年前我也曾基于 Xcode 的模版功能做过一些简单的文件模版和项目模版。但是 Xcode 模版配置比较繁琐，并且官方的文档基本找不到（也可能是我没认真找）。\n\n那么有没有什么别的好办法呢？这就引出这次要说的主角了：[Cookiecutter](https://cookiecutter.readthedocs.io/en/latest/)\n\n## 简介\n\nCookiecutter 是一个用 Python 开发的项目模版工具，在 [Github](https://github.com/audreyr/cookiecutter) 上可以找到它的源码，这个项目目前已经有将近一万个 star 了。\n\nCookiecutter 并不是一个 iOS 专用的工具，它的支持相当广泛，基本上所有主流的项目方案都可以使用它来建立模版，这源于它十分简单粗暴的实现原理：先创建一个项目框架作为模版，将项目名称等一系列参数以关键字的方式在配置文件中指定好，然后新建项目时根据配置好的模版参数，替换模版中所有目录和子目录的名称，以及所有文本中匹配到的关键字。当然了，Cookiecutter 还有很多高级用法，可以去查询它的文档(可能需要借助梯子😔)。\n\n这篇文章只是抛砖引玉，介绍一下我基于 Cookiecutter 创建一个简单的 App 模版的过程。\n\n## 安装\n\n首先需要安装 Cookiecutter，针对不同的平台和环境，Cookiecutter 提供了相当多的安装方式。不过 iOS 开发者基本都在 macOS 环境下工作，所以其他的就略过了。\n\nmac 下官方推荐使用 Homebrew 来安装：\n\n```bash\nbrew install Cookiecutter\n```\n\n整个安装过程都是自动的，非常简单。\n\n## 创建模版\n\n### 新建项目\n\n首先我们需要创建一个模版：打开 Xcode，新建一个单页应用。\n\n![新建单页应用](/images/cookiecutter/QQ20190314-142251%402x.png)\n\n点击 **next**，然后将对应属性设置为 template 关键字：\n  \n```txt\nProduct Name: {{cookiecutter.product_name}}\nOrganization Name: {{cookiecutter.organization_name}}\nOrganization Identifier: {{cookiecutter.organization_identifier}}\n```\n\n然后点击 `next` 创建项目，如下图所示：\n\n![创建项目](/images/cookiecutter/619631-e4d5989e654025cc.png)\n\n项目创建完毕后，打开 info.plist，将 Bundle identifier 指定为:\n\n```txt\ncom.{{cookiecutter.organization_identifier}}.{{cookiecutter.product_name}}\n```\n\n否则 Xcode 默认会将 `{` 和 `}` 替换为 `-`，导致后续创建项目时替换失败。\n\n### 配置文件\n\n接下来，在与刚创建完毕的项目根目录同级，也就是 `cookiecutter.product_name` 文件夹所在的目录，创建一个 **cookiecutter.json** 文件，内容如下：\n\n```JSON\n{\n    \"product_name\": \"Hello\",\n    \"organization_name\": \"Someone Co.,Ltd.\",\n    \"organization_identifier\": \"someone\"\n}\n```\n\nJSON 中的 key 就是我们刚才创建项目时填写的那几个用双括号包含起来的名称，并且去掉 `cookiecutter` 前缀，key 对应的值表示默认值。使用 Cookiecutter 从模版创建项目时，它会询问配置文件中的这几个 key，让我们给它指定名称，如果不指定，则使用配置文件中的默认值。\n\n另外，需要哪些 key，以及 key 的名称是不固定的，你可以根据自己的需要自己定义任意数量的 key，只要保证在模版项目中使用相同的名称，**并且需要带上 `cookiecutter` 前缀**。\n\n至此，一个最简单的项目模版就创建完了，你也可以根据自己的需要给这个项目添加一些额外的代码，新建项目时所有额外添加的内容都将原样保留。\n\n### 钩子\n\n上面创建的项目非常简单，但是我们实际开发中一般都需要使用 Cocoapods 来管理第三方依赖，并且有些库几乎是所有项目都需要用到的，比如 `Alamofire`、`SnapKit` 等等。那么能不能通过模版一并完成 pods 的配置和安装呢？\n\n这就可以用上 Cookiecutter 的钩子功能了，钩子通俗一点讲也叫回调，可以在某些特性情况下触发一些事件，执行一些操作等。\n\nCookiecutter 的钩子配置非常简单，只需要在配置文件同级目录下新建一个 `hooks` 目录，然后将写好的脚本放在该目录中，Cookiecutter 会自动调用。\n\n目前 Cookiecutter 支持两个事件，即创建项目之前和创建项目完成之后，会分别调用对应的脚本文件，目前支持 shell 脚本和 python 脚本。在安装前调用的脚本需要命名为 `pre_gen_project.sh` 或者 `pre_gen_project.py`；同样的，在安装之后调用的脚本需要命名为 `post_gen_project.sh` 或者 `post_gen_project.py`，取决于脚本使用的语言。\n\n#### 自动安装 pods\n\n首先需要在项目目录下，即 `{{cookiecutter.product_name}}/` 目录下创建 Podfile 文件，并配置好常用的依赖库：\n\n```Ruby\ntarget '{{cookiecutter.product_name}}' do\n\n  use_frameworks!\n\n  # Pods for {{cookiecutter.product_name}}\n\n  # Networking\n  pod 'Alamofire'\n  # ImageCache\n  pod 'Kingfisher'\n  # AutoLayout\n  pod 'SnapKit'\n\nend\n```\n\n好了，不要执行 `pod install`，因为这只是个模版，可能实际创建项目时这些库已经更新了，所以需要在创建项目时才安装依赖。\n\n接下来打开 `post_gen_project.sh`, 写上 pod 安装相关的命令：\n\n```bash\n#!/bin/bash\nGREEN='\\033[0;32m'\necho -e \"${GREEN}Project successfuly generated!\"\necho -e \"${GREEN}Installing Pods...\"\npod install\necho -e \"${GREEN}Pods Install Finished\"\n```\n\n其实只需要写一句 `pod install` 就够了，不过为了创建项目时命令行的输出内容能够更加友好，我添加了一些额外的状态输出的内容😏，你也可以在其中添加一些其他需要处理的事务。\n\n这时候我们的项目框架才算基本完成。此时，我们的项目模版目录应该是类似下面这样：\n\n```txt\nios_template/\n├── {{cookiecutter.product_name}}/\n│   ├── {{cookiecutter.product_name}}.xcodeproj\n│   ├── Podfile\n│   └── ...\n├── hooks\n│   ├── pre_gen_project.sh\n│   └── post_gen_project.sh\n└── cookiecutter.json\n```\n\n## 使用\n\n### 分发模版\n\n模版做完了，放到哪里呢？本地目录也是可以的，Cookiecutter 支持从任何可以访问的路径加载项目模版，不过为了方便使用和团队共享，最好是将模版推送到 git 仓库中，这样也方便后期修改以及多人维护等。\n\n另外，如果你的模版项目非常大，也可以打包成 zip 上传，Cookiecutter 支持从 zip 包创建项目，创建时会自动解压。\n\n### 创建项目\n\n创建项目也非常简单，确保 Cookiecutter 已经正确安装后，只需要 cd 到你准备创建项目的目录，然后执行以下命令就好了：\n\n```bash\ncookiecutter https://github.com/Harley-xk/iOS_Template_Comet.git\n```\n\n>后面的路径可以是本地路径也可以是远程路径，可以是 git，也可以是 zip。Cookiecutter 还支持很多其他的仓库形式，详细可以查看它的文档。\n\n命令执行后就开始创建项目了，Cookiecutter 会对你在配置文件中设置的每一个关键字进行询问，你可以输入新项目需要使用的值，或者也可以直接回车后使用默认值。\n\n可以看到命令行的输出如下：\n\n![创建项目](/images/cookiecutter/619631-d6add963dcab88b4.png)\n\nCookiecutter 会在用户目录下缓存所有安装过的项目模版，下次安装时会询问你是否需要更新模版：\n\n> You've downloaded /Users/Harley-xk/.cookiecutters/iOS_Template_Comet before. Is it okay to delete and re-download it?\n\n输入 `yes`，它会自动更新模版后创建项目。\n\n另外可以看到在创建项目之后 `pod install` 指令也自动执行了，我们在 Podfile 里面指定的三个依赖库都已经成功安装了。可以进入 MyApp 目录下面，打开 `MyApp.xcworkspace` 查看创建完毕的项目：\n\n![创建完毕的项目](/images/cookiecutter/QQ20190314-153222%402x.png)\n\n## 结束语\n\n其实可以发现 Cookiecutter 的原理和使用都非常简单。现在项目越做越庞大，架构也越来越复杂，虽然我们可以通过组件化的方式最大化的重用代码，减少工作量，但是依然需要写大量的胶水代码来整合各个组件，做大量的项目配置、项目初始化的工作，通过使用 Cookiecutter，可以进一步节省大量的工作。\n\n*ps. 我在 Github 上创建了我自己的 iOS 项目模版，你如果不想自己写，也可以使用[我的模版](https://github.com/Harley-xk/iOS_Template_Comet.git)*\n","slug":"cookiecutter","published":1,"date":"2019-03-14T05:26:24.000Z","updated":"2020-01-31T05:53:41.352Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck61tll2e0001ufqb5omv0rdo","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>每次新创建一个项目，我们总是要做这些事情：创建项目、初始化 pod、安装 pod、配置工程、写(或者引入)一些框架性的代码。当项目写的多了，会发现这里面基本上是大量的重复劳动，每次要做的事情几乎是一样的，但是又不可避免。特别是当有时候想写一些玩具性质的小项目时，创建项目所使用的劳动量相比就更加明显了。</p>\n</blockquote>\n<p>其实可以看出来，以上这些工作其实都属于模版性质的，如果我们能够先编辑好一个项目模版，然后每次都基于这个模版创建新项目的话就好了。其实 Xcode 本身就提供了模版功能，多年前我也曾基于 Xcode 的模版功能做过一些简单的文件模版和项目模版。但是 Xcode 模版配置比较繁琐，并且官方的文档基本找不到（也可能是我没认真找）。</p>\n<p>那么有没有什么别的好办法呢？这就引出这次要说的主角了：<a href=\"https://cookiecutter.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"noopener\">Cookiecutter</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Cookiecutter 是一个用 Python 开发的项目模版工具，在 <a href=\"https://github.com/audreyr/cookiecutter\" target=\"_blank\" rel=\"noopener\">Github</a> 上可以找到它的源码，这个项目目前已经有将近一万个 star 了。</p>\n<p>Cookiecutter 并不是一个 iOS 专用的工具，它的支持相当广泛，基本上所有主流的项目方案都可以使用它来建立模版，这源于它十分简单粗暴的实现原理：先创建一个项目框架作为模版，将项目名称等一系列参数以关键字的方式在配置文件中指定好，然后新建项目时根据配置好的模版参数，替换模版中所有目录和子目录的名称，以及所有文本中匹配到的关键字。当然了，Cookiecutter 还有很多高级用法，可以去查询它的文档(可能需要借助梯子😔)。</p>\n<p>这篇文章只是抛砖引玉，介绍一下我基于 Cookiecutter 创建一个简单的 App 模版的过程。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>首先需要安装 Cookiecutter，针对不同的平台和环境，Cookiecutter 提供了相当多的安装方式。不过 iOS 开发者基本都在 macOS 环境下工作，所以其他的就略过了。</p>\n<p>mac 下官方推荐使用 Homebrew 来安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install Cookiecutter</span><br></pre></td></tr></table></figure>\n\n<p>整个安装过程都是自动的，非常简单。</p>\n<h2 id=\"创建模版\"><a href=\"#创建模版\" class=\"headerlink\" title=\"创建模版\"></a>创建模版</h2><h3 id=\"新建项目\"><a href=\"#新建项目\" class=\"headerlink\" title=\"新建项目\"></a>新建项目</h3><p>首先我们需要创建一个模版：打开 Xcode，新建一个单页应用。</p>\n<p><img src=\"/images/cookiecutter/QQ20190314-142251%402x.png\" alt=\"新建单页应用\"></p>\n<p>点击 <strong>next</strong>，然后将对应属性设置为 template 关键字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Product Name: &#123;&#123;cookiecutter.product_name&#125;&#125;</span><br><span class=\"line\">Organization Name: &#123;&#123;cookiecutter.organization_name&#125;&#125;</span><br><span class=\"line\">Organization Identifier: &#123;&#123;cookiecutter.organization_identifier&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后点击 <code>next</code> 创建项目，如下图所示：</p>\n<p><img src=\"/images/cookiecutter/619631-e4d5989e654025cc.png\" alt=\"创建项目\"></p>\n<p>项目创建完毕后，打开 info.plist，将 Bundle identifier 指定为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.&#123;&#123;cookiecutter.organization_identifier&#125;&#125;.&#123;&#123;cookiecutter.product_name&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>否则 Xcode 默认会将 <code>{</code> 和 <code>}</code> 替换为 <code>-</code>，导致后续创建项目时替换失败。</p>\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>接下来，在与刚创建完毕的项目根目录同级，也就是 <code>cookiecutter.product_name</code> 文件夹所在的目录，创建一个 <strong>cookiecutter.json</strong> 文件，内容如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"product_name\"</span>: <span class=\"string\">\"Hello\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"organization_name\"</span>: <span class=\"string\">\"Someone Co.,Ltd.\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"organization_identifier\"</span>: <span class=\"string\">\"someone\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JSON 中的 key 就是我们刚才创建项目时填写的那几个用双括号包含起来的名称，并且去掉 <code>cookiecutter</code> 前缀，key 对应的值表示默认值。使用 Cookiecutter 从模版创建项目时，它会询问配置文件中的这几个 key，让我们给它指定名称，如果不指定，则使用配置文件中的默认值。</p>\n<p>另外，需要哪些 key，以及 key 的名称是不固定的，你可以根据自己的需要自己定义任意数量的 key，只要保证在模版项目中使用相同的名称，<strong>并且需要带上 <code>cookiecutter</code> 前缀</strong>。</p>\n<p>至此，一个最简单的项目模版就创建完了，你也可以根据自己的需要给这个项目添加一些额外的代码，新建项目时所有额外添加的内容都将原样保留。</p>\n<h3 id=\"钩子\"><a href=\"#钩子\" class=\"headerlink\" title=\"钩子\"></a>钩子</h3><p>上面创建的项目非常简单，但是我们实际开发中一般都需要使用 Cocoapods 来管理第三方依赖，并且有些库几乎是所有项目都需要用到的，比如 <code>Alamofire</code>、<code>SnapKit</code> 等等。那么能不能通过模版一并完成 pods 的配置和安装呢？</p>\n<p>这就可以用上 Cookiecutter 的钩子功能了，钩子通俗一点讲也叫回调，可以在某些特性情况下触发一些事件，执行一些操作等。</p>\n<p>Cookiecutter 的钩子配置非常简单，只需要在配置文件同级目录下新建一个 <code>hooks</code> 目录，然后将写好的脚本放在该目录中，Cookiecutter 会自动调用。</p>\n<p>目前 Cookiecutter 支持两个事件，即创建项目之前和创建项目完成之后，会分别调用对应的脚本文件，目前支持 shell 脚本和 python 脚本。在安装前调用的脚本需要命名为 <code>pre_gen_project.sh</code> 或者 <code>pre_gen_project.py</code>；同样的，在安装之后调用的脚本需要命名为 <code>post_gen_project.sh</code> 或者 <code>post_gen_project.py</code>，取决于脚本使用的语言。</p>\n<h4 id=\"自动安装-pods\"><a href=\"#自动安装-pods\" class=\"headerlink\" title=\"自动安装 pods\"></a>自动安装 pods</h4><p>首先需要在项目目录下，即 <code>/</code> 目录下创建 Podfile 文件，并配置好常用的依赖库：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target <span class=\"string\">'&#123;&#123;cookiecutter.product_name&#125;&#125;'</span> <span class=\"keyword\">do</span></span><br><span class=\"line\"></span><br><span class=\"line\">  use_frameworks!</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Pods for &#123;&#123;cookiecutter.product_name&#125;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Networking</span></span><br><span class=\"line\">  pod <span class=\"string\">'Alamofire'</span></span><br><span class=\"line\">  <span class=\"comment\"># ImageCache</span></span><br><span class=\"line\">  pod <span class=\"string\">'Kingfisher'</span></span><br><span class=\"line\">  <span class=\"comment\"># AutoLayout</span></span><br><span class=\"line\">  pod <span class=\"string\">'SnapKit'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>好了，不要执行 <code>pod install</code>，因为这只是个模版，可能实际创建项目时这些库已经更新了，所以需要在创建项目时才安装依赖。</p>\n<p>接下来打开 <code>post_gen_project.sh</code>, 写上 pod 安装相关的命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">GREEN=<span class=\"string\">'\\033[0;32m'</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"<span class=\"variable\">$&#123;GREEN&#125;</span>Project successfuly generated!\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"<span class=\"variable\">$&#123;GREEN&#125;</span>Installing Pods...\"</span></span><br><span class=\"line\">pod install</span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"<span class=\"variable\">$&#123;GREEN&#125;</span>Pods Install Finished\"</span></span><br></pre></td></tr></table></figure>\n\n<p>其实只需要写一句 <code>pod install</code> 就够了，不过为了创建项目时命令行的输出内容能够更加友好，我添加了一些额外的状态输出的内容😏，你也可以在其中添加一些其他需要处理的事务。</p>\n<p>这时候我们的项目框架才算基本完成。此时，我们的项目模版目录应该是类似下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ios_template&#x2F;</span><br><span class=\"line\">├── &#123;&#123;cookiecutter.product_name&#125;&#125;&#x2F;</span><br><span class=\"line\">│   ├── &#123;&#123;cookiecutter.product_name&#125;&#125;.xcodeproj</span><br><span class=\"line\">│   ├── Podfile</span><br><span class=\"line\">│   └── ...</span><br><span class=\"line\">├── hooks</span><br><span class=\"line\">│   ├── pre_gen_project.sh</span><br><span class=\"line\">│   └── post_gen_project.sh</span><br><span class=\"line\">└── cookiecutter.json</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"分发模版\"><a href=\"#分发模版\" class=\"headerlink\" title=\"分发模版\"></a>分发模版</h3><p>模版做完了，放到哪里呢？本地目录也是可以的，Cookiecutter 支持从任何可以访问的路径加载项目模版，不过为了方便使用和团队共享，最好是将模版推送到 git 仓库中，这样也方便后期修改以及多人维护等。</p>\n<p>另外，如果你的模版项目非常大，也可以打包成 zip 上传，Cookiecutter 支持从 zip 包创建项目，创建时会自动解压。</p>\n<h3 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h3><p>创建项目也非常简单，确保 Cookiecutter 已经正确安装后，只需要 cd 到你准备创建项目的目录，然后执行以下命令就好了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cookiecutter https://github.com/Harley-xk/iOS_Template_Comet.git</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>后面的路径可以是本地路径也可以是远程路径，可以是 git，也可以是 zip。Cookiecutter 还支持很多其他的仓库形式，详细可以查看它的文档。</p>\n</blockquote>\n<p>命令执行后就开始创建项目了，Cookiecutter 会对你在配置文件中设置的每一个关键字进行询问，你可以输入新项目需要使用的值，或者也可以直接回车后使用默认值。</p>\n<p>可以看到命令行的输出如下：</p>\n<p><img src=\"/images/cookiecutter/619631-d6add963dcab88b4.png\" alt=\"创建项目\"></p>\n<p>Cookiecutter 会在用户目录下缓存所有安装过的项目模版，下次安装时会询问你是否需要更新模版：</p>\n<blockquote>\n<p>You’ve downloaded /Users/Harley-xk/.cookiecutters/iOS_Template_Comet before. Is it okay to delete and re-download it?</p>\n</blockquote>\n<p>输入 <code>yes</code>，它会自动更新模版后创建项目。</p>\n<p>另外可以看到在创建项目之后 <code>pod install</code> 指令也自动执行了，我们在 Podfile 里面指定的三个依赖库都已经成功安装了。可以进入 MyApp 目录下面，打开 <code>MyApp.xcworkspace</code> 查看创建完毕的项目：</p>\n<p><img src=\"/images/cookiecutter/QQ20190314-153222%402x.png\" alt=\"创建完毕的项目\"></p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>其实可以发现 Cookiecutter 的原理和使用都非常简单。现在项目越做越庞大，架构也越来越复杂，虽然我们可以通过组件化的方式最大化的重用代码，减少工作量，但是依然需要写大量的胶水代码来整合各个组件，做大量的项目配置、项目初始化的工作，通过使用 Cookiecutter，可以进一步节省大量的工作。</p>\n<p><em>ps. 我在 Github 上创建了我自己的 iOS 项目模版，你如果不想自己写，也可以使用<a href=\"https://github.com/Harley-xk/iOS_Template_Comet.git\" target=\"_blank\" rel=\"noopener\">我的模版</a></em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>每次新创建一个项目，我们总是要做这些事情：创建项目、初始化 pod、安装 pod、配置工程、写(或者引入)一些框架性的代码。当项目写的多了，会发现这里面基本上是大量的重复劳动，每次要做的事情几乎是一样的，但是又不可避免。特别是当有时候想写一些玩具性质的小项目时，创建项目所使用的劳动量相比就更加明显了。</p>\n</blockquote>\n<p>其实可以看出来，以上这些工作其实都属于模版性质的，如果我们能够先编辑好一个项目模版，然后每次都基于这个模版创建新项目的话就好了。其实 Xcode 本身就提供了模版功能，多年前我也曾基于 Xcode 的模版功能做过一些简单的文件模版和项目模版。但是 Xcode 模版配置比较繁琐，并且官方的文档基本找不到（也可能是我没认真找）。</p>\n<p>那么有没有什么别的好办法呢？这就引出这次要说的主角了：<a href=\"https://cookiecutter.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"noopener\">Cookiecutter</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Cookiecutter 是一个用 Python 开发的项目模版工具，在 <a href=\"https://github.com/audreyr/cookiecutter\" target=\"_blank\" rel=\"noopener\">Github</a> 上可以找到它的源码，这个项目目前已经有将近一万个 star 了。</p>\n<p>Cookiecutter 并不是一个 iOS 专用的工具，它的支持相当广泛，基本上所有主流的项目方案都可以使用它来建立模版，这源于它十分简单粗暴的实现原理：先创建一个项目框架作为模版，将项目名称等一系列参数以关键字的方式在配置文件中指定好，然后新建项目时根据配置好的模版参数，替换模版中所有目录和子目录的名称，以及所有文本中匹配到的关键字。当然了，Cookiecutter 还有很多高级用法，可以去查询它的文档(可能需要借助梯子😔)。</p>\n<p>这篇文章只是抛砖引玉，介绍一下我基于 Cookiecutter 创建一个简单的 App 模版的过程。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>首先需要安装 Cookiecutter，针对不同的平台和环境，Cookiecutter 提供了相当多的安装方式。不过 iOS 开发者基本都在 macOS 环境下工作，所以其他的就略过了。</p>\n<p>mac 下官方推荐使用 Homebrew 来安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install Cookiecutter</span><br></pre></td></tr></table></figure>\n\n<p>整个安装过程都是自动的，非常简单。</p>\n<h2 id=\"创建模版\"><a href=\"#创建模版\" class=\"headerlink\" title=\"创建模版\"></a>创建模版</h2><h3 id=\"新建项目\"><a href=\"#新建项目\" class=\"headerlink\" title=\"新建项目\"></a>新建项目</h3><p>首先我们需要创建一个模版：打开 Xcode，新建一个单页应用。</p>\n<p><img src=\"/images/cookiecutter/QQ20190314-142251%402x.png\" alt=\"新建单页应用\"></p>\n<p>点击 <strong>next</strong>，然后将对应属性设置为 template 关键字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Product Name: &#123;&#123;cookiecutter.product_name&#125;&#125;</span><br><span class=\"line\">Organization Name: &#123;&#123;cookiecutter.organization_name&#125;&#125;</span><br><span class=\"line\">Organization Identifier: &#123;&#123;cookiecutter.organization_identifier&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后点击 <code>next</code> 创建项目，如下图所示：</p>\n<p><img src=\"/images/cookiecutter/619631-e4d5989e654025cc.png\" alt=\"创建项目\"></p>\n<p>项目创建完毕后，打开 info.plist，将 Bundle identifier 指定为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.&#123;&#123;cookiecutter.organization_identifier&#125;&#125;.&#123;&#123;cookiecutter.product_name&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>否则 Xcode 默认会将 <code>{</code> 和 <code>}</code> 替换为 <code>-</code>，导致后续创建项目时替换失败。</p>\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>接下来，在与刚创建完毕的项目根目录同级，也就是 <code>cookiecutter.product_name</code> 文件夹所在的目录，创建一个 <strong>cookiecutter.json</strong> 文件，内容如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"product_name\"</span>: <span class=\"string\">\"Hello\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"organization_name\"</span>: <span class=\"string\">\"Someone Co.,Ltd.\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"organization_identifier\"</span>: <span class=\"string\">\"someone\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JSON 中的 key 就是我们刚才创建项目时填写的那几个用双括号包含起来的名称，并且去掉 <code>cookiecutter</code> 前缀，key 对应的值表示默认值。使用 Cookiecutter 从模版创建项目时，它会询问配置文件中的这几个 key，让我们给它指定名称，如果不指定，则使用配置文件中的默认值。</p>\n<p>另外，需要哪些 key，以及 key 的名称是不固定的，你可以根据自己的需要自己定义任意数量的 key，只要保证在模版项目中使用相同的名称，<strong>并且需要带上 <code>cookiecutter</code> 前缀</strong>。</p>\n<p>至此，一个最简单的项目模版就创建完了，你也可以根据自己的需要给这个项目添加一些额外的代码，新建项目时所有额外添加的内容都将原样保留。</p>\n<h3 id=\"钩子\"><a href=\"#钩子\" class=\"headerlink\" title=\"钩子\"></a>钩子</h3><p>上面创建的项目非常简单，但是我们实际开发中一般都需要使用 Cocoapods 来管理第三方依赖，并且有些库几乎是所有项目都需要用到的，比如 <code>Alamofire</code>、<code>SnapKit</code> 等等。那么能不能通过模版一并完成 pods 的配置和安装呢？</p>\n<p>这就可以用上 Cookiecutter 的钩子功能了，钩子通俗一点讲也叫回调，可以在某些特性情况下触发一些事件，执行一些操作等。</p>\n<p>Cookiecutter 的钩子配置非常简单，只需要在配置文件同级目录下新建一个 <code>hooks</code> 目录，然后将写好的脚本放在该目录中，Cookiecutter 会自动调用。</p>\n<p>目前 Cookiecutter 支持两个事件，即创建项目之前和创建项目完成之后，会分别调用对应的脚本文件，目前支持 shell 脚本和 python 脚本。在安装前调用的脚本需要命名为 <code>pre_gen_project.sh</code> 或者 <code>pre_gen_project.py</code>；同样的，在安装之后调用的脚本需要命名为 <code>post_gen_project.sh</code> 或者 <code>post_gen_project.py</code>，取决于脚本使用的语言。</p>\n<h4 id=\"自动安装-pods\"><a href=\"#自动安装-pods\" class=\"headerlink\" title=\"自动安装 pods\"></a>自动安装 pods</h4><p>首先需要在项目目录下，即 <code>/</code> 目录下创建 Podfile 文件，并配置好常用的依赖库：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target <span class=\"string\">'&#123;&#123;cookiecutter.product_name&#125;&#125;'</span> <span class=\"keyword\">do</span></span><br><span class=\"line\"></span><br><span class=\"line\">  use_frameworks!</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Pods for &#123;&#123;cookiecutter.product_name&#125;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Networking</span></span><br><span class=\"line\">  pod <span class=\"string\">'Alamofire'</span></span><br><span class=\"line\">  <span class=\"comment\"># ImageCache</span></span><br><span class=\"line\">  pod <span class=\"string\">'Kingfisher'</span></span><br><span class=\"line\">  <span class=\"comment\"># AutoLayout</span></span><br><span class=\"line\">  pod <span class=\"string\">'SnapKit'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>好了，不要执行 <code>pod install</code>，因为这只是个模版，可能实际创建项目时这些库已经更新了，所以需要在创建项目时才安装依赖。</p>\n<p>接下来打开 <code>post_gen_project.sh</code>, 写上 pod 安装相关的命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">GREEN=<span class=\"string\">'\\033[0;32m'</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"<span class=\"variable\">$&#123;GREEN&#125;</span>Project successfuly generated!\"</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"<span class=\"variable\">$&#123;GREEN&#125;</span>Installing Pods...\"</span></span><br><span class=\"line\">pod install</span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"<span class=\"variable\">$&#123;GREEN&#125;</span>Pods Install Finished\"</span></span><br></pre></td></tr></table></figure>\n\n<p>其实只需要写一句 <code>pod install</code> 就够了，不过为了创建项目时命令行的输出内容能够更加友好，我添加了一些额外的状态输出的内容😏，你也可以在其中添加一些其他需要处理的事务。</p>\n<p>这时候我们的项目框架才算基本完成。此时，我们的项目模版目录应该是类似下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ios_template&#x2F;</span><br><span class=\"line\">├── &#123;&#123;cookiecutter.product_name&#125;&#125;&#x2F;</span><br><span class=\"line\">│   ├── &#123;&#123;cookiecutter.product_name&#125;&#125;.xcodeproj</span><br><span class=\"line\">│   ├── Podfile</span><br><span class=\"line\">│   └── ...</span><br><span class=\"line\">├── hooks</span><br><span class=\"line\">│   ├── pre_gen_project.sh</span><br><span class=\"line\">│   └── post_gen_project.sh</span><br><span class=\"line\">└── cookiecutter.json</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"分发模版\"><a href=\"#分发模版\" class=\"headerlink\" title=\"分发模版\"></a>分发模版</h3><p>模版做完了，放到哪里呢？本地目录也是可以的，Cookiecutter 支持从任何可以访问的路径加载项目模版，不过为了方便使用和团队共享，最好是将模版推送到 git 仓库中，这样也方便后期修改以及多人维护等。</p>\n<p>另外，如果你的模版项目非常大，也可以打包成 zip 上传，Cookiecutter 支持从 zip 包创建项目，创建时会自动解压。</p>\n<h3 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h3><p>创建项目也非常简单，确保 Cookiecutter 已经正确安装后，只需要 cd 到你准备创建项目的目录，然后执行以下命令就好了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cookiecutter https://github.com/Harley-xk/iOS_Template_Comet.git</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>后面的路径可以是本地路径也可以是远程路径，可以是 git，也可以是 zip。Cookiecutter 还支持很多其他的仓库形式，详细可以查看它的文档。</p>\n</blockquote>\n<p>命令执行后就开始创建项目了，Cookiecutter 会对你在配置文件中设置的每一个关键字进行询问，你可以输入新项目需要使用的值，或者也可以直接回车后使用默认值。</p>\n<p>可以看到命令行的输出如下：</p>\n<p><img src=\"/images/cookiecutter/619631-d6add963dcab88b4.png\" alt=\"创建项目\"></p>\n<p>Cookiecutter 会在用户目录下缓存所有安装过的项目模版，下次安装时会询问你是否需要更新模版：</p>\n<blockquote>\n<p>You’ve downloaded /Users/Harley-xk/.cookiecutters/iOS_Template_Comet before. Is it okay to delete and re-download it?</p>\n</blockquote>\n<p>输入 <code>yes</code>，它会自动更新模版后创建项目。</p>\n<p>另外可以看到在创建项目之后 <code>pod install</code> 指令也自动执行了，我们在 Podfile 里面指定的三个依赖库都已经成功安装了。可以进入 MyApp 目录下面，打开 <code>MyApp.xcworkspace</code> 查看创建完毕的项目：</p>\n<p><img src=\"/images/cookiecutter/QQ20190314-153222%402x.png\" alt=\"创建完毕的项目\"></p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>其实可以发现 Cookiecutter 的原理和使用都非常简单。现在项目越做越庞大，架构也越来越复杂，虽然我们可以通过组件化的方式最大化的重用代码，减少工作量，但是依然需要写大量的胶水代码来整合各个组件，做大量的项目配置、项目初始化的工作，通过使用 Cookiecutter，可以进一步节省大量的工作。</p>\n<p><em>ps. 我在 Github 上创建了我自己的 iOS 项目模版，你如果不想自己写，也可以使用<a href=\"https://github.com/Harley-xk/iOS_Template_Comet.git\" target=\"_blank\" rel=\"noopener\">我的模版</a></em></p>\n"},{"title":"UIStatusBarStyle 解惑","abstract":"作为一个强迫症晚期患者，对于 StatusBar 这样的细节也是无法放过的。对于每一个界面，StatusBar 都必须显示成需要的正确的风格，为此呕心沥血，殚精竭虑。。。","_content":"\n> 作为一个强迫症晚期患者，对于 StatusBar 这样的细节也是无法放过的。对于每一个界面，StatusBar 都必须显示成需要的正确的风格，为此呕心沥血，殚精竭虑。。。\n> 而后有了这么一篇总结。\n\n## 原始手段\n\n要实现对 StatusBar Style 的绝对控制，其实有一个最简单粗暴的方法：\n\n```swift\nopen func setStatusBarStyle(_ statusBarStyle: UIStatusBarStyle, animated: Bool)\n```\n\n这是从 iOS 2.0 那个古老的年代就已经存在的方法了，通过它可以直接设置 StatusBar 的 Style。\n\n不过坏消息是，苹果一直在不遗余力地废弃老旧的 API，很不幸的，iOS 9 之后，这个方法也被标记为 **deprecated** 了：\n\n```swift\n@available(iOS, introduced: 2.0, deprecated: 9.0, message: \"Use -[UIViewController preferredStatusBarStyle]\")\nopen func setStatusBarStyle(_ statusBarStyle: UIStatusBarStyle, animated: Bool)\n```\n\n而且如果想要继续使用这个方式来管理 StatusBar Style 的话，还需要在 `Info.plist` 文件中设置：`View controller-based status bar appearance ` 为 `NO`。\n\n对于一个强迫症晚期患者，代码里面满篇的 **deprecated** 警告以及 ` Info.plist ` 中额外的设置项是更加无法容忍的，这条路被无情地堵死了🙁\n\n## 新的方向\n\n其实 `setStatusBarStyle` 方法被废除也是意料之中的，如今编程思想已经在不知不觉中进步了不少，远古时代这种面向实现的编程思想已经与现如今的协议式编程相去甚远了。虽然老方法能够简单粗暴地解决问题，但是同样也留下了许多后遗症，比如在太过复杂的逻辑中，直接设置 StatusBar 的 Style 往往会造成混乱，最终得不到我们想要的效果；另外，由于我们可以在任何地方、任何代码逻辑中改变 StatusBar 的 Style，这对后期维护来说往往是灾难性的，最终导致得不偿失。\n\n其实苹果早在 iOS 7 中就与时俱进地提供了新的控制 Status Bar Style 的体系，也就是上面的 `View controller-based status bar appearance`，通过限制改变 Status Bar Style 的自由性，转而交由 `View Controller` 去负责自己生命周期中的 Status Bar Style 控制。这么一来，整个思路都变得更佳清晰和优雅了。\n\n### 基本方式\n\n在新的体系下工作其实更简单了，只需要在 ViewController 中重写相关属性即可：\n\n```swift\noverride var preferredStatusBarStyle: UIStatusBarStyle {\n\treturn .lightContent\n}\n```\n\nApp 在运行过程中，始终由在 UI 最顶端的 ViewController 的 `preferredStatusBarStyle` 属性来决定当前 Status Bar 的 Style。当我们需要更改 Style 时，只需要在 `preferredStatusBarStyle` 计算方法中返回新的 `style` 属性值，然后调用 `setNeedsStatusBarAppearanceUpdate()` 方法即可：\n\n```swift\noverride var preferredStatusBarStyle: UIStatusBarStyle {\n\tif needsLightContent {\n\t\treturn .lightContent\n\t} else {\n\t\treturn .default\n\t}\n}\n    \nprivate func changeStyle() {\n\tneedsLightContent = true\n\tsetNeedsStatusBarAppearanceUpdate()\n}\n```\n\n通过这种模式，我们始终通过 `ViewController` 来管理 Status Bar 的 Style，就算需要更新它的状态，也是通过间接的方式通知到 `ViewController` ，而不是直接改变 Status Bar 的属性。这样，后期的代码维护工作也可以更加轻松了。\n\n### 分发控制权限\n\n如果顶部的 `ViewController` 只是一个空壳，实际的 UI 逻辑都是由添加到之上的  `ChildController` 来控制的，那么这时候你可以通过重写 `childViewControllerForStatusBarStyle` 属性将 Status Bar Style 的控制权分发到对应的`ChildController` 中去：\n\n```swift\noverride var childViewControllerForStatusBarStyle: UIViewController? {\n\tlet currentChildViewController = childViewControllers[0]\n\treturn currentChildViewController\n}\n```\n\n### 特殊情况\n\n当然，新的模式也引入了新的规则(keng)，我们在体会新的简单粗暴的手段时，也遇到了新的问题：如果不同的 `ViewController` 争夺控制权怎么办？比如 `Navigation` 和 `Modal Presentation` 这两个另类，他们都是一个 `ViewController` 嵌套在另一个 `ViewController` 的典型代表，这时候到底是谁说了算？\n\n有坑就得填，首先拿 Navigation 开刀。\n\n#### Navigation\n\n当 UI 最顶层的 `ViewController` 嵌套在 UINavigationController 中时，UINavigationController 和 栈顶的 `ContentViewController` 都想争夺 Status Bar 的控制权，如果不加以控制，那刚刚建立的新秩序立刻就要被破坏了，于是我们有了下面的规则：\n\n- 当 `Navigation Bar` 不可见时，由栈顶的 `ContentViewController` 负责管理 Status Bar 的 Style\n\n- 当 `Navigation Bar` 可见时，由 `NavigationController` 负责管理 Status Bar 的 Style\n\n  这时候，由于 `Navigation Bar` 处于可视状态，因此 Status Bar 需要与 `Navigation Bar` 的风格保持一致，因此由 `NavigationController` 来控制 Status Bar Style 是最合理的。\n\n  但是这时候同样存在新的问题：`NavigationController` 往往都是使用系统默认的 `UINavigationController` 类，如果这时候的 Status Bar Style 不符合我们的需求怎么办？如果不继承 `UINavigationController` 就没法重写 `preferredStatusBarStyle` 属性；如果继承了 `UINavigationController` ，虽然可以实现需求，但是一来破坏了代码的简洁性，并且苹果是不建议继承 `UINavigationController` 的，二来有许多系统组件是直接继承自 `UINavigationController` 的（比如 `MFMailComposeViewController`），这时候继承也只是然并卵了。那么有什么办法可以解决这个问题呢？\n\n必须有，苹果早就考虑到了这一点，于是针对 `UINavigationBar` 做了一番工作，提供了设置 Status Bar Style 的入口：`barStyle` 属性。`barStyle` 属性决定了 `NavigationBar` 的外观，因此，修改 `barStyle` 属性会联动改变 Status Bar 的 Style：\n\n-   当 `barStyle` = `.default` 时，`NavigationBar` 显示为黑色，此时 `StatusBar`  显示为白色\n  - 当 `barStyle` = `.black` 时，`NavigationBar` 显示为白色，此时 `StatusBar`  显示为黑色\n\n  所以，如果通过设置 `barTintColor` 自定义了 `NavigationBar` 的颜色，这时候就需要设置 `barStyle` 属性来告知 `NavigationController` 正确的 Status Bar Style。\n\n  *另外需要注意的是，由于某种原因，设置 `barStyle` 后会改变 `barTintColor`  的值，因此需要先修改 `barStyle` 属性，然后再设置 `barTintColor`。\n\n#### Modal Presentation\n\n在了解了 Navigation 之后，Model Presentation 的逻辑相对简单，通过 Modal Presentation 呈现的视图，如果也是嵌套在 `NavigationController` 中的话，此时的规则和 Navigaion 中描述的一致，否则的话同样由最顶端的 `ViewController` 来决定 Status Bar 的 Style。\n\n需要注意的是，Modal Presentation 的逻辑有一个**前提条件**，只有当 `modalPresentationStyle` 的属性为 `.fullScreen` ，也就是全屏 Presentation 时，呈现出的视图才对 Status Bar Style 有发言权，否则还是由原先的 `ViewController` 来控制。\n\n但是，凡事都有个但是不是么，如果你的强迫症已经无药可救了，非要在不全屏 Presentation 的 ViewController 中控制 Status Bar 的 Style，其实也不是不可以，`modalPresentationCapturesStatusBarAppearance` 是专门为强迫症患者量身定制的，只需要重写这个属性并返回 `true` ，你就可以在任何形式的 Model Presentation 中获得对 Status Bar Style 的控制权了。\n\n## 结语\n\nUIStatusBar 是大多数 App 都需要接触到的，但是往往也是最容易被忽视的一个细节，我们见过太多状态栏显示异常的 App (也包括某些大公司的产品)。很多时候这个代表了一个人、一个团队做事、做产品的态度。我一贯认为应该以对待一个艺术品而不是商品生产线的态度去开发软件，任何的细节都不应该放过。与其整天高谈阔论所谓的算法、性能，倒不如先从手头的细节做起，完善每一处用户体验，杜绝劣质 App。","source":"_posts/status-bar-styles.md","raw":"---\ntitle: UIStatusBarStyle 解惑\nabstract: 作为一个强迫症晚期患者，对于 StatusBar 这样的细节也是无法放过的。对于每一个界面，StatusBar 都必须显示成需要的正确的风格，为此呕心沥血，殚精竭虑。。。\n---\n\n> 作为一个强迫症晚期患者，对于 StatusBar 这样的细节也是无法放过的。对于每一个界面，StatusBar 都必须显示成需要的正确的风格，为此呕心沥血，殚精竭虑。。。\n> 而后有了这么一篇总结。\n\n## 原始手段\n\n要实现对 StatusBar Style 的绝对控制，其实有一个最简单粗暴的方法：\n\n```swift\nopen func setStatusBarStyle(_ statusBarStyle: UIStatusBarStyle, animated: Bool)\n```\n\n这是从 iOS 2.0 那个古老的年代就已经存在的方法了，通过它可以直接设置 StatusBar 的 Style。\n\n不过坏消息是，苹果一直在不遗余力地废弃老旧的 API，很不幸的，iOS 9 之后，这个方法也被标记为 **deprecated** 了：\n\n```swift\n@available(iOS, introduced: 2.0, deprecated: 9.0, message: \"Use -[UIViewController preferredStatusBarStyle]\")\nopen func setStatusBarStyle(_ statusBarStyle: UIStatusBarStyle, animated: Bool)\n```\n\n而且如果想要继续使用这个方式来管理 StatusBar Style 的话，还需要在 `Info.plist` 文件中设置：`View controller-based status bar appearance ` 为 `NO`。\n\n对于一个强迫症晚期患者，代码里面满篇的 **deprecated** 警告以及 ` Info.plist ` 中额外的设置项是更加无法容忍的，这条路被无情地堵死了🙁\n\n## 新的方向\n\n其实 `setStatusBarStyle` 方法被废除也是意料之中的，如今编程思想已经在不知不觉中进步了不少，远古时代这种面向实现的编程思想已经与现如今的协议式编程相去甚远了。虽然老方法能够简单粗暴地解决问题，但是同样也留下了许多后遗症，比如在太过复杂的逻辑中，直接设置 StatusBar 的 Style 往往会造成混乱，最终得不到我们想要的效果；另外，由于我们可以在任何地方、任何代码逻辑中改变 StatusBar 的 Style，这对后期维护来说往往是灾难性的，最终导致得不偿失。\n\n其实苹果早在 iOS 7 中就与时俱进地提供了新的控制 Status Bar Style 的体系，也就是上面的 `View controller-based status bar appearance`，通过限制改变 Status Bar Style 的自由性，转而交由 `View Controller` 去负责自己生命周期中的 Status Bar Style 控制。这么一来，整个思路都变得更佳清晰和优雅了。\n\n### 基本方式\n\n在新的体系下工作其实更简单了，只需要在 ViewController 中重写相关属性即可：\n\n```swift\noverride var preferredStatusBarStyle: UIStatusBarStyle {\n\treturn .lightContent\n}\n```\n\nApp 在运行过程中，始终由在 UI 最顶端的 ViewController 的 `preferredStatusBarStyle` 属性来决定当前 Status Bar 的 Style。当我们需要更改 Style 时，只需要在 `preferredStatusBarStyle` 计算方法中返回新的 `style` 属性值，然后调用 `setNeedsStatusBarAppearanceUpdate()` 方法即可：\n\n```swift\noverride var preferredStatusBarStyle: UIStatusBarStyle {\n\tif needsLightContent {\n\t\treturn .lightContent\n\t} else {\n\t\treturn .default\n\t}\n}\n    \nprivate func changeStyle() {\n\tneedsLightContent = true\n\tsetNeedsStatusBarAppearanceUpdate()\n}\n```\n\n通过这种模式，我们始终通过 `ViewController` 来管理 Status Bar 的 Style，就算需要更新它的状态，也是通过间接的方式通知到 `ViewController` ，而不是直接改变 Status Bar 的属性。这样，后期的代码维护工作也可以更加轻松了。\n\n### 分发控制权限\n\n如果顶部的 `ViewController` 只是一个空壳，实际的 UI 逻辑都是由添加到之上的  `ChildController` 来控制的，那么这时候你可以通过重写 `childViewControllerForStatusBarStyle` 属性将 Status Bar Style 的控制权分发到对应的`ChildController` 中去：\n\n```swift\noverride var childViewControllerForStatusBarStyle: UIViewController? {\n\tlet currentChildViewController = childViewControllers[0]\n\treturn currentChildViewController\n}\n```\n\n### 特殊情况\n\n当然，新的模式也引入了新的规则(keng)，我们在体会新的简单粗暴的手段时，也遇到了新的问题：如果不同的 `ViewController` 争夺控制权怎么办？比如 `Navigation` 和 `Modal Presentation` 这两个另类，他们都是一个 `ViewController` 嵌套在另一个 `ViewController` 的典型代表，这时候到底是谁说了算？\n\n有坑就得填，首先拿 Navigation 开刀。\n\n#### Navigation\n\n当 UI 最顶层的 `ViewController` 嵌套在 UINavigationController 中时，UINavigationController 和 栈顶的 `ContentViewController` 都想争夺 Status Bar 的控制权，如果不加以控制，那刚刚建立的新秩序立刻就要被破坏了，于是我们有了下面的规则：\n\n- 当 `Navigation Bar` 不可见时，由栈顶的 `ContentViewController` 负责管理 Status Bar 的 Style\n\n- 当 `Navigation Bar` 可见时，由 `NavigationController` 负责管理 Status Bar 的 Style\n\n  这时候，由于 `Navigation Bar` 处于可视状态，因此 Status Bar 需要与 `Navigation Bar` 的风格保持一致，因此由 `NavigationController` 来控制 Status Bar Style 是最合理的。\n\n  但是这时候同样存在新的问题：`NavigationController` 往往都是使用系统默认的 `UINavigationController` 类，如果这时候的 Status Bar Style 不符合我们的需求怎么办？如果不继承 `UINavigationController` 就没法重写 `preferredStatusBarStyle` 属性；如果继承了 `UINavigationController` ，虽然可以实现需求，但是一来破坏了代码的简洁性，并且苹果是不建议继承 `UINavigationController` 的，二来有许多系统组件是直接继承自 `UINavigationController` 的（比如 `MFMailComposeViewController`），这时候继承也只是然并卵了。那么有什么办法可以解决这个问题呢？\n\n必须有，苹果早就考虑到了这一点，于是针对 `UINavigationBar` 做了一番工作，提供了设置 Status Bar Style 的入口：`barStyle` 属性。`barStyle` 属性决定了 `NavigationBar` 的外观，因此，修改 `barStyle` 属性会联动改变 Status Bar 的 Style：\n\n-   当 `barStyle` = `.default` 时，`NavigationBar` 显示为黑色，此时 `StatusBar`  显示为白色\n  - 当 `barStyle` = `.black` 时，`NavigationBar` 显示为白色，此时 `StatusBar`  显示为黑色\n\n  所以，如果通过设置 `barTintColor` 自定义了 `NavigationBar` 的颜色，这时候就需要设置 `barStyle` 属性来告知 `NavigationController` 正确的 Status Bar Style。\n\n  *另外需要注意的是，由于某种原因，设置 `barStyle` 后会改变 `barTintColor`  的值，因此需要先修改 `barStyle` 属性，然后再设置 `barTintColor`。\n\n#### Modal Presentation\n\n在了解了 Navigation 之后，Model Presentation 的逻辑相对简单，通过 Modal Presentation 呈现的视图，如果也是嵌套在 `NavigationController` 中的话，此时的规则和 Navigaion 中描述的一致，否则的话同样由最顶端的 `ViewController` 来决定 Status Bar 的 Style。\n\n需要注意的是，Modal Presentation 的逻辑有一个**前提条件**，只有当 `modalPresentationStyle` 的属性为 `.fullScreen` ，也就是全屏 Presentation 时，呈现出的视图才对 Status Bar Style 有发言权，否则还是由原先的 `ViewController` 来控制。\n\n但是，凡事都有个但是不是么，如果你的强迫症已经无药可救了，非要在不全屏 Presentation 的 ViewController 中控制 Status Bar 的 Style，其实也不是不可以，`modalPresentationCapturesStatusBarAppearance` 是专门为强迫症患者量身定制的，只需要重写这个属性并返回 `true` ，你就可以在任何形式的 Model Presentation 中获得对 Status Bar Style 的控制权了。\n\n## 结语\n\nUIStatusBar 是大多数 App 都需要接触到的，但是往往也是最容易被忽视的一个细节，我们见过太多状态栏显示异常的 App (也包括某些大公司的产品)。很多时候这个代表了一个人、一个团队做事、做产品的态度。我一贯认为应该以对待一个艺术品而不是商品生产线的态度去开发软件，任何的细节都不应该放过。与其整天高谈阔论所谓的算法、性能，倒不如先从手头的细节做起，完善每一处用户体验，杜绝劣质 App。","slug":"status-bar-styles","published":1,"date":"2017-04-25T08:26:28.000Z","updated":"2020-01-31T03:42:47.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck61tll2g0002ufqb7zru5u1o","content":"<blockquote>\n<p>作为一个强迫症晚期患者，对于 StatusBar 这样的细节也是无法放过的。对于每一个界面，StatusBar 都必须显示成需要的正确的风格，为此呕心沥血，殚精竭虑。。。<br>而后有了这么一篇总结。</p>\n</blockquote>\n<h2 id=\"原始手段\"><a href=\"#原始手段\" class=\"headerlink\" title=\"原始手段\"></a>原始手段</h2><p>要实现对 StatusBar Style 的绝对控制，其实有一个最简单粗暴的方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setStatusBarStyle</span><span class=\"params\">(<span class=\"number\">_</span> statusBarStyle: UIStatusBarStyle, animated: Bool)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这是从 iOS 2.0 那个古老的年代就已经存在的方法了，通过它可以直接设置 StatusBar 的 Style。</p>\n<p>不过坏消息是，苹果一直在不遗余力地废弃老旧的 API，很不幸的，iOS 9 之后，这个方法也被标记为 <strong>deprecated</strong> 了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@available</span>(iOS, introduced: <span class=\"number\">2.0</span>, deprecated: <span class=\"number\">9.0</span>, message: <span class=\"string\">\"Use -[UIViewController preferredStatusBarStyle]\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setStatusBarStyle</span><span class=\"params\">(<span class=\"number\">_</span> statusBarStyle: UIStatusBarStyle, animated: Bool)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>而且如果想要继续使用这个方式来管理 StatusBar Style 的话，还需要在 <code>Info.plist</code> 文件中设置：<code>View controller-based status bar appearance</code> 为 <code>NO</code>。</p>\n<p>对于一个强迫症晚期患者，代码里面满篇的 <strong>deprecated</strong> 警告以及 <code>Info.plist</code> 中额外的设置项是更加无法容忍的，这条路被无情地堵死了🙁</p>\n<h2 id=\"新的方向\"><a href=\"#新的方向\" class=\"headerlink\" title=\"新的方向\"></a>新的方向</h2><p>其实 <code>setStatusBarStyle</code> 方法被废除也是意料之中的，如今编程思想已经在不知不觉中进步了不少，远古时代这种面向实现的编程思想已经与现如今的协议式编程相去甚远了。虽然老方法能够简单粗暴地解决问题，但是同样也留下了许多后遗症，比如在太过复杂的逻辑中，直接设置 StatusBar 的 Style 往往会造成混乱，最终得不到我们想要的效果；另外，由于我们可以在任何地方、任何代码逻辑中改变 StatusBar 的 Style，这对后期维护来说往往是灾难性的，最终导致得不偿失。</p>\n<p>其实苹果早在 iOS 7 中就与时俱进地提供了新的控制 Status Bar Style 的体系，也就是上面的 <code>View controller-based status bar appearance</code>，通过限制改变 Status Bar Style 的自由性，转而交由 <code>View Controller</code> 去负责自己生命周期中的 Status Bar Style 控制。这么一来，整个思路都变得更佳清晰和优雅了。</p>\n<h3 id=\"基本方式\"><a href=\"#基本方式\" class=\"headerlink\" title=\"基本方式\"></a>基本方式</h3><p>在新的体系下工作其实更简单了，只需要在 ViewController 中重写相关属性即可：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> preferredStatusBarStyle: <span class=\"type\">UIStatusBarStyle</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> .lightContent</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>App 在运行过程中，始终由在 UI 最顶端的 ViewController 的 <code>preferredStatusBarStyle</code> 属性来决定当前 Status Bar 的 Style。当我们需要更改 Style 时，只需要在 <code>preferredStatusBarStyle</code> 计算方法中返回新的 <code>style</code> 属性值，然后调用 <code>setNeedsStatusBarAppearanceUpdate()</code> 方法即可：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> preferredStatusBarStyle: <span class=\"type\">UIStatusBarStyle</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> needsLightContent &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> .lightContent</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> .<span class=\"keyword\">default</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">changeStyle</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tneedsLightContent = <span class=\"literal\">true</span></span><br><span class=\"line\">\tsetNeedsStatusBarAppearanceUpdate()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这种模式，我们始终通过 <code>ViewController</code> 来管理 Status Bar 的 Style，就算需要更新它的状态，也是通过间接的方式通知到 <code>ViewController</code> ，而不是直接改变 Status Bar 的属性。这样，后期的代码维护工作也可以更加轻松了。</p>\n<h3 id=\"分发控制权限\"><a href=\"#分发控制权限\" class=\"headerlink\" title=\"分发控制权限\"></a>分发控制权限</h3><p>如果顶部的 <code>ViewController</code> 只是一个空壳，实际的 UI 逻辑都是由添加到之上的  <code>ChildController</code> 来控制的，那么这时候你可以通过重写 <code>childViewControllerForStatusBarStyle</code> 属性将 Status Bar Style 的控制权分发到对应的<code>ChildController</code> 中去：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> childViewControllerForStatusBarStyle: <span class=\"type\">UIViewController?</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> currentChildViewController = childViewControllers[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> currentChildViewController</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特殊情况\"><a href=\"#特殊情况\" class=\"headerlink\" title=\"特殊情况\"></a>特殊情况</h3><p>当然，新的模式也引入了新的规则(keng)，我们在体会新的简单粗暴的手段时，也遇到了新的问题：如果不同的 <code>ViewController</code> 争夺控制权怎么办？比如 <code>Navigation</code> 和 <code>Modal Presentation</code> 这两个另类，他们都是一个 <code>ViewController</code> 嵌套在另一个 <code>ViewController</code> 的典型代表，这时候到底是谁说了算？</p>\n<p>有坑就得填，首先拿 Navigation 开刀。</p>\n<h4 id=\"Navigation\"><a href=\"#Navigation\" class=\"headerlink\" title=\"Navigation\"></a>Navigation</h4><p>当 UI 最顶层的 <code>ViewController</code> 嵌套在 UINavigationController 中时，UINavigationController 和 栈顶的 <code>ContentViewController</code> 都想争夺 Status Bar 的控制权，如果不加以控制，那刚刚建立的新秩序立刻就要被破坏了，于是我们有了下面的规则：</p>\n<ul>\n<li><p>当 <code>Navigation Bar</code> 不可见时，由栈顶的 <code>ContentViewController</code> 负责管理 Status Bar 的 Style</p>\n</li>\n<li><p>当 <code>Navigation Bar</code> 可见时，由 <code>NavigationController</code> 负责管理 Status Bar 的 Style</p>\n<p>这时候，由于 <code>Navigation Bar</code> 处于可视状态，因此 Status Bar 需要与 <code>Navigation Bar</code> 的风格保持一致，因此由 <code>NavigationController</code> 来控制 Status Bar Style 是最合理的。</p>\n<p>但是这时候同样存在新的问题：<code>NavigationController</code> 往往都是使用系统默认的 <code>UINavigationController</code> 类，如果这时候的 Status Bar Style 不符合我们的需求怎么办？如果不继承 <code>UINavigationController</code> 就没法重写 <code>preferredStatusBarStyle</code> 属性；如果继承了 <code>UINavigationController</code> ，虽然可以实现需求，但是一来破坏了代码的简洁性，并且苹果是不建议继承 <code>UINavigationController</code> 的，二来有许多系统组件是直接继承自 <code>UINavigationController</code> 的（比如 <code>MFMailComposeViewController</code>），这时候继承也只是然并卵了。那么有什么办法可以解决这个问题呢？</p>\n</li>\n</ul>\n<p>必须有，苹果早就考虑到了这一点，于是针对 <code>UINavigationBar</code> 做了一番工作，提供了设置 Status Bar Style 的入口：<code>barStyle</code> 属性。<code>barStyle</code> 属性决定了 <code>NavigationBar</code> 的外观，因此，修改 <code>barStyle</code> 属性会联动改变 Status Bar 的 Style：</p>\n<ul>\n<li><p>当 <code>barStyle</code> = <code>.default</code> 时，<code>NavigationBar</code> 显示为黑色，此时 <code>StatusBar</code>  显示为白色</p>\n<ul>\n<li>当 <code>barStyle</code> = <code>.black</code> 时，<code>NavigationBar</code> 显示为白色，此时 <code>StatusBar</code>  显示为黑色</li>\n</ul>\n<p>所以，如果通过设置 <code>barTintColor</code> 自定义了 <code>NavigationBar</code> 的颜色，这时候就需要设置 <code>barStyle</code> 属性来告知 <code>NavigationController</code> 正确的 Status Bar Style。</p>\n<p>*另外需要注意的是，由于某种原因，设置 <code>barStyle</code> 后会改变 <code>barTintColor</code>  的值，因此需要先修改 <code>barStyle</code> 属性，然后再设置 <code>barTintColor</code>。</p>\n</li>\n</ul>\n<h4 id=\"Modal-Presentation\"><a href=\"#Modal-Presentation\" class=\"headerlink\" title=\"Modal Presentation\"></a>Modal Presentation</h4><p>在了解了 Navigation 之后，Model Presentation 的逻辑相对简单，通过 Modal Presentation 呈现的视图，如果也是嵌套在 <code>NavigationController</code> 中的话，此时的规则和 Navigaion 中描述的一致，否则的话同样由最顶端的 <code>ViewController</code> 来决定 Status Bar 的 Style。</p>\n<p>需要注意的是，Modal Presentation 的逻辑有一个<strong>前提条件</strong>，只有当 <code>modalPresentationStyle</code> 的属性为 <code>.fullScreen</code> ，也就是全屏 Presentation 时，呈现出的视图才对 Status Bar Style 有发言权，否则还是由原先的 <code>ViewController</code> 来控制。</p>\n<p>但是，凡事都有个但是不是么，如果你的强迫症已经无药可救了，非要在不全屏 Presentation 的 ViewController 中控制 Status Bar 的 Style，其实也不是不可以，<code>modalPresentationCapturesStatusBarAppearance</code> 是专门为强迫症患者量身定制的，只需要重写这个属性并返回 <code>true</code> ，你就可以在任何形式的 Model Presentation 中获得对 Status Bar Style 的控制权了。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>UIStatusBar 是大多数 App 都需要接触到的，但是往往也是最容易被忽视的一个细节，我们见过太多状态栏显示异常的 App (也包括某些大公司的产品)。很多时候这个代表了一个人、一个团队做事、做产品的态度。我一贯认为应该以对待一个艺术品而不是商品生产线的态度去开发软件，任何的细节都不应该放过。与其整天高谈阔论所谓的算法、性能，倒不如先从手头的细节做起，完善每一处用户体验，杜绝劣质 App。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>作为一个强迫症晚期患者，对于 StatusBar 这样的细节也是无法放过的。对于每一个界面，StatusBar 都必须显示成需要的正确的风格，为此呕心沥血，殚精竭虑。。。<br>而后有了这么一篇总结。</p>\n</blockquote>\n<h2 id=\"原始手段\"><a href=\"#原始手段\" class=\"headerlink\" title=\"原始手段\"></a>原始手段</h2><p>要实现对 StatusBar Style 的绝对控制，其实有一个最简单粗暴的方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setStatusBarStyle</span><span class=\"params\">(<span class=\"number\">_</span> statusBarStyle: UIStatusBarStyle, animated: Bool)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这是从 iOS 2.0 那个古老的年代就已经存在的方法了，通过它可以直接设置 StatusBar 的 Style。</p>\n<p>不过坏消息是，苹果一直在不遗余力地废弃老旧的 API，很不幸的，iOS 9 之后，这个方法也被标记为 <strong>deprecated</strong> 了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@available</span>(iOS, introduced: <span class=\"number\">2.0</span>, deprecated: <span class=\"number\">9.0</span>, message: <span class=\"string\">\"Use -[UIViewController preferredStatusBarStyle]\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setStatusBarStyle</span><span class=\"params\">(<span class=\"number\">_</span> statusBarStyle: UIStatusBarStyle, animated: Bool)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>而且如果想要继续使用这个方式来管理 StatusBar Style 的话，还需要在 <code>Info.plist</code> 文件中设置：<code>View controller-based status bar appearance</code> 为 <code>NO</code>。</p>\n<p>对于一个强迫症晚期患者，代码里面满篇的 <strong>deprecated</strong> 警告以及 <code>Info.plist</code> 中额外的设置项是更加无法容忍的，这条路被无情地堵死了🙁</p>\n<h2 id=\"新的方向\"><a href=\"#新的方向\" class=\"headerlink\" title=\"新的方向\"></a>新的方向</h2><p>其实 <code>setStatusBarStyle</code> 方法被废除也是意料之中的，如今编程思想已经在不知不觉中进步了不少，远古时代这种面向实现的编程思想已经与现如今的协议式编程相去甚远了。虽然老方法能够简单粗暴地解决问题，但是同样也留下了许多后遗症，比如在太过复杂的逻辑中，直接设置 StatusBar 的 Style 往往会造成混乱，最终得不到我们想要的效果；另外，由于我们可以在任何地方、任何代码逻辑中改变 StatusBar 的 Style，这对后期维护来说往往是灾难性的，最终导致得不偿失。</p>\n<p>其实苹果早在 iOS 7 中就与时俱进地提供了新的控制 Status Bar Style 的体系，也就是上面的 <code>View controller-based status bar appearance</code>，通过限制改变 Status Bar Style 的自由性，转而交由 <code>View Controller</code> 去负责自己生命周期中的 Status Bar Style 控制。这么一来，整个思路都变得更佳清晰和优雅了。</p>\n<h3 id=\"基本方式\"><a href=\"#基本方式\" class=\"headerlink\" title=\"基本方式\"></a>基本方式</h3><p>在新的体系下工作其实更简单了，只需要在 ViewController 中重写相关属性即可：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> preferredStatusBarStyle: <span class=\"type\">UIStatusBarStyle</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> .lightContent</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>App 在运行过程中，始终由在 UI 最顶端的 ViewController 的 <code>preferredStatusBarStyle</code> 属性来决定当前 Status Bar 的 Style。当我们需要更改 Style 时，只需要在 <code>preferredStatusBarStyle</code> 计算方法中返回新的 <code>style</code> 属性值，然后调用 <code>setNeedsStatusBarAppearanceUpdate()</code> 方法即可：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> preferredStatusBarStyle: <span class=\"type\">UIStatusBarStyle</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> needsLightContent &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> .lightContent</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> .<span class=\"keyword\">default</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">changeStyle</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tneedsLightContent = <span class=\"literal\">true</span></span><br><span class=\"line\">\tsetNeedsStatusBarAppearanceUpdate()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这种模式，我们始终通过 <code>ViewController</code> 来管理 Status Bar 的 Style，就算需要更新它的状态，也是通过间接的方式通知到 <code>ViewController</code> ，而不是直接改变 Status Bar 的属性。这样，后期的代码维护工作也可以更加轻松了。</p>\n<h3 id=\"分发控制权限\"><a href=\"#分发控制权限\" class=\"headerlink\" title=\"分发控制权限\"></a>分发控制权限</h3><p>如果顶部的 <code>ViewController</code> 只是一个空壳，实际的 UI 逻辑都是由添加到之上的  <code>ChildController</code> 来控制的，那么这时候你可以通过重写 <code>childViewControllerForStatusBarStyle</code> 属性将 Status Bar Style 的控制权分发到对应的<code>ChildController</code> 中去：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">var</span> childViewControllerForStatusBarStyle: <span class=\"type\">UIViewController?</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> currentChildViewController = childViewControllers[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> currentChildViewController</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特殊情况\"><a href=\"#特殊情况\" class=\"headerlink\" title=\"特殊情况\"></a>特殊情况</h3><p>当然，新的模式也引入了新的规则(keng)，我们在体会新的简单粗暴的手段时，也遇到了新的问题：如果不同的 <code>ViewController</code> 争夺控制权怎么办？比如 <code>Navigation</code> 和 <code>Modal Presentation</code> 这两个另类，他们都是一个 <code>ViewController</code> 嵌套在另一个 <code>ViewController</code> 的典型代表，这时候到底是谁说了算？</p>\n<p>有坑就得填，首先拿 Navigation 开刀。</p>\n<h4 id=\"Navigation\"><a href=\"#Navigation\" class=\"headerlink\" title=\"Navigation\"></a>Navigation</h4><p>当 UI 最顶层的 <code>ViewController</code> 嵌套在 UINavigationController 中时，UINavigationController 和 栈顶的 <code>ContentViewController</code> 都想争夺 Status Bar 的控制权，如果不加以控制，那刚刚建立的新秩序立刻就要被破坏了，于是我们有了下面的规则：</p>\n<ul>\n<li><p>当 <code>Navigation Bar</code> 不可见时，由栈顶的 <code>ContentViewController</code> 负责管理 Status Bar 的 Style</p>\n</li>\n<li><p>当 <code>Navigation Bar</code> 可见时，由 <code>NavigationController</code> 负责管理 Status Bar 的 Style</p>\n<p>这时候，由于 <code>Navigation Bar</code> 处于可视状态，因此 Status Bar 需要与 <code>Navigation Bar</code> 的风格保持一致，因此由 <code>NavigationController</code> 来控制 Status Bar Style 是最合理的。</p>\n<p>但是这时候同样存在新的问题：<code>NavigationController</code> 往往都是使用系统默认的 <code>UINavigationController</code> 类，如果这时候的 Status Bar Style 不符合我们的需求怎么办？如果不继承 <code>UINavigationController</code> 就没法重写 <code>preferredStatusBarStyle</code> 属性；如果继承了 <code>UINavigationController</code> ，虽然可以实现需求，但是一来破坏了代码的简洁性，并且苹果是不建议继承 <code>UINavigationController</code> 的，二来有许多系统组件是直接继承自 <code>UINavigationController</code> 的（比如 <code>MFMailComposeViewController</code>），这时候继承也只是然并卵了。那么有什么办法可以解决这个问题呢？</p>\n</li>\n</ul>\n<p>必须有，苹果早就考虑到了这一点，于是针对 <code>UINavigationBar</code> 做了一番工作，提供了设置 Status Bar Style 的入口：<code>barStyle</code> 属性。<code>barStyle</code> 属性决定了 <code>NavigationBar</code> 的外观，因此，修改 <code>barStyle</code> 属性会联动改变 Status Bar 的 Style：</p>\n<ul>\n<li><p>当 <code>barStyle</code> = <code>.default</code> 时，<code>NavigationBar</code> 显示为黑色，此时 <code>StatusBar</code>  显示为白色</p>\n<ul>\n<li>当 <code>barStyle</code> = <code>.black</code> 时，<code>NavigationBar</code> 显示为白色，此时 <code>StatusBar</code>  显示为黑色</li>\n</ul>\n<p>所以，如果通过设置 <code>barTintColor</code> 自定义了 <code>NavigationBar</code> 的颜色，这时候就需要设置 <code>barStyle</code> 属性来告知 <code>NavigationController</code> 正确的 Status Bar Style。</p>\n<p>*另外需要注意的是，由于某种原因，设置 <code>barStyle</code> 后会改变 <code>barTintColor</code>  的值，因此需要先修改 <code>barStyle</code> 属性，然后再设置 <code>barTintColor</code>。</p>\n</li>\n</ul>\n<h4 id=\"Modal-Presentation\"><a href=\"#Modal-Presentation\" class=\"headerlink\" title=\"Modal Presentation\"></a>Modal Presentation</h4><p>在了解了 Navigation 之后，Model Presentation 的逻辑相对简单，通过 Modal Presentation 呈现的视图，如果也是嵌套在 <code>NavigationController</code> 中的话，此时的规则和 Navigaion 中描述的一致，否则的话同样由最顶端的 <code>ViewController</code> 来决定 Status Bar 的 Style。</p>\n<p>需要注意的是，Modal Presentation 的逻辑有一个<strong>前提条件</strong>，只有当 <code>modalPresentationStyle</code> 的属性为 <code>.fullScreen</code> ，也就是全屏 Presentation 时，呈现出的视图才对 Status Bar Style 有发言权，否则还是由原先的 <code>ViewController</code> 来控制。</p>\n<p>但是，凡事都有个但是不是么，如果你的强迫症已经无药可救了，非要在不全屏 Presentation 的 ViewController 中控制 Status Bar 的 Style，其实也不是不可以，<code>modalPresentationCapturesStatusBarAppearance</code> 是专门为强迫症患者量身定制的，只需要重写这个属性并返回 <code>true</code> ，你就可以在任何形式的 Model Presentation 中获得对 Status Bar Style 的控制权了。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>UIStatusBar 是大多数 App 都需要接触到的，但是往往也是最容易被忽视的一个细节，我们见过太多状态栏显示异常的 App (也包括某些大公司的产品)。很多时候这个代表了一个人、一个团队做事、做产品的态度。我一贯认为应该以对待一个艺术品而不是商品生产线的态度去开发软件，任何的细节都不应该放过。与其整天高谈阔论所谓的算法、性能，倒不如先从手头的细节做起，完善每一处用户体验，杜绝劣质 App。</p>\n"},{"title":"使用 Assets Processor 处理 Xcode 图片资源","abstract":"自从 Xcode ghost 事件之后，苹果直接在 8.0以上的版本中禁止了 Xcode 的第三方插件。苹果一直很霸道，这么做虽然确实保证了安全性，但是却同时打死了好多确实很方便和实用的插件，比如RTImageAssets。虽然苹果另外提供了 Code Editor Extension 作为补充，但是一来生态完善程度不足，这方面的扩展程序还太少，二来限制太多，很多功能无法作为代码编辑器的插件存在。","_content":"\n> 自从 Xcode ghost 事件之后，苹果直接在 8.0以上的版本中禁止了 Xcode 的第三方插件。苹果一直很霸道，这么做虽然确实保证了安全性，但是却同时打死了好多确实很方便和实用的插件，比如说 [**RTImageAssets**](https://github.com/rickytan/RTImageAssets)。\n> 虽然苹果另外提供了 Code Editor Extension 作为补充，但是一来生态完善程度不足，这方面的扩展程序还太少，二来限制太多，很多功能无法作为代码编辑器的插件存在。\n\n## 硬性需求\n\n图片资源管理是所有 App 都需要涉及到的东西，大多数时候我们会要求设计人员提供所有分辨率的切图。但是对于设计人员来说，iOS App 与 Android App 加起来需要好多套切图，这是一项比较枯燥而且繁重的工作。既然是固定模式的重复劳动，那么正是程序所擅长的，也因此诞生了  [**RTImageAssets**](https://github.com/rickytan/RTImageAssets) 这类优秀插件。\n\n## 重生\n\n在没有了  [**RTImageAssets**](https://github.com/rickytan/RTImageAssets) 之后写过好几个项目，深深感觉到缺少强力工具之后的无助和不便，于是我萌生了写一个与  [**RTImageAssets**](https://github.com/rickytan/RTImageAssets) 功能一致的工具 App 的想法。因为 ImageAssets 实际上是通过目录 + Contents.json 配置文件的模式运作的，所以从原理上来说脱离 Xcode 来对它进行管理是可行的，这样就可以避开 Xcode 对第三方插件的红线了。\n\n于是便有了 AssetsProcessor，这里可耻的偷了个懒，因为  [**RTImageAssets**](https://github.com/rickytan/RTImageAssets) 是基于 MIT 协议开源的，所以 AssetsProcessor 核心的图片处理部分的代码都是从   [**RTImageAssets**](https://github.com/rickytan/RTImageAssets) 搬过来的，不过我用 Swift 重写了下。\n\n## 使用\n\n因为脱离了 Xcode，所以无法像原来那样在 Xcode 中直接使用快捷键来完成工作了。不过现在的用法同样简单，只需要打开 AssetsProcesor，然后将 Assets 文件夹从 Xcode 文件导航窗口中拖拽到 AssetsProcessor 的窗口中就可以了：\n\n![](/images/assetsprocessor/AssetsProcessorExample.gif)\n\n另外，发挥了一下桌面 App 的优势，现在处理完图片之后，会在窗口中显示每一个 ImageAsset 的处理结果，包含 1x、2x、3x 三种图片的状态，AssetsProcesor 也会将图片重命名为 n@2x.png 这种形式，并且是自动进行的。\n\n关于图标的说明：\n\n|图标|说明|\n|---|---|\n|![](/images/assetsprocessor/icn-none@2x.png)|表示原始尺寸的图片不存在，并且也没有自动生成|\n|![](/images/assetsprocessor/icn-cross@2x.png)|表示处理出现错误|\n|![](/images/assetsprocessor/icn-check-yellow.png)|`1x`、`2x`、`3x`：表示存在对应原始尺寸的图片，并且没有修改；<br>`name`：表示原始的文件名称符合预设风格，没有修改|\n|![](/images/assetsprocessor/icn-check-green.png)|`1x`、`2x`、`3x`：表示生成了对应尺寸的图片；<br>`name`：表示已将文件名修改为预设的风格|\n\n### 改进\n\nAssetsProcesor 支持跨项目的图片资源处理，除了在 Xcode 中将 Assets 文件夹拖进来之外，还可以将任何目录拖拽到窗口中，AssetsProcesor 会自动检索目录中(包括子目录)所有的 Assets 目录并进行处理。\n\n### 安装\n\nAssetsProcesor 已经在 macOX App Store 上架，[**去下载**](https://itunes.apple.com/us/app/assets-processor/id1240024311?l=zh&ls=1&mt=12)\n","source":"_posts/assets-processor.md","raw":"---\ntitle: 使用 Assets Processor 处理 Xcode 图片资源\nabstract: 自从 Xcode ghost 事件之后，苹果直接在 8.0以上的版本中禁止了 Xcode 的第三方插件。苹果一直很霸道，这么做虽然确实保证了安全性，但是却同时打死了好多确实很方便和实用的插件，比如RTImageAssets。虽然苹果另外提供了 Code Editor Extension 作为补充，但是一来生态完善程度不足，这方面的扩展程序还太少，二来限制太多，很多功能无法作为代码编辑器的插件存在。\n---\n\n> 自从 Xcode ghost 事件之后，苹果直接在 8.0以上的版本中禁止了 Xcode 的第三方插件。苹果一直很霸道，这么做虽然确实保证了安全性，但是却同时打死了好多确实很方便和实用的插件，比如说 [**RTImageAssets**](https://github.com/rickytan/RTImageAssets)。\n> 虽然苹果另外提供了 Code Editor Extension 作为补充，但是一来生态完善程度不足，这方面的扩展程序还太少，二来限制太多，很多功能无法作为代码编辑器的插件存在。\n\n## 硬性需求\n\n图片资源管理是所有 App 都需要涉及到的东西，大多数时候我们会要求设计人员提供所有分辨率的切图。但是对于设计人员来说，iOS App 与 Android App 加起来需要好多套切图，这是一项比较枯燥而且繁重的工作。既然是固定模式的重复劳动，那么正是程序所擅长的，也因此诞生了  [**RTImageAssets**](https://github.com/rickytan/RTImageAssets) 这类优秀插件。\n\n## 重生\n\n在没有了  [**RTImageAssets**](https://github.com/rickytan/RTImageAssets) 之后写过好几个项目，深深感觉到缺少强力工具之后的无助和不便，于是我萌生了写一个与  [**RTImageAssets**](https://github.com/rickytan/RTImageAssets) 功能一致的工具 App 的想法。因为 ImageAssets 实际上是通过目录 + Contents.json 配置文件的模式运作的，所以从原理上来说脱离 Xcode 来对它进行管理是可行的，这样就可以避开 Xcode 对第三方插件的红线了。\n\n于是便有了 AssetsProcessor，这里可耻的偷了个懒，因为  [**RTImageAssets**](https://github.com/rickytan/RTImageAssets) 是基于 MIT 协议开源的，所以 AssetsProcessor 核心的图片处理部分的代码都是从   [**RTImageAssets**](https://github.com/rickytan/RTImageAssets) 搬过来的，不过我用 Swift 重写了下。\n\n## 使用\n\n因为脱离了 Xcode，所以无法像原来那样在 Xcode 中直接使用快捷键来完成工作了。不过现在的用法同样简单，只需要打开 AssetsProcesor，然后将 Assets 文件夹从 Xcode 文件导航窗口中拖拽到 AssetsProcessor 的窗口中就可以了：\n\n![](/images/assetsprocessor/AssetsProcessorExample.gif)\n\n另外，发挥了一下桌面 App 的优势，现在处理完图片之后，会在窗口中显示每一个 ImageAsset 的处理结果，包含 1x、2x、3x 三种图片的状态，AssetsProcesor 也会将图片重命名为 n@2x.png 这种形式，并且是自动进行的。\n\n关于图标的说明：\n\n|图标|说明|\n|---|---|\n|![](/images/assetsprocessor/icn-none@2x.png)|表示原始尺寸的图片不存在，并且也没有自动生成|\n|![](/images/assetsprocessor/icn-cross@2x.png)|表示处理出现错误|\n|![](/images/assetsprocessor/icn-check-yellow.png)|`1x`、`2x`、`3x`：表示存在对应原始尺寸的图片，并且没有修改；<br>`name`：表示原始的文件名称符合预设风格，没有修改|\n|![](/images/assetsprocessor/icn-check-green.png)|`1x`、`2x`、`3x`：表示生成了对应尺寸的图片；<br>`name`：表示已将文件名修改为预设的风格|\n\n### 改进\n\nAssetsProcesor 支持跨项目的图片资源处理，除了在 Xcode 中将 Assets 文件夹拖进来之外，还可以将任何目录拖拽到窗口中，AssetsProcesor 会自动检索目录中(包括子目录)所有的 Assets 目录并进行处理。\n\n### 安装\n\nAssetsProcesor 已经在 macOX App Store 上架，[**去下载**](https://itunes.apple.com/us/app/assets-processor/id1240024311?l=zh&ls=1&mt=12)\n","slug":"assets-processor","published":1,"date":"2017-05-26T00:27:58.000Z","updated":"2020-01-31T04:06:02.137Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck61tll2i0004ufqb2lfj5n48","content":"<blockquote>\n<p>自从 Xcode ghost 事件之后，苹果直接在 8.0以上的版本中禁止了 Xcode 的第三方插件。苹果一直很霸道，这么做虽然确实保证了安全性，但是却同时打死了好多确实很方便和实用的插件，比如说 <a href=\"https://github.com/rickytan/RTImageAssets\" target=\"_blank\" rel=\"noopener\"><strong>RTImageAssets</strong></a>。<br>虽然苹果另外提供了 Code Editor Extension 作为补充，但是一来生态完善程度不足，这方面的扩展程序还太少，二来限制太多，很多功能无法作为代码编辑器的插件存在。</p>\n</blockquote>\n<h2 id=\"硬性需求\"><a href=\"#硬性需求\" class=\"headerlink\" title=\"硬性需求\"></a>硬性需求</h2><p>图片资源管理是所有 App 都需要涉及到的东西，大多数时候我们会要求设计人员提供所有分辨率的切图。但是对于设计人员来说，iOS App 与 Android App 加起来需要好多套切图，这是一项比较枯燥而且繁重的工作。既然是固定模式的重复劳动，那么正是程序所擅长的，也因此诞生了  <a href=\"https://github.com/rickytan/RTImageAssets\" target=\"_blank\" rel=\"noopener\"><strong>RTImageAssets</strong></a> 这类优秀插件。</p>\n<h2 id=\"重生\"><a href=\"#重生\" class=\"headerlink\" title=\"重生\"></a>重生</h2><p>在没有了  <a href=\"https://github.com/rickytan/RTImageAssets\" target=\"_blank\" rel=\"noopener\"><strong>RTImageAssets</strong></a> 之后写过好几个项目，深深感觉到缺少强力工具之后的无助和不便，于是我萌生了写一个与  <a href=\"https://github.com/rickytan/RTImageAssets\" target=\"_blank\" rel=\"noopener\"><strong>RTImageAssets</strong></a> 功能一致的工具 App 的想法。因为 ImageAssets 实际上是通过目录 + Contents.json 配置文件的模式运作的，所以从原理上来说脱离 Xcode 来对它进行管理是可行的，这样就可以避开 Xcode 对第三方插件的红线了。</p>\n<p>于是便有了 AssetsProcessor，这里可耻的偷了个懒，因为  <a href=\"https://github.com/rickytan/RTImageAssets\" target=\"_blank\" rel=\"noopener\"><strong>RTImageAssets</strong></a> 是基于 MIT 协议开源的，所以 AssetsProcessor 核心的图片处理部分的代码都是从   <a href=\"https://github.com/rickytan/RTImageAssets\" target=\"_blank\" rel=\"noopener\"><strong>RTImageAssets</strong></a> 搬过来的，不过我用 Swift 重写了下。</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>因为脱离了 Xcode，所以无法像原来那样在 Xcode 中直接使用快捷键来完成工作了。不过现在的用法同样简单，只需要打开 AssetsProcesor，然后将 Assets 文件夹从 Xcode 文件导航窗口中拖拽到 AssetsProcessor 的窗口中就可以了：</p>\n<p><img src=\"/images/assetsprocessor/AssetsProcessorExample.gif\" alt=\"\"></p>\n<p>另外，发挥了一下桌面 App 的优势，现在处理完图片之后，会在窗口中显示每一个 ImageAsset 的处理结果，包含 1x、2x、3x 三种图片的状态，AssetsProcesor 也会将图片重命名为 <a href=\"mailto:n@2x.png\">n@2x.png</a> 这种形式，并且是自动进行的。</p>\n<p>关于图标的说明：</p>\n<table>\n<thead>\n<tr>\n<th>图标</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"/images/assetsprocessor/icn-none@2x.png\" alt=\"\"></td>\n<td>表示原始尺寸的图片不存在，并且也没有自动生成</td>\n</tr>\n<tr>\n<td><img src=\"/images/assetsprocessor/icn-cross@2x.png\" alt=\"\"></td>\n<td>表示处理出现错误</td>\n</tr>\n<tr>\n<td><img src=\"/images/assetsprocessor/icn-check-yellow.png\" alt=\"\"></td>\n<td><code>1x</code>、<code>2x</code>、<code>3x</code>：表示存在对应原始尺寸的图片，并且没有修改；<br><code>name</code>：表示原始的文件名称符合预设风格，没有修改</td>\n</tr>\n<tr>\n<td><img src=\"/images/assetsprocessor/icn-check-green.png\" alt=\"\"></td>\n<td><code>1x</code>、<code>2x</code>、<code>3x</code>：表示生成了对应尺寸的图片；<br><code>name</code>：表示已将文件名修改为预设的风格</td>\n</tr>\n</tbody></table>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>AssetsProcesor 支持跨项目的图片资源处理，除了在 Xcode 中将 Assets 文件夹拖进来之外，还可以将任何目录拖拽到窗口中，AssetsProcesor 会自动检索目录中(包括子目录)所有的 Assets 目录并进行处理。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>AssetsProcesor 已经在 macOX App Store 上架，<a href=\"https://itunes.apple.com/us/app/assets-processor/id1240024311?l=zh&ls=1&mt=12\" target=\"_blank\" rel=\"noopener\"><strong>去下载</strong></a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>自从 Xcode ghost 事件之后，苹果直接在 8.0以上的版本中禁止了 Xcode 的第三方插件。苹果一直很霸道，这么做虽然确实保证了安全性，但是却同时打死了好多确实很方便和实用的插件，比如说 <a href=\"https://github.com/rickytan/RTImageAssets\" target=\"_blank\" rel=\"noopener\"><strong>RTImageAssets</strong></a>。<br>虽然苹果另外提供了 Code Editor Extension 作为补充，但是一来生态完善程度不足，这方面的扩展程序还太少，二来限制太多，很多功能无法作为代码编辑器的插件存在。</p>\n</blockquote>\n<h2 id=\"硬性需求\"><a href=\"#硬性需求\" class=\"headerlink\" title=\"硬性需求\"></a>硬性需求</h2><p>图片资源管理是所有 App 都需要涉及到的东西，大多数时候我们会要求设计人员提供所有分辨率的切图。但是对于设计人员来说，iOS App 与 Android App 加起来需要好多套切图，这是一项比较枯燥而且繁重的工作。既然是固定模式的重复劳动，那么正是程序所擅长的，也因此诞生了  <a href=\"https://github.com/rickytan/RTImageAssets\" target=\"_blank\" rel=\"noopener\"><strong>RTImageAssets</strong></a> 这类优秀插件。</p>\n<h2 id=\"重生\"><a href=\"#重生\" class=\"headerlink\" title=\"重生\"></a>重生</h2><p>在没有了  <a href=\"https://github.com/rickytan/RTImageAssets\" target=\"_blank\" rel=\"noopener\"><strong>RTImageAssets</strong></a> 之后写过好几个项目，深深感觉到缺少强力工具之后的无助和不便，于是我萌生了写一个与  <a href=\"https://github.com/rickytan/RTImageAssets\" target=\"_blank\" rel=\"noopener\"><strong>RTImageAssets</strong></a> 功能一致的工具 App 的想法。因为 ImageAssets 实际上是通过目录 + Contents.json 配置文件的模式运作的，所以从原理上来说脱离 Xcode 来对它进行管理是可行的，这样就可以避开 Xcode 对第三方插件的红线了。</p>\n<p>于是便有了 AssetsProcessor，这里可耻的偷了个懒，因为  <a href=\"https://github.com/rickytan/RTImageAssets\" target=\"_blank\" rel=\"noopener\"><strong>RTImageAssets</strong></a> 是基于 MIT 协议开源的，所以 AssetsProcessor 核心的图片处理部分的代码都是从   <a href=\"https://github.com/rickytan/RTImageAssets\" target=\"_blank\" rel=\"noopener\"><strong>RTImageAssets</strong></a> 搬过来的，不过我用 Swift 重写了下。</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>因为脱离了 Xcode，所以无法像原来那样在 Xcode 中直接使用快捷键来完成工作了。不过现在的用法同样简单，只需要打开 AssetsProcesor，然后将 Assets 文件夹从 Xcode 文件导航窗口中拖拽到 AssetsProcessor 的窗口中就可以了：</p>\n<p><img src=\"/images/assetsprocessor/AssetsProcessorExample.gif\" alt=\"\"></p>\n<p>另外，发挥了一下桌面 App 的优势，现在处理完图片之后，会在窗口中显示每一个 ImageAsset 的处理结果，包含 1x、2x、3x 三种图片的状态，AssetsProcesor 也会将图片重命名为 <a href=\"mailto:n@2x.png\">n@2x.png</a> 这种形式，并且是自动进行的。</p>\n<p>关于图标的说明：</p>\n<table>\n<thead>\n<tr>\n<th>图标</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"/images/assetsprocessor/icn-none@2x.png\" alt=\"\"></td>\n<td>表示原始尺寸的图片不存在，并且也没有自动生成</td>\n</tr>\n<tr>\n<td><img src=\"/images/assetsprocessor/icn-cross@2x.png\" alt=\"\"></td>\n<td>表示处理出现错误</td>\n</tr>\n<tr>\n<td><img src=\"/images/assetsprocessor/icn-check-yellow.png\" alt=\"\"></td>\n<td><code>1x</code>、<code>2x</code>、<code>3x</code>：表示存在对应原始尺寸的图片，并且没有修改；<br><code>name</code>：表示原始的文件名称符合预设风格，没有修改</td>\n</tr>\n<tr>\n<td><img src=\"/images/assetsprocessor/icn-check-green.png\" alt=\"\"></td>\n<td><code>1x</code>、<code>2x</code>、<code>3x</code>：表示生成了对应尺寸的图片；<br><code>name</code>：表示已将文件名修改为预设的风格</td>\n</tr>\n</tbody></table>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>AssetsProcesor 支持跨项目的图片资源处理，除了在 Xcode 中将 Assets 文件夹拖进来之外，还可以将任何目录拖拽到窗口中，AssetsProcesor 会自动检索目录中(包括子目录)所有的 Assets 目录并进行处理。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>AssetsProcesor 已经在 macOX App Store 上架，<a href=\"https://itunes.apple.com/us/app/assets-processor/id1240024311?l=zh&ls=1&mt=12\" target=\"_blank\" rel=\"noopener\"><strong>去下载</strong></a></p>\n"},{"title":"神笔马良——基于 Metal 的涂鸦框架","abstract":"MaLiang 是 iOS 平台基于 Metal 的涂鸦绘图框架，完全使用 Swift 实现，支持自定义纹理、缩放、压力感应等特性，并且提供了较大的自定义扩展的空间","_content":"\n> 取这个名字有投机取巧的嫌疑，希望能对得起先贤 >_<\n\n**MaLiang 现已全面升级到 Metal。**\n*本文已针对最新 Metal 版本更新，最后更新于：2019-05-10*\n\n## 这是什么？\n\n**[MaLiang](https://github.com/Harley-xk/MaLiang)** 是 iOS 平台基于 Metal 的涂鸦绘图框架，完全使用 Swift 实现，支持自定义纹理、缩放、压力感应等特性，并且提供了较大的自定义扩展的空间。\n\n## 特色功能\n\n- 笔迹通过贝塞尔曲线进行平滑处理\n- 支持添加自定义贴图\n- 纹理和贴图支持旋转\n- 内置一个荧光笔特效的实现\n- 可以根据压力自动调整笔迹，支持 3D Touch\n- 支持撤销和重做\n- 支持滚动和缩放画布\n- 导出绘制内容为图片\n- 将绘制内容保存为矢量文档和从文档恢复数据\n\n## 使用\n\n我的理念是尽量制造简单、优雅的东西，虽然有时候要做到这一点其实很难，但是尽量往这方面靠吧。**MaLiang** 的集成和使用都很简单，我把大量对使用者来说没有什么用也没有必要了解的内部逻辑都隐藏了。这篇文章也会介绍一些内部实现的思路。\n\n### 集成\n\n#### Cocoapods\n\n**MaLiang** 已经推送到了 Cocopods 的官方 repo，所以，你只需要在 Podfile 增加一条 Pod 指令然后 `install` 就可以在项目中使用了：\n\n```ruby\npod 'MaLiang'\n```\n\n如果你想使用老的 OpenGL 版本，请指定到 1.1.x 版本\n\n```ruby\npod 'MaLiang', '~> 1.1'\n```\n\n**需要注意 OpenGL 版本只包含有限的功能并且已停止维护**\n\n### Carthage\n\n**MaLiang** 现在也支持通过 [Carthage](https://github.com/Carthage/Carthage) 集成，首先在 `Cartfile` 中增加指令：\n\n```source-ruby\ngithub \"Harley-xk/MaLiang\"\n```\n然后执行 `cartage update` 命令来完成编译，然后将编译完成的 `MaLiang.framework` 添加到 Xcode 项目中。\n\n**需要确保将 `MaLiang.framework` 添加到 target 的 `Embedded Binaries` 中**\n\n### 调用\n在需要使用的地方引入 Mudule。当然，首先需要编译一下，否在会报找不到 Moudle 的错误\n\n```swift\nimport MaLiang\n```\n\n#### 几个主要的类\n\n##### 1. Canvas\n\n画布是 **MaLiang** 最基础的组件，所有的涂鸦都发生在 `Canvas` 上。`Canvas` 本质上是一个 `UIView`，所以你可以使用任何你原来创建 `UIView` 的方法来创建一个画布，并将它添加到你的界面上。\n\n- 如果你偏好代码流，那么直接调用 `UIView` 的通用构造函数 `init(frame:)` 就可以了。\n\n- 如果你觉得 `IB` 流才是正道，只要在 `xib` 或者 `storyboard` 中拖一个 `UIView` 到界面上，然后将类名改成 `Canvas` 后回车就可以了，Xcode 应该会自动将 Module 设置成 `MaLiang`。\n\n给 `Canvas` 设置正确的布局约束，然后你就可以开始涂鸦了，比如写两个毛笔字：\n\n![](https://upload-images.jianshu.io/upload_images/619631-357782e1e0895a94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n嗯，请忽略我的书法水平... 想画成这样，还缺少一些东西 :)\n\n`Canvas` 继承自 `MetalView`, `MetalView` 做了几乎所有与 `Metal` 打交道的事情，虽然它被定义成一个 `open` 的类，但是如果不是深度定制的话，应该不需要对它进行扩展。\n\n**MaLiang** 涂鸦的核心是纹理(`Texture`)，本质上就是沿着手指轨迹，不断地将纹理叠加到画布上的过程。所以能画出什么样的笔迹，完全取决于使用的纹理，以及它的大小、颜色、尺寸、透明度等等这些参数。\n\n`MetalView` 初始化之后会创建一个默认的纹理，这个纹理就是一个简单的不透明的圆点，所以只能画最简单的线条。如果想要画出上图那样的效果，就需要使用相对复杂一点的纹理了。**MaLiang** 的示例项目里面提供了好几个设定好的纹理，用他们可以模拟出铅笔、水笔以及毛笔的特效，上面的文字就是使用毛笔特效写出来的。\n\n###### 快照\n\n`Canvas` 提供了一个简单的快照功能：\n\n```swift\nopen func snapshot() -> UIImage?\n```\n调用该方法会对画布生成一个当前内容的快照并以 Image 的形式返回，快照的实现逻辑很简单，你也可以自己实现更加复杂的快照逻辑。\n\n##### 2. Brush\n\n直接使用纹理还是比较繁琐的，另外与纹理相关的还有颜色、线条的粗细以及其他一些参数，所以这里提供了一个 `Brush` 类来处理所有的这些数据。\n\n`Brush` 的属性在改变后会立刻影响接下来的绘制效果。\n\n- `opacity` 透明度\n\n上面提到，涂鸦的本质是把纹理叠加到画笔的过程，所以想要做出深浅不一的笔迹，纹理就需要具有透明度，可以通过\b`opacity` 属性来调节。\n\n- `pointSize` 笔迹粗细\n\n`pointSize` 直接影响笔迹的粗细，它是以 iOS 尺寸的标准单位 **点(`point`)** 来衡量的，所以这是一个自适应屏幕像素密度的属性。你不需要根据设备类型来计算实际像素，直接指定眼睛可见的大小就可以了。\n\n- `pointStep` 点距\n\n同上，由于\b笔迹是通过叠加纹理实现的，因此除了透明度外，两个纹理之间的距离也会影响到笔迹的深浅。另外如果把点距设定到大于笔迹的尺寸，甚至可以画出类似虚线的效果。点距的单位也是 **点(`point`)**。\n\n- `forceSensitive` 压力敏感度\n\n之所以说 `pointSize` 是影响笔迹的粗细，而不是直接确定，是因为有压力感应的存在。笔迹的实际尺寸会随着压力的大小在 `pointSize` 指定的尺寸上下浮动，压力越大，笔迹越粗。`forceSensitive` 影响笔迹对压力浮动的剧烈程度，建议设置为 `0` - `1` 之间的某个值。如果设置过大，笔迹随压力的便会会太过剧烈而失真；如果将 `forceSensitive` 的值设置为 `0`，则对该画笔关闭压力感应效果，笔迹粗细不会随着压力而变化。\n\n**MaLiang** 默认使用 iOS 设备的 **3D Touch** 参数，另外在一些不支持压力感应的设备上使用模拟的压力感应。模拟压感依赖手势移动的速度来判断压力的大小。\n\n- `color` 颜色\n\n影响笔迹的颜色，实际画出的颜色会计算进 `opacity` 的值，不过由于纹理之间会叠加，所以相互效果可以基本抵消。你一般不需要为颜色额外指定透明度的值。\n\n- `texture` 纹理\n\n`texture` 是一个非公开属性，实际使用时只需要使用纹理图的 Image 初始化 `Brush` 对象就可以了，不需要关心 `texture` 的具体实现。\n\n对于纯色线条，颜色是根据对画笔所指定的 `color` 属性来决定的，纹理只需要提供准确的透明度信息即可，因此可以是任意颜色。\n\n##### 3. CanvasData\n\n`CanvasData` 会在画布创建后自动初始化，它保存了当前画布上的所有笔迹信息，依赖这些数据，目前实现了撤销和重做功能。\n通过 `CanvasData` 持有的数据，还可以轻松实现保存涂鸦数据到文件的逻辑。反过来也可以将保存的数据重新还原成画布图像，这样可以实现跨设备的数据同步功能。**MaLiang** 提供了一个默认版本的数据保存和读取的逻辑，你可以在此基础上做进一步的封装，也可以完全另外实现你自己的存储逻辑。\n\n## MaLiang 进化史\n\n- **MaLiang** 起源于 12 年的一个涂鸦项目，当时还是基于 Objective-C 和 OpenGL ES1 实现的，OpenGL \bES1 对于抗锯齿的支持不是很好，所以涂鸦的效果不怎么敢恭维。并且当时由于太年轻，整个框架的设计和结构都比较凌乱。虽然最后顺利上架了一段时间，不过由于各种各样的原因，整个项目随当时的公司一起无疾而终了。\n\n- 18年业余时间重拾了这个项目，基于 OpenGL ES3，使用 Swift 完全重写，同时对整个项目结构进行了重新设计和改进，并进行了少量的扩展。\n\n- 然而生不逢时，MaLiang 刚完成没多久，苹果就宣布废除 OpenGL ES，iOS 平台 Metal 成了唯一选项。但由于我对 OpenGL ES 都只是一知半解，Metal 就研究的更少了，将 MaLiang 迁移到 Metal 的计划便一直处于搁浅状态。\n\n- 直到最近才终于下定决心，从渲染管线到着色器语言，恶补了 Metal 相关的基础知识，终于将底层绘制相关的逻辑全部用 Metal 改写，并且对上层逻辑进行了部分重构。同时顺便将原来基本没有用户体验的缩放功能完全重写，实现了可以放大画布之后绘制微缩图案的功能。\n\n*当然了，我对 Metal 的理解还很浅薄，**MaLiang** 还是有很多需要优化改进的地方。*\n\n## Why Swift？\n\nSwift 从 15 年开始就作为我的主要开发语言了，所以回去写 OC 对我来说已经不可能，尽管之前写 OpenGL 时使用 Swift 确实很麻烦，不过最后还是完成了。\n\n当时有大佬奉劝我使用 OC 或者 C 作为中间层来调用 OpenGL，再用 Swift 封装上层逻辑，确实这样可以以最低的成本实现需要的效果。不过作为一个业余项目，成本并不是我第一考虑的要素，而且这个库虽然是基于 OpenGL 的，但是真正跟 OpenGL 打交道的，其实也就那几百行代码。为了追求这一点点成本和便利性，牺牲整个项目结构的统一和整洁，在我这是无法接受的。\n\n而坚持使用 Swift 的好处在最近迁移到 Metal 时就表现出来了。只需要对几处OpenGL的关键绘制逻辑使用 Metal 改写，就能很快完成迁移，否则就需要重写整个底层逻辑了 :)\n\n~~另外，引入 OC 代码意味着\b同时引入了 OC 的动态运行时环境，这对 Swift 的执行效率会有一定的影响。虽然作为一个 iOS 的项目，现在必然无法摆脱 OC 的动态运行时环境，我的这点偏执似乎也没有什么意义，不过谁知道以后会怎么样呢 :)~~\n\n在这个时间点，Swift 5 刚好发布没多久，终于迎来了 ABI 稳定这一天，这意味着 Swift App 距离脱离 OC 的动态运行时，完全运行在纯 Swift 环境中那一天已经不远了:)\n\n## 应用\n\n说了半天，这个库有什么用？说实话我也不知道，或许可以用来做签名？不过签名其实用 `CoreGraphics` 就足够了。或许可以用它来做一个画画的 App 来逗小孩玩，可能我真会这么干。。。\n\n说到底，这主要是对当初懵懂时期经历的一个纪念吧。感兴趣的都可以拿去玩 :)\n\n~~接下来可能会打算基于这个库开发一款涂鸦的 App。当然了，多年前的那个项目是不会复活了，新的这个 App 会是一个融合了很多我自己想法的全新项目。当然了希望不要半途而废 - -!~~\n\n基于 MaLiang 的涂鸦 App 已经开发完成并上线，可以在 AppStore 搜索 **马良** [下载体验](https://apps.apple.com/cn/app/id1462615532)。","source":"_posts/maliang.md","raw":"---\ntitle: 神笔马良——基于 Metal 的涂鸦框架\nabstract: MaLiang 是 iOS 平台基于 Metal 的涂鸦绘图框架，完全使用 Swift 实现，支持自定义纹理、缩放、压力感应等特性，并且提供了较大的自定义扩展的空间\n---\n\n> 取这个名字有投机取巧的嫌疑，希望能对得起先贤 >_<\n\n**MaLiang 现已全面升级到 Metal。**\n*本文已针对最新 Metal 版本更新，最后更新于：2019-05-10*\n\n## 这是什么？\n\n**[MaLiang](https://github.com/Harley-xk/MaLiang)** 是 iOS 平台基于 Metal 的涂鸦绘图框架，完全使用 Swift 实现，支持自定义纹理、缩放、压力感应等特性，并且提供了较大的自定义扩展的空间。\n\n## 特色功能\n\n- 笔迹通过贝塞尔曲线进行平滑处理\n- 支持添加自定义贴图\n- 纹理和贴图支持旋转\n- 内置一个荧光笔特效的实现\n- 可以根据压力自动调整笔迹，支持 3D Touch\n- 支持撤销和重做\n- 支持滚动和缩放画布\n- 导出绘制内容为图片\n- 将绘制内容保存为矢量文档和从文档恢复数据\n\n## 使用\n\n我的理念是尽量制造简单、优雅的东西，虽然有时候要做到这一点其实很难，但是尽量往这方面靠吧。**MaLiang** 的集成和使用都很简单，我把大量对使用者来说没有什么用也没有必要了解的内部逻辑都隐藏了。这篇文章也会介绍一些内部实现的思路。\n\n### 集成\n\n#### Cocoapods\n\n**MaLiang** 已经推送到了 Cocopods 的官方 repo，所以，你只需要在 Podfile 增加一条 Pod 指令然后 `install` 就可以在项目中使用了：\n\n```ruby\npod 'MaLiang'\n```\n\n如果你想使用老的 OpenGL 版本，请指定到 1.1.x 版本\n\n```ruby\npod 'MaLiang', '~> 1.1'\n```\n\n**需要注意 OpenGL 版本只包含有限的功能并且已停止维护**\n\n### Carthage\n\n**MaLiang** 现在也支持通过 [Carthage](https://github.com/Carthage/Carthage) 集成，首先在 `Cartfile` 中增加指令：\n\n```source-ruby\ngithub \"Harley-xk/MaLiang\"\n```\n然后执行 `cartage update` 命令来完成编译，然后将编译完成的 `MaLiang.framework` 添加到 Xcode 项目中。\n\n**需要确保将 `MaLiang.framework` 添加到 target 的 `Embedded Binaries` 中**\n\n### 调用\n在需要使用的地方引入 Mudule。当然，首先需要编译一下，否在会报找不到 Moudle 的错误\n\n```swift\nimport MaLiang\n```\n\n#### 几个主要的类\n\n##### 1. Canvas\n\n画布是 **MaLiang** 最基础的组件，所有的涂鸦都发生在 `Canvas` 上。`Canvas` 本质上是一个 `UIView`，所以你可以使用任何你原来创建 `UIView` 的方法来创建一个画布，并将它添加到你的界面上。\n\n- 如果你偏好代码流，那么直接调用 `UIView` 的通用构造函数 `init(frame:)` 就可以了。\n\n- 如果你觉得 `IB` 流才是正道，只要在 `xib` 或者 `storyboard` 中拖一个 `UIView` 到界面上，然后将类名改成 `Canvas` 后回车就可以了，Xcode 应该会自动将 Module 设置成 `MaLiang`。\n\n给 `Canvas` 设置正确的布局约束，然后你就可以开始涂鸦了，比如写两个毛笔字：\n\n![](https://upload-images.jianshu.io/upload_images/619631-357782e1e0895a94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n嗯，请忽略我的书法水平... 想画成这样，还缺少一些东西 :)\n\n`Canvas` 继承自 `MetalView`, `MetalView` 做了几乎所有与 `Metal` 打交道的事情，虽然它被定义成一个 `open` 的类，但是如果不是深度定制的话，应该不需要对它进行扩展。\n\n**MaLiang** 涂鸦的核心是纹理(`Texture`)，本质上就是沿着手指轨迹，不断地将纹理叠加到画布上的过程。所以能画出什么样的笔迹，完全取决于使用的纹理，以及它的大小、颜色、尺寸、透明度等等这些参数。\n\n`MetalView` 初始化之后会创建一个默认的纹理，这个纹理就是一个简单的不透明的圆点，所以只能画最简单的线条。如果想要画出上图那样的效果，就需要使用相对复杂一点的纹理了。**MaLiang** 的示例项目里面提供了好几个设定好的纹理，用他们可以模拟出铅笔、水笔以及毛笔的特效，上面的文字就是使用毛笔特效写出来的。\n\n###### 快照\n\n`Canvas` 提供了一个简单的快照功能：\n\n```swift\nopen func snapshot() -> UIImage?\n```\n调用该方法会对画布生成一个当前内容的快照并以 Image 的形式返回，快照的实现逻辑很简单，你也可以自己实现更加复杂的快照逻辑。\n\n##### 2. Brush\n\n直接使用纹理还是比较繁琐的，另外与纹理相关的还有颜色、线条的粗细以及其他一些参数，所以这里提供了一个 `Brush` 类来处理所有的这些数据。\n\n`Brush` 的属性在改变后会立刻影响接下来的绘制效果。\n\n- `opacity` 透明度\n\n上面提到，涂鸦的本质是把纹理叠加到画笔的过程，所以想要做出深浅不一的笔迹，纹理就需要具有透明度，可以通过\b`opacity` 属性来调节。\n\n- `pointSize` 笔迹粗细\n\n`pointSize` 直接影响笔迹的粗细，它是以 iOS 尺寸的标准单位 **点(`point`)** 来衡量的，所以这是一个自适应屏幕像素密度的属性。你不需要根据设备类型来计算实际像素，直接指定眼睛可见的大小就可以了。\n\n- `pointStep` 点距\n\n同上，由于\b笔迹是通过叠加纹理实现的，因此除了透明度外，两个纹理之间的距离也会影响到笔迹的深浅。另外如果把点距设定到大于笔迹的尺寸，甚至可以画出类似虚线的效果。点距的单位也是 **点(`point`)**。\n\n- `forceSensitive` 压力敏感度\n\n之所以说 `pointSize` 是影响笔迹的粗细，而不是直接确定，是因为有压力感应的存在。笔迹的实际尺寸会随着压力的大小在 `pointSize` 指定的尺寸上下浮动，压力越大，笔迹越粗。`forceSensitive` 影响笔迹对压力浮动的剧烈程度，建议设置为 `0` - `1` 之间的某个值。如果设置过大，笔迹随压力的便会会太过剧烈而失真；如果将 `forceSensitive` 的值设置为 `0`，则对该画笔关闭压力感应效果，笔迹粗细不会随着压力而变化。\n\n**MaLiang** 默认使用 iOS 设备的 **3D Touch** 参数，另外在一些不支持压力感应的设备上使用模拟的压力感应。模拟压感依赖手势移动的速度来判断压力的大小。\n\n- `color` 颜色\n\n影响笔迹的颜色，实际画出的颜色会计算进 `opacity` 的值，不过由于纹理之间会叠加，所以相互效果可以基本抵消。你一般不需要为颜色额外指定透明度的值。\n\n- `texture` 纹理\n\n`texture` 是一个非公开属性，实际使用时只需要使用纹理图的 Image 初始化 `Brush` 对象就可以了，不需要关心 `texture` 的具体实现。\n\n对于纯色线条，颜色是根据对画笔所指定的 `color` 属性来决定的，纹理只需要提供准确的透明度信息即可，因此可以是任意颜色。\n\n##### 3. CanvasData\n\n`CanvasData` 会在画布创建后自动初始化，它保存了当前画布上的所有笔迹信息，依赖这些数据，目前实现了撤销和重做功能。\n通过 `CanvasData` 持有的数据，还可以轻松实现保存涂鸦数据到文件的逻辑。反过来也可以将保存的数据重新还原成画布图像，这样可以实现跨设备的数据同步功能。**MaLiang** 提供了一个默认版本的数据保存和读取的逻辑，你可以在此基础上做进一步的封装，也可以完全另外实现你自己的存储逻辑。\n\n## MaLiang 进化史\n\n- **MaLiang** 起源于 12 年的一个涂鸦项目，当时还是基于 Objective-C 和 OpenGL ES1 实现的，OpenGL \bES1 对于抗锯齿的支持不是很好，所以涂鸦的效果不怎么敢恭维。并且当时由于太年轻，整个框架的设计和结构都比较凌乱。虽然最后顺利上架了一段时间，不过由于各种各样的原因，整个项目随当时的公司一起无疾而终了。\n\n- 18年业余时间重拾了这个项目，基于 OpenGL ES3，使用 Swift 完全重写，同时对整个项目结构进行了重新设计和改进，并进行了少量的扩展。\n\n- 然而生不逢时，MaLiang 刚完成没多久，苹果就宣布废除 OpenGL ES，iOS 平台 Metal 成了唯一选项。但由于我对 OpenGL ES 都只是一知半解，Metal 就研究的更少了，将 MaLiang 迁移到 Metal 的计划便一直处于搁浅状态。\n\n- 直到最近才终于下定决心，从渲染管线到着色器语言，恶补了 Metal 相关的基础知识，终于将底层绘制相关的逻辑全部用 Metal 改写，并且对上层逻辑进行了部分重构。同时顺便将原来基本没有用户体验的缩放功能完全重写，实现了可以放大画布之后绘制微缩图案的功能。\n\n*当然了，我对 Metal 的理解还很浅薄，**MaLiang** 还是有很多需要优化改进的地方。*\n\n## Why Swift？\n\nSwift 从 15 年开始就作为我的主要开发语言了，所以回去写 OC 对我来说已经不可能，尽管之前写 OpenGL 时使用 Swift 确实很麻烦，不过最后还是完成了。\n\n当时有大佬奉劝我使用 OC 或者 C 作为中间层来调用 OpenGL，再用 Swift 封装上层逻辑，确实这样可以以最低的成本实现需要的效果。不过作为一个业余项目，成本并不是我第一考虑的要素，而且这个库虽然是基于 OpenGL 的，但是真正跟 OpenGL 打交道的，其实也就那几百行代码。为了追求这一点点成本和便利性，牺牲整个项目结构的统一和整洁，在我这是无法接受的。\n\n而坚持使用 Swift 的好处在最近迁移到 Metal 时就表现出来了。只需要对几处OpenGL的关键绘制逻辑使用 Metal 改写，就能很快完成迁移，否则就需要重写整个底层逻辑了 :)\n\n~~另外，引入 OC 代码意味着\b同时引入了 OC 的动态运行时环境，这对 Swift 的执行效率会有一定的影响。虽然作为一个 iOS 的项目，现在必然无法摆脱 OC 的动态运行时环境，我的这点偏执似乎也没有什么意义，不过谁知道以后会怎么样呢 :)~~\n\n在这个时间点，Swift 5 刚好发布没多久，终于迎来了 ABI 稳定这一天，这意味着 Swift App 距离脱离 OC 的动态运行时，完全运行在纯 Swift 环境中那一天已经不远了:)\n\n## 应用\n\n说了半天，这个库有什么用？说实话我也不知道，或许可以用来做签名？不过签名其实用 `CoreGraphics` 就足够了。或许可以用它来做一个画画的 App 来逗小孩玩，可能我真会这么干。。。\n\n说到底，这主要是对当初懵懂时期经历的一个纪念吧。感兴趣的都可以拿去玩 :)\n\n~~接下来可能会打算基于这个库开发一款涂鸦的 App。当然了，多年前的那个项目是不会复活了，新的这个 App 会是一个融合了很多我自己想法的全新项目。当然了希望不要半途而废 - -!~~\n\n基于 MaLiang 的涂鸦 App 已经开发完成并上线，可以在 AppStore 搜索 **马良** [下载体验](https://apps.apple.com/cn/app/id1462615532)。","slug":"maliang","published":1,"date":"2018-05-07T08:54:33.000Z","updated":"2020-01-31T04:24:41.942Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck61tll2j0005ufqb4qav62v1","content":"<blockquote>\n<p>取这个名字有投机取巧的嫌疑，希望能对得起先贤 &gt;_&lt;</p>\n</blockquote>\n<p><strong>MaLiang 现已全面升级到 Metal。</strong><br><em>本文已针对最新 Metal 版本更新，最后更新于：2019-05-10</em></p>\n<h2 id=\"这是什么？\"><a href=\"#这是什么？\" class=\"headerlink\" title=\"这是什么？\"></a>这是什么？</h2><p><strong><a href=\"https://github.com/Harley-xk/MaLiang\" target=\"_blank\" rel=\"noopener\">MaLiang</a></strong> 是 iOS 平台基于 Metal 的涂鸦绘图框架，完全使用 Swift 实现，支持自定义纹理、缩放、压力感应等特性，并且提供了较大的自定义扩展的空间。</p>\n<h2 id=\"特色功能\"><a href=\"#特色功能\" class=\"headerlink\" title=\"特色功能\"></a>特色功能</h2><ul>\n<li>笔迹通过贝塞尔曲线进行平滑处理</li>\n<li>支持添加自定义贴图</li>\n<li>纹理和贴图支持旋转</li>\n<li>内置一个荧光笔特效的实现</li>\n<li>可以根据压力自动调整笔迹，支持 3D Touch</li>\n<li>支持撤销和重做</li>\n<li>支持滚动和缩放画布</li>\n<li>导出绘制内容为图片</li>\n<li>将绘制内容保存为矢量文档和从文档恢复数据</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>我的理念是尽量制造简单、优雅的东西，虽然有时候要做到这一点其实很难，但是尽量往这方面靠吧。<strong>MaLiang</strong> 的集成和使用都很简单，我把大量对使用者来说没有什么用也没有必要了解的内部逻辑都隐藏了。这篇文章也会介绍一些内部实现的思路。</p>\n<h3 id=\"集成\"><a href=\"#集成\" class=\"headerlink\" title=\"集成\"></a>集成</h3><h4 id=\"Cocoapods\"><a href=\"#Cocoapods\" class=\"headerlink\" title=\"Cocoapods\"></a>Cocoapods</h4><p><strong>MaLiang</strong> 已经推送到了 Cocopods 的官方 repo，所以，你只需要在 Podfile 增加一条 Pod 指令然后 <code>install</code> 就可以在项目中使用了：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod <span class=\"string\">'MaLiang'</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你想使用老的 OpenGL 版本，请指定到 1.1.x 版本</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod <span class=\"string\">'MaLiang'</span>, <span class=\"string\">'~&gt; 1.1'</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>需要注意 OpenGL 版本只包含有限的功能并且已停止维护</strong></p>\n<h3 id=\"Carthage\"><a href=\"#Carthage\" class=\"headerlink\" title=\"Carthage\"></a>Carthage</h3><p><strong>MaLiang</strong> 现在也支持通过 <a href=\"https://github.com/Carthage/Carthage\" target=\"_blank\" rel=\"noopener\">Carthage</a> 集成，首先在 <code>Cartfile</code> 中增加指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">github &quot;Harley-xk&#x2F;MaLiang&quot;</span><br></pre></td></tr></table></figure>\n<p>然后执行 <code>cartage update</code> 命令来完成编译，然后将编译完成的 <code>MaLiang.framework</code> 添加到 Xcode 项目中。</p>\n<p><strong>需要确保将 <code>MaLiang.framework</code> 添加到 target 的 <code>Embedded Binaries</code> 中</strong></p>\n<h3 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h3><p>在需要使用的地方引入 Mudule。当然，首先需要编译一下，否在会报找不到 Moudle 的错误</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> MaLiang</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"几个主要的类\"><a href=\"#几个主要的类\" class=\"headerlink\" title=\"几个主要的类\"></a>几个主要的类</h4><h5 id=\"1-Canvas\"><a href=\"#1-Canvas\" class=\"headerlink\" title=\"1. Canvas\"></a>1. Canvas</h5><p>画布是 <strong>MaLiang</strong> 最基础的组件，所有的涂鸦都发生在 <code>Canvas</code> 上。<code>Canvas</code> 本质上是一个 <code>UIView</code>，所以你可以使用任何你原来创建 <code>UIView</code> 的方法来创建一个画布，并将它添加到你的界面上。</p>\n<ul>\n<li><p>如果你偏好代码流，那么直接调用 <code>UIView</code> 的通用构造函数 <code>init(frame:)</code> 就可以了。</p>\n</li>\n<li><p>如果你觉得 <code>IB</code> 流才是正道，只要在 <code>xib</code> 或者 <code>storyboard</code> 中拖一个 <code>UIView</code> 到界面上，然后将类名改成 <code>Canvas</code> 后回车就可以了，Xcode 应该会自动将 Module 设置成 <code>MaLiang</code>。</p>\n</li>\n</ul>\n<p>给 <code>Canvas</code> 设置正确的布局约束，然后你就可以开始涂鸦了，比如写两个毛笔字：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/619631-357782e1e0895a94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>嗯，请忽略我的书法水平… 想画成这样，还缺少一些东西 :)</p>\n<p><code>Canvas</code> 继承自 <code>MetalView</code>, <code>MetalView</code> 做了几乎所有与 <code>Metal</code> 打交道的事情，虽然它被定义成一个 <code>open</code> 的类，但是如果不是深度定制的话，应该不需要对它进行扩展。</p>\n<p><strong>MaLiang</strong> 涂鸦的核心是纹理(<code>Texture</code>)，本质上就是沿着手指轨迹，不断地将纹理叠加到画布上的过程。所以能画出什么样的笔迹，完全取决于使用的纹理，以及它的大小、颜色、尺寸、透明度等等这些参数。</p>\n<p><code>MetalView</code> 初始化之后会创建一个默认的纹理，这个纹理就是一个简单的不透明的圆点，所以只能画最简单的线条。如果想要画出上图那样的效果，就需要使用相对复杂一点的纹理了。<strong>MaLiang</strong> 的示例项目里面提供了好几个设定好的纹理，用他们可以模拟出铅笔、水笔以及毛笔的特效，上面的文字就是使用毛笔特效写出来的。</p>\n<h6 id=\"快照\"><a href=\"#快照\" class=\"headerlink\" title=\"快照\"></a>快照</h6><p><code>Canvas</code> 提供了一个简单的快照功能：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">snapshot</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">UIImage?</span></span><br></pre></td></tr></table></figure>\n<p>调用该方法会对画布生成一个当前内容的快照并以 Image 的形式返回，快照的实现逻辑很简单，你也可以自己实现更加复杂的快照逻辑。</p>\n<h5 id=\"2-Brush\"><a href=\"#2-Brush\" class=\"headerlink\" title=\"2. Brush\"></a>2. Brush</h5><p>直接使用纹理还是比较繁琐的，另外与纹理相关的还有颜色、线条的粗细以及其他一些参数，所以这里提供了一个 <code>Brush</code> 类来处理所有的这些数据。</p>\n<p><code>Brush</code> 的属性在改变后会立刻影响接下来的绘制效果。</p>\n<ul>\n<li><code>opacity</code> 透明度</li>\n</ul>\n<p>上面提到，涂鸦的本质是把纹理叠加到画笔的过程，所以想要做出深浅不一的笔迹，纹理就需要具有透明度，可以通过\b<code>opacity</code> 属性来调节。</p>\n<ul>\n<li><code>pointSize</code> 笔迹粗细</li>\n</ul>\n<p><code>pointSize</code> 直接影响笔迹的粗细，它是以 iOS 尺寸的标准单位 <strong>点(<code>point</code>)</strong> 来衡量的，所以这是一个自适应屏幕像素密度的属性。你不需要根据设备类型来计算实际像素，直接指定眼睛可见的大小就可以了。</p>\n<ul>\n<li><code>pointStep</code> 点距</li>\n</ul>\n<p>同上，由于\b笔迹是通过叠加纹理实现的，因此除了透明度外，两个纹理之间的距离也会影响到笔迹的深浅。另外如果把点距设定到大于笔迹的尺寸，甚至可以画出类似虚线的效果。点距的单位也是 <strong>点(<code>point</code>)</strong>。</p>\n<ul>\n<li><code>forceSensitive</code> 压力敏感度</li>\n</ul>\n<p>之所以说 <code>pointSize</code> 是影响笔迹的粗细，而不是直接确定，是因为有压力感应的存在。笔迹的实际尺寸会随着压力的大小在 <code>pointSize</code> 指定的尺寸上下浮动，压力越大，笔迹越粗。<code>forceSensitive</code> 影响笔迹对压力浮动的剧烈程度，建议设置为 <code>0</code> - <code>1</code> 之间的某个值。如果设置过大，笔迹随压力的便会会太过剧烈而失真；如果将 <code>forceSensitive</code> 的值设置为 <code>0</code>，则对该画笔关闭压力感应效果，笔迹粗细不会随着压力而变化。</p>\n<p><strong>MaLiang</strong> 默认使用 iOS 设备的 <strong>3D Touch</strong> 参数，另外在一些不支持压力感应的设备上使用模拟的压力感应。模拟压感依赖手势移动的速度来判断压力的大小。</p>\n<ul>\n<li><code>color</code> 颜色</li>\n</ul>\n<p>影响笔迹的颜色，实际画出的颜色会计算进 <code>opacity</code> 的值，不过由于纹理之间会叠加，所以相互效果可以基本抵消。你一般不需要为颜色额外指定透明度的值。</p>\n<ul>\n<li><code>texture</code> 纹理</li>\n</ul>\n<p><code>texture</code> 是一个非公开属性，实际使用时只需要使用纹理图的 Image 初始化 <code>Brush</code> 对象就可以了，不需要关心 <code>texture</code> 的具体实现。</p>\n<p>对于纯色线条，颜色是根据对画笔所指定的 <code>color</code> 属性来决定的，纹理只需要提供准确的透明度信息即可，因此可以是任意颜色。</p>\n<h5 id=\"3-CanvasData\"><a href=\"#3-CanvasData\" class=\"headerlink\" title=\"3. CanvasData\"></a>3. CanvasData</h5><p><code>CanvasData</code> 会在画布创建后自动初始化，它保存了当前画布上的所有笔迹信息，依赖这些数据，目前实现了撤销和重做功能。<br>通过 <code>CanvasData</code> 持有的数据，还可以轻松实现保存涂鸦数据到文件的逻辑。反过来也可以将保存的数据重新还原成画布图像，这样可以实现跨设备的数据同步功能。<strong>MaLiang</strong> 提供了一个默认版本的数据保存和读取的逻辑，你可以在此基础上做进一步的封装，也可以完全另外实现你自己的存储逻辑。</p>\n<h2 id=\"MaLiang-进化史\"><a href=\"#MaLiang-进化史\" class=\"headerlink\" title=\"MaLiang 进化史\"></a>MaLiang 进化史</h2><ul>\n<li><p><strong>MaLiang</strong> 起源于 12 年的一个涂鸦项目，当时还是基于 Objective-C 和 OpenGL ES1 实现的，OpenGL \bES1 对于抗锯齿的支持不是很好，所以涂鸦的效果不怎么敢恭维。并且当时由于太年轻，整个框架的设计和结构都比较凌乱。虽然最后顺利上架了一段时间，不过由于各种各样的原因，整个项目随当时的公司一起无疾而终了。</p>\n</li>\n<li><p>18年业余时间重拾了这个项目，基于 OpenGL ES3，使用 Swift 完全重写，同时对整个项目结构进行了重新设计和改进，并进行了少量的扩展。</p>\n</li>\n<li><p>然而生不逢时，MaLiang 刚完成没多久，苹果就宣布废除 OpenGL ES，iOS 平台 Metal 成了唯一选项。但由于我对 OpenGL ES 都只是一知半解，Metal 就研究的更少了，将 MaLiang 迁移到 Metal 的计划便一直处于搁浅状态。</p>\n</li>\n<li><p>直到最近才终于下定决心，从渲染管线到着色器语言，恶补了 Metal 相关的基础知识，终于将底层绘制相关的逻辑全部用 Metal 改写，并且对上层逻辑进行了部分重构。同时顺便将原来基本没有用户体验的缩放功能完全重写，实现了可以放大画布之后绘制微缩图案的功能。</p>\n</li>\n</ul>\n<p><em>当然了，我对 Metal 的理解还很浅薄，<strong>MaLiang</strong> 还是有很多需要优化改进的地方。</em></p>\n<h2 id=\"Why-Swift？\"><a href=\"#Why-Swift？\" class=\"headerlink\" title=\"Why Swift？\"></a>Why Swift？</h2><p>Swift 从 15 年开始就作为我的主要开发语言了，所以回去写 OC 对我来说已经不可能，尽管之前写 OpenGL 时使用 Swift 确实很麻烦，不过最后还是完成了。</p>\n<p>当时有大佬奉劝我使用 OC 或者 C 作为中间层来调用 OpenGL，再用 Swift 封装上层逻辑，确实这样可以以最低的成本实现需要的效果。不过作为一个业余项目，成本并不是我第一考虑的要素，而且这个库虽然是基于 OpenGL 的，但是真正跟 OpenGL 打交道的，其实也就那几百行代码。为了追求这一点点成本和便利性，牺牲整个项目结构的统一和整洁，在我这是无法接受的。</p>\n<p>而坚持使用 Swift 的好处在最近迁移到 Metal 时就表现出来了。只需要对几处OpenGL的关键绘制逻辑使用 Metal 改写，就能很快完成迁移，否则就需要重写整个底层逻辑了 :)</p>\n<p><del>另外，引入 OC 代码意味着\b同时引入了 OC 的动态运行时环境，这对 Swift 的执行效率会有一定的影响。虽然作为一个 iOS 的项目，现在必然无法摆脱 OC 的动态运行时环境，我的这点偏执似乎也没有什么意义，不过谁知道以后会怎么样呢 :)</del></p>\n<p>在这个时间点，Swift 5 刚好发布没多久，终于迎来了 ABI 稳定这一天，这意味着 Swift App 距离脱离 OC 的动态运行时，完全运行在纯 Swift 环境中那一天已经不远了:)</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>说了半天，这个库有什么用？说实话我也不知道，或许可以用来做签名？不过签名其实用 <code>CoreGraphics</code> 就足够了。或许可以用它来做一个画画的 App 来逗小孩玩，可能我真会这么干。。。</p>\n<p>说到底，这主要是对当初懵懂时期经历的一个纪念吧。感兴趣的都可以拿去玩 :)</p>\n<p><del>接下来可能会打算基于这个库开发一款涂鸦的 App。当然了，多年前的那个项目是不会复活了，新的这个 App 会是一个融合了很多我自己想法的全新项目。当然了希望不要半途而废 - -!</del></p>\n<p>基于 MaLiang 的涂鸦 App 已经开发完成并上线，可以在 AppStore 搜索 <strong>马良</strong> <a href=\"https://apps.apple.com/cn/app/id1462615532\" target=\"_blank\" rel=\"noopener\">下载体验</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>取这个名字有投机取巧的嫌疑，希望能对得起先贤 &gt;_&lt;</p>\n</blockquote>\n<p><strong>MaLiang 现已全面升级到 Metal。</strong><br><em>本文已针对最新 Metal 版本更新，最后更新于：2019-05-10</em></p>\n<h2 id=\"这是什么？\"><a href=\"#这是什么？\" class=\"headerlink\" title=\"这是什么？\"></a>这是什么？</h2><p><strong><a href=\"https://github.com/Harley-xk/MaLiang\" target=\"_blank\" rel=\"noopener\">MaLiang</a></strong> 是 iOS 平台基于 Metal 的涂鸦绘图框架，完全使用 Swift 实现，支持自定义纹理、缩放、压力感应等特性，并且提供了较大的自定义扩展的空间。</p>\n<h2 id=\"特色功能\"><a href=\"#特色功能\" class=\"headerlink\" title=\"特色功能\"></a>特色功能</h2><ul>\n<li>笔迹通过贝塞尔曲线进行平滑处理</li>\n<li>支持添加自定义贴图</li>\n<li>纹理和贴图支持旋转</li>\n<li>内置一个荧光笔特效的实现</li>\n<li>可以根据压力自动调整笔迹，支持 3D Touch</li>\n<li>支持撤销和重做</li>\n<li>支持滚动和缩放画布</li>\n<li>导出绘制内容为图片</li>\n<li>将绘制内容保存为矢量文档和从文档恢复数据</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>我的理念是尽量制造简单、优雅的东西，虽然有时候要做到这一点其实很难，但是尽量往这方面靠吧。<strong>MaLiang</strong> 的集成和使用都很简单，我把大量对使用者来说没有什么用也没有必要了解的内部逻辑都隐藏了。这篇文章也会介绍一些内部实现的思路。</p>\n<h3 id=\"集成\"><a href=\"#集成\" class=\"headerlink\" title=\"集成\"></a>集成</h3><h4 id=\"Cocoapods\"><a href=\"#Cocoapods\" class=\"headerlink\" title=\"Cocoapods\"></a>Cocoapods</h4><p><strong>MaLiang</strong> 已经推送到了 Cocopods 的官方 repo，所以，你只需要在 Podfile 增加一条 Pod 指令然后 <code>install</code> 就可以在项目中使用了：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod <span class=\"string\">'MaLiang'</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你想使用老的 OpenGL 版本，请指定到 1.1.x 版本</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod <span class=\"string\">'MaLiang'</span>, <span class=\"string\">'~&gt; 1.1'</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>需要注意 OpenGL 版本只包含有限的功能并且已停止维护</strong></p>\n<h3 id=\"Carthage\"><a href=\"#Carthage\" class=\"headerlink\" title=\"Carthage\"></a>Carthage</h3><p><strong>MaLiang</strong> 现在也支持通过 <a href=\"https://github.com/Carthage/Carthage\" target=\"_blank\" rel=\"noopener\">Carthage</a> 集成，首先在 <code>Cartfile</code> 中增加指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">github &quot;Harley-xk&#x2F;MaLiang&quot;</span><br></pre></td></tr></table></figure>\n<p>然后执行 <code>cartage update</code> 命令来完成编译，然后将编译完成的 <code>MaLiang.framework</code> 添加到 Xcode 项目中。</p>\n<p><strong>需要确保将 <code>MaLiang.framework</code> 添加到 target 的 <code>Embedded Binaries</code> 中</strong></p>\n<h3 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h3><p>在需要使用的地方引入 Mudule。当然，首先需要编译一下，否在会报找不到 Moudle 的错误</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> MaLiang</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"几个主要的类\"><a href=\"#几个主要的类\" class=\"headerlink\" title=\"几个主要的类\"></a>几个主要的类</h4><h5 id=\"1-Canvas\"><a href=\"#1-Canvas\" class=\"headerlink\" title=\"1. Canvas\"></a>1. Canvas</h5><p>画布是 <strong>MaLiang</strong> 最基础的组件，所有的涂鸦都发生在 <code>Canvas</code> 上。<code>Canvas</code> 本质上是一个 <code>UIView</code>，所以你可以使用任何你原来创建 <code>UIView</code> 的方法来创建一个画布，并将它添加到你的界面上。</p>\n<ul>\n<li><p>如果你偏好代码流，那么直接调用 <code>UIView</code> 的通用构造函数 <code>init(frame:)</code> 就可以了。</p>\n</li>\n<li><p>如果你觉得 <code>IB</code> 流才是正道，只要在 <code>xib</code> 或者 <code>storyboard</code> 中拖一个 <code>UIView</code> 到界面上，然后将类名改成 <code>Canvas</code> 后回车就可以了，Xcode 应该会自动将 Module 设置成 <code>MaLiang</code>。</p>\n</li>\n</ul>\n<p>给 <code>Canvas</code> 设置正确的布局约束，然后你就可以开始涂鸦了，比如写两个毛笔字：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/619631-357782e1e0895a94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>嗯，请忽略我的书法水平… 想画成这样，还缺少一些东西 :)</p>\n<p><code>Canvas</code> 继承自 <code>MetalView</code>, <code>MetalView</code> 做了几乎所有与 <code>Metal</code> 打交道的事情，虽然它被定义成一个 <code>open</code> 的类，但是如果不是深度定制的话，应该不需要对它进行扩展。</p>\n<p><strong>MaLiang</strong> 涂鸦的核心是纹理(<code>Texture</code>)，本质上就是沿着手指轨迹，不断地将纹理叠加到画布上的过程。所以能画出什么样的笔迹，完全取决于使用的纹理，以及它的大小、颜色、尺寸、透明度等等这些参数。</p>\n<p><code>MetalView</code> 初始化之后会创建一个默认的纹理，这个纹理就是一个简单的不透明的圆点，所以只能画最简单的线条。如果想要画出上图那样的效果，就需要使用相对复杂一点的纹理了。<strong>MaLiang</strong> 的示例项目里面提供了好几个设定好的纹理，用他们可以模拟出铅笔、水笔以及毛笔的特效，上面的文字就是使用毛笔特效写出来的。</p>\n<h6 id=\"快照\"><a href=\"#快照\" class=\"headerlink\" title=\"快照\"></a>快照</h6><p><code>Canvas</code> 提供了一个简单的快照功能：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">snapshot</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">UIImage?</span></span><br></pre></td></tr></table></figure>\n<p>调用该方法会对画布生成一个当前内容的快照并以 Image 的形式返回，快照的实现逻辑很简单，你也可以自己实现更加复杂的快照逻辑。</p>\n<h5 id=\"2-Brush\"><a href=\"#2-Brush\" class=\"headerlink\" title=\"2. Brush\"></a>2. Brush</h5><p>直接使用纹理还是比较繁琐的，另外与纹理相关的还有颜色、线条的粗细以及其他一些参数，所以这里提供了一个 <code>Brush</code> 类来处理所有的这些数据。</p>\n<p><code>Brush</code> 的属性在改变后会立刻影响接下来的绘制效果。</p>\n<ul>\n<li><code>opacity</code> 透明度</li>\n</ul>\n<p>上面提到，涂鸦的本质是把纹理叠加到画笔的过程，所以想要做出深浅不一的笔迹，纹理就需要具有透明度，可以通过\b<code>opacity</code> 属性来调节。</p>\n<ul>\n<li><code>pointSize</code> 笔迹粗细</li>\n</ul>\n<p><code>pointSize</code> 直接影响笔迹的粗细，它是以 iOS 尺寸的标准单位 <strong>点(<code>point</code>)</strong> 来衡量的，所以这是一个自适应屏幕像素密度的属性。你不需要根据设备类型来计算实际像素，直接指定眼睛可见的大小就可以了。</p>\n<ul>\n<li><code>pointStep</code> 点距</li>\n</ul>\n<p>同上，由于\b笔迹是通过叠加纹理实现的，因此除了透明度外，两个纹理之间的距离也会影响到笔迹的深浅。另外如果把点距设定到大于笔迹的尺寸，甚至可以画出类似虚线的效果。点距的单位也是 <strong>点(<code>point</code>)</strong>。</p>\n<ul>\n<li><code>forceSensitive</code> 压力敏感度</li>\n</ul>\n<p>之所以说 <code>pointSize</code> 是影响笔迹的粗细，而不是直接确定，是因为有压力感应的存在。笔迹的实际尺寸会随着压力的大小在 <code>pointSize</code> 指定的尺寸上下浮动，压力越大，笔迹越粗。<code>forceSensitive</code> 影响笔迹对压力浮动的剧烈程度，建议设置为 <code>0</code> - <code>1</code> 之间的某个值。如果设置过大，笔迹随压力的便会会太过剧烈而失真；如果将 <code>forceSensitive</code> 的值设置为 <code>0</code>，则对该画笔关闭压力感应效果，笔迹粗细不会随着压力而变化。</p>\n<p><strong>MaLiang</strong> 默认使用 iOS 设备的 <strong>3D Touch</strong> 参数，另外在一些不支持压力感应的设备上使用模拟的压力感应。模拟压感依赖手势移动的速度来判断压力的大小。</p>\n<ul>\n<li><code>color</code> 颜色</li>\n</ul>\n<p>影响笔迹的颜色，实际画出的颜色会计算进 <code>opacity</code> 的值，不过由于纹理之间会叠加，所以相互效果可以基本抵消。你一般不需要为颜色额外指定透明度的值。</p>\n<ul>\n<li><code>texture</code> 纹理</li>\n</ul>\n<p><code>texture</code> 是一个非公开属性，实际使用时只需要使用纹理图的 Image 初始化 <code>Brush</code> 对象就可以了，不需要关心 <code>texture</code> 的具体实现。</p>\n<p>对于纯色线条，颜色是根据对画笔所指定的 <code>color</code> 属性来决定的，纹理只需要提供准确的透明度信息即可，因此可以是任意颜色。</p>\n<h5 id=\"3-CanvasData\"><a href=\"#3-CanvasData\" class=\"headerlink\" title=\"3. CanvasData\"></a>3. CanvasData</h5><p><code>CanvasData</code> 会在画布创建后自动初始化，它保存了当前画布上的所有笔迹信息，依赖这些数据，目前实现了撤销和重做功能。<br>通过 <code>CanvasData</code> 持有的数据，还可以轻松实现保存涂鸦数据到文件的逻辑。反过来也可以将保存的数据重新还原成画布图像，这样可以实现跨设备的数据同步功能。<strong>MaLiang</strong> 提供了一个默认版本的数据保存和读取的逻辑，你可以在此基础上做进一步的封装，也可以完全另外实现你自己的存储逻辑。</p>\n<h2 id=\"MaLiang-进化史\"><a href=\"#MaLiang-进化史\" class=\"headerlink\" title=\"MaLiang 进化史\"></a>MaLiang 进化史</h2><ul>\n<li><p><strong>MaLiang</strong> 起源于 12 年的一个涂鸦项目，当时还是基于 Objective-C 和 OpenGL ES1 实现的，OpenGL \bES1 对于抗锯齿的支持不是很好，所以涂鸦的效果不怎么敢恭维。并且当时由于太年轻，整个框架的设计和结构都比较凌乱。虽然最后顺利上架了一段时间，不过由于各种各样的原因，整个项目随当时的公司一起无疾而终了。</p>\n</li>\n<li><p>18年业余时间重拾了这个项目，基于 OpenGL ES3，使用 Swift 完全重写，同时对整个项目结构进行了重新设计和改进，并进行了少量的扩展。</p>\n</li>\n<li><p>然而生不逢时，MaLiang 刚完成没多久，苹果就宣布废除 OpenGL ES，iOS 平台 Metal 成了唯一选项。但由于我对 OpenGL ES 都只是一知半解，Metal 就研究的更少了，将 MaLiang 迁移到 Metal 的计划便一直处于搁浅状态。</p>\n</li>\n<li><p>直到最近才终于下定决心，从渲染管线到着色器语言，恶补了 Metal 相关的基础知识，终于将底层绘制相关的逻辑全部用 Metal 改写，并且对上层逻辑进行了部分重构。同时顺便将原来基本没有用户体验的缩放功能完全重写，实现了可以放大画布之后绘制微缩图案的功能。</p>\n</li>\n</ul>\n<p><em>当然了，我对 Metal 的理解还很浅薄，<strong>MaLiang</strong> 还是有很多需要优化改进的地方。</em></p>\n<h2 id=\"Why-Swift？\"><a href=\"#Why-Swift？\" class=\"headerlink\" title=\"Why Swift？\"></a>Why Swift？</h2><p>Swift 从 15 年开始就作为我的主要开发语言了，所以回去写 OC 对我来说已经不可能，尽管之前写 OpenGL 时使用 Swift 确实很麻烦，不过最后还是完成了。</p>\n<p>当时有大佬奉劝我使用 OC 或者 C 作为中间层来调用 OpenGL，再用 Swift 封装上层逻辑，确实这样可以以最低的成本实现需要的效果。不过作为一个业余项目，成本并不是我第一考虑的要素，而且这个库虽然是基于 OpenGL 的，但是真正跟 OpenGL 打交道的，其实也就那几百行代码。为了追求这一点点成本和便利性，牺牲整个项目结构的统一和整洁，在我这是无法接受的。</p>\n<p>而坚持使用 Swift 的好处在最近迁移到 Metal 时就表现出来了。只需要对几处OpenGL的关键绘制逻辑使用 Metal 改写，就能很快完成迁移，否则就需要重写整个底层逻辑了 :)</p>\n<p><del>另外，引入 OC 代码意味着\b同时引入了 OC 的动态运行时环境，这对 Swift 的执行效率会有一定的影响。虽然作为一个 iOS 的项目，现在必然无法摆脱 OC 的动态运行时环境，我的这点偏执似乎也没有什么意义，不过谁知道以后会怎么样呢 :)</del></p>\n<p>在这个时间点，Swift 5 刚好发布没多久，终于迎来了 ABI 稳定这一天，这意味着 Swift App 距离脱离 OC 的动态运行时，完全运行在纯 Swift 环境中那一天已经不远了:)</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>说了半天，这个库有什么用？说实话我也不知道，或许可以用来做签名？不过签名其实用 <code>CoreGraphics</code> 就足够了。或许可以用它来做一个画画的 App 来逗小孩玩，可能我真会这么干。。。</p>\n<p>说到底，这主要是对当初懵懂时期经历的一个纪念吧。感兴趣的都可以拿去玩 :)</p>\n<p><del>接下来可能会打算基于这个库开发一款涂鸦的 App。当然了，多年前的那个项目是不会复活了，新的这个 App 会是一个融合了很多我自己想法的全新项目。当然了希望不要半途而废 - -!</del></p>\n<p>基于 MaLiang 的涂鸦 App 已经开发完成并上线，可以在 AppStore 搜索 <strong>马良</strong> <a href=\"https://apps.apple.com/cn/app/id1462615532\" target=\"_blank\" rel=\"noopener\">下载体验</a>。</p>\n"},{"title":"Swift 4 踩坑之 Codable 协议","abstract":"Swift 由于类型安全的特性，对于像 JSON 这类弱类型的数据处理一直是一个比较头疼的问题，虽然市面上许多优秀的第三方库在这方面做了不少努力，但是依然存在着很多难以克服的缺陷，所以 Codable 协议的推出，一来打破了这样的僵局，二来也给我们解决类似问题提供了新的思路...","_content":"\n> WWDC 过去有一段时间了，最近终于有时间空闲，可以静下心来仔细研究一下相关内容。对于开发者来说，本届WWDC 最重要的消息还是得属 Swift 4 的推出。\n>\n> Swift 经过三年的发展，终于在 API 层面趋于稳定。从 Swift 3 迁移代码到 Swift 4 终于不用像 2 到 3 那样痛苦了。这对开发者来说实在是个重大利好，应该会吸引一大批对 Swift 仍然处于观望状态的开发者加入。\n>\n> 另外 Swift 4 引入了许多新的特性，像是 fileprivate 关键字的限制范围更加精确了；声明属性终于可以同时限制类型和协议了；新的 KeyPath API 等等，从这些改进我们可以看到，Swift 的生态越来越完善，Swift 本身也越来越强大。\n>\n> 而 Swift 4 带来的新特性中，最让人眼前一亮的，我觉得非 **Codable** 协议莫属，下面就来介绍下我自己对 **Codable** 协议踩坑的经验总结。\n\n## 简单介绍\n\nSwift 由于类型安全的特性，对于像 JSON 这类弱类型的数据处理一直是一个比较头疼的问题，虽然市面上许多优秀的第三方库在这方面做了不少努力，但是依然存在着很多难以克服的缺陷，所以 **Codable** 协议的推出，一来打破了这样的僵局，二来也给我们解决类似问题提供了新的思路。\n\n通过查看定义可以看到，**Codable** 其实是一个组合协议，由 `Decodable` 和 `Encodable` 两个协议组成：\n\n```swift\n/// A type that can convert itself into and out of an external representation.\npublic typealias Codable = Decodable & Encodable\n\n/// A type that can encode itself to an external representation.\npublic protocol Encodable {\n    public func encode(to encoder: Encoder) throws\n}\n\n/// A type that can decode itself from an external representation.\npublic protocol Decodable {\n    public init(from decoder: Decoder) throws\n}\n```\n`Encodable` 和 `Decodable` 分别定义了 `encode(to:)` 和 `init(from:)` 两个协议函数，分别用来实现数据模型的归档和外部数据的解析和实例化。最常用的场景就是接口 JSON 数据解析和模型创建。但是 **Codable** 的能力并不止于此，这个后面会说。\n\n## 解析 JSON 对象\n\n先来看 `Decodable` 对 JSON 数据对象的解析。Swift 为我们做了绝大部分的工作，Swift 中的基本数据类型比如 `String`、`Int`、`Float` 等都已经实现了 **Codable** 协议，因此如果你的数据类型只包含这些基本数据类型的属性，只需要在类型声明中加上 **Codable** 协议就可以了，不需要写任何实际实现的代码，这也是 **Codable** 最大的优势所在。\n\n比如我们有下面这样一个学生信息的 JSON 字符串：\n\n```swift\nlet jsonString =\n\"\"\"\n{\n    \"name\": \"小明\",\n    \"age\": 12,\n    \"weight\": 43.2\n}\n\"\"\"\n```\n\n这时候，只需要定义一个 `Student` 类型，声明实现 `Decodable` 协议即可，Swift 4 已经为我们提供了默认的实现：\n\n```swift\nstruct Student: Decodable {   \n    var name: String\n    var age: Int\n    var weight: Float\n}\n```\n\n然后，只需要一行代码就可以将 ***小明*** 解析出来了：\n\n```swift\nlet xiaoming = try JSONDecoder().decode(Student.self, from: jsonString.data(using: .utf8)!)\n```\n这里需要注意的是, `decode` 函数需要外部数据类型为 `Data` 类型，如果是字符串需要先转换为 `Data` 之后操作，不过像 [**Alamofire**](https://github.com/Alamofire/Alamofire) 之类的网络框架，返回数据原本就是 `Data` 类型的。\n另外 `decode` 函数是标记为 `throws` 的，如果解析失败，会抛出一个异常，为了保证程序的健壮性，需要使用 `do-catch` 对异常情况进行处理:\n\n```swift\ndo {\n    let xiaoming = try JSONDecoder().decode(Student.self, from: data)\n} catch {\n    // 异常处理\n}\n```\n\n### 特殊数据类型\n很多时候光靠基本数据类型并不能完成工作，往往我们需要用到一些特殊的数据类型。Swift 对许多特殊数据类型也提供了默认的 **Codable** 实现，但是有一些限制。\n\n#### 枚举\n\n```json\n{\n    ...\n    \"gender\": \"male\"\n    ...\n}\n```\n性别是一个很常用的信息，我们经常会把它定义成枚举：\n\n```swift\nenum Gender {\n    case male\n    case female\n    case other\n}\n```\n枚举类型也默认实现了 **Codable** 协议，但是如果我们直接声明 `Gender` 枚举支持 **Codable** 协议，编译器会提示没有提供实现：\n\n![](http://upload-images.jianshu.io/upload_images/619631-f5f9ada526a1538a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其实这里有一个限制：枚举类型要默认支持 **Codable** 协议，需要声明为具有原始值的形式，并且原始值的类型需要支持 **Codable** 协议：\n\n```swift\nenum Gender: String, Decodable {\n    case male\n    case female\n    case other\n}\n```\n由于枚举类型原始值隐式赋值特性的存在，如果枚举值的名称和对应的 JSON 中的值一致，不需要显式指定原始值即可完成解析。\n\n#### Bool\n\n我们的数据模型现在新增了一个字段，用来表示某个学生是否是少先队员：\n\n```json\n{\n    ...\n    \"isYoungPioneer\": true\n    ...\n}\n```\n这时候，直接声明对应的属性就可以了:\n\n```swift\nvar isYoungPioneer: Bool\n```\n`Bool` 类型原本没什么好讲的，不过因为踩到了坑，所以还是得说一说：\n目前发现的坑是：`Bool` 类型默认**只支持 `true`/`false` 形式的 `Bool` 值解析**。对于一些使用 `0`/`1` 形式来表示 `Bool` 值的后端框架，只能通过 `Int` 类型解析之后再做转换了，或者可以自定义实现 **Codable** 协议。\n\n#### 日期解析策略\n说了枚举和 `Bool`，另外一个常用的特殊类型就是 `Date` 了，`Date` 类型的特殊性在于它有着各种各样的格式标准和表示方式，从数字到字符串可以说是五花八门，解析 `Date` 类型是任何一个同类型的框架都必须面对的课题。\n\n对此，**Codable** 给出的解决方案是：定义解析策略。`JSONDecoder` 类声明了一个 `DateDecodingStrategy` 类型的属性，用来制定 `Date` 类型的解析策略，同样先看定义：\n\n```swift\n/// The strategy to use for decoding `Date` values.\npublic enum DateDecodingStrategy {\n    \n    /// Defer to `Date` for decoding. This is the default strategy.\n    case deferredToDate\n    \n    /// Decode the `Date` as a UNIX timestamp from a JSON number.\n    case secondsSince1970\n    \n    /// Decode the `Date` as UNIX millisecond timestamp from a JSON number.\n    case millisecondsSince1970\n    \n    /// Decode the `Date` as an ISO-8601-formatted string (in RFC 3339 format).\n    case iso8601\n    \n    /// Decode the `Date` as a string parsed by the given formatter.\n    case formatted(DateFormatter)\n    \n    /// Decode the `Date` as a custom value decoded by the given closure.\n    case custom((Decoder) throws -> Date)\n}\n```\n**Codable** 对几种常用格式标准进行了支持，默认启用的策略是 `deferredToDate`，即从 **UTC 时间2001年1月1日 **开始的秒数，对应 `Date` 类型中 `timeIntervalSinceReferenceDate` 这个属性。比如 `519751611.125429` 这个数字解析后的结果是 `2017-06-21 15:26:51 +0000`。\n\n另外可选的格式标准有 `secondsSince1970`、`millisecondsSince1970`、[`iso8601`](https://zh.wikipedia.org/wiki/ISO_8601) 等，这些都是有详细说明的通用标准，不清楚的自行谷歌吧 :)\n\n同时 **Codable** 提供了两种方自定义 `Date` 格式的策略：\n- `formatted(DateFormatter)`\n  这种策略通过设置 `DateFormatter` 来指定 `Date` 格式\n- `custom((Decoder) throws -> Date)`\n  `custom` 策略接受一个 `(Decoder) -> Date` 的闭包，基本上是把解析任务完全丢给我们自己去实现了，具有较高的自由度\n\n#### 小数解析策略\n小数类型（`Float`／`Double`） 默认也实现了 **Codable** 协议，但是小数类型在 Swift 中有许多特殊值，比如圆周率（`Float.pi`）等。这里要说的是另外两个属性，先看定义：\n\n```swift\n/// Positive infinity.\n///\n/// Infinity compares greater than all finite numbers and equal to other\n/// infinite values.\npublic static var infinity: Double { get }\n\n/// A quiet NaN (\"not a number\").\n///\n/// A NaN compares not equal, not greater than, and not less than every\n/// value, including itself. Passing a NaN to an operation generally results\n/// in NaN.\npublic static var nan: Double { get }\n```\n`infinity` 表示正无穷（负无穷写作：`-infinity`），`nan` 表示没有值，这些特殊值没有办法使用数字进行表示，但是在 Swift 中它们是确确实实的值，可以参与计算、比较等。\n不同的语言、框架对此会有类似的实现，但是表达方式可能不完全相同，因此如果在某些场景下需要解析这样的值，就需要做特殊转换了。\n\n**Codable** 的实现方式比较简单粗暴，`JSONDecoder` 类型有一个属性 `nonConformingFloatDecodingStrategy` ，用来指定不一致的小数转换策略，默认值为 `throw`， 即直接抛出异常，解析失败。另外一个选择就是自己指定 `infinity`、`-infinity`、`nan` 三个特殊值的表示方式：\n\n```swift\nlet decoder = JSONDecoder()\ndecoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: \"infinity\", negativeInfinity: \"-infinity\", nan: \"nan\")\n// 另外一种表示方式\n// decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: \"∞\", negativeInfinity: \"-∞\", nan: \"n/a\")\n```\n目前看来只支持这三个特殊值的转换，不过这种特殊值的使用场景应该非常有限，至少在我自己五六年的开发生涯中还没有遇到过。\n\n### 自定义数据类型\n\n纯粹的基本数据类型依然不能很好地工作，实际项目的数据结构往往是很复杂的，一个数据类型经常会包含另一个数据类型的属性。比如说我们这个例子中，每个学生信息中还包含了所在学校的信息：\n\n```json\n{\n    \"name\": \"小明\",\n    \"age\": 12,\n    \"weight\": 43.2\n    \"school\": {\n      \"name\": \"市第一中学\",\n      \"address\": \"XX市人民中路 66 号\"\n    }\n}\n```\n\n这时候就需要 Student 和 School 两个类型来组合表示：\n\n```swift\nstruct School: Decodable {\n\tvar name: String\n\tvar address: String\n}\nstruct Student: Decodable {   \n    var name: String\n    var age: Int\n    var weight: Float\n    var school: School\n}\n```\n\n由于所有基本类型都实现了 **Codable** 协议，因此 `School` 与 `Student` 一样，只要所有属性都实现了 **Codable** 协议，就不需要手动提供任何实现即可获得默认的 **Codable** 实现。由于 `School` 支持了 **Codable** 协议，保证了 `Student` 依然能够获得默认的 **Codable** 实现，因此，嵌套类型的解析同样不需要额外的代码了。\n\n### 自定义字段\n\n很多时候前后端不一定能完全步调一致，观念相同。所以往往后端给出的数据结构中会有一些比较个性的字段名，当然有时候是我们自己。另外有一些框架（比如我正在用的 Laravel）习惯使用蛇形命名法，而 iOS 的代码规范推荐使用驼峰命名法，为了保证代码风格和平台特色，这时候就必须要自行指定字段名了。\n\n在研究自定义字段之前我们需要深入底层，了解下 **Codable** 默认是怎么实现属性的名称识别及赋值的。通过研究底层的 C++ 源代码可以发现，**Codable** 通过巧（kai）妙（guà）的方式，在编译代码时根据类型的属性，自动生成了一个 `CodingKeys` 的枚举类型定义，这是一个以 `String` 类型作为原始值的枚举类型，对应每一个属性的名称。然后再给每一个声明实现 **Codable** 协议的类型自动生成 `init(from:)` 和 `encode(to:)` 两个函数的具体实现，最终完成了整个协议的实现。\n\n所以我们可以自己实现 `CodingKeys` 的类型定义，并且给属性指定不同的原始值来实现自定义字段的解析。这样编译器会直接采用我们已经实现好的方案而不再重新生成一个默认的。\n\n比如 `Student` 需要增加一个出生日期的属性，后端接口使用蛇形命名，JSON 数据如下：\n\n```json\n{\n    \"name\": \"小明\",\n    \"age\": 12,\n    \"weight\": 43.2\n    \"birth_date\": \"1992-12-25\"\n}\n```\n\n这时候在 Student 类型声明中需要增加 `CodingKeys` 定义，并且将 `birthday` 的原始值设置为 `birth_date`：\n\n```swift\nstruct Student: Codable {\n\t...\n\tvar birthday: Date\n\t\n\tenum CodingKeys: String, CodingKey {\n        case name\n        case age\n        case weight\n        case birthday = \"birth_date\"\n    }\n}\n```\n\n需要注意的是，即使属性名称与 JSON 中的字段名称一致，如果自定义了 `CodingKeys`，这些属性也是无法省略的，否则会得到一个 `Type 'Student' does not conform to protocol 'Codable'` 的编译错误，这一点还是有点坑的。不过在编译时给 `CodingKeys` 补全其他默认的属性的声明在理论上是可行的，期待苹果后续的优化了。\n\n### 可选值\n\n有些字段有可能会是空值。还是用学生的出生日期来举例，假设有些学生的出生日期没有统计到，这时候后台返回数据格式有两种选择，一种是对于没有出生日期的数据，直接不包含 `birth_date` 字段，另一种是指定为空值：`\"birth_date\": null`\n\n对于这两种形式，都只需要将 birthday 属性声明为可选值即可正常解析：\n\n```swift\n...\nvar birthday: Date?\n...\n```\n\n## 解析 JSON 数组\n\n**Codable** 协议同样支持数组类型，只需要满足一个前提：只要数组中的元素实现了 **Codable** 协议，数组将自动获得 **Codable** 协议的实现。\n\n使用 `JSONDecoder` 解析时只需要指定类型为对应的数组即可：\n\n```swift\ndo {\n    let students = try JSONDecoder().decode([Student].self, from: data)\n} catch {\n    // 异常处理\n}\n```\n\n## 归档数据\n\n归档数据使用 `Encodable` 协议，使用方式与 `Decodable` 一致。\n\n### 导出为 JSON\n\n将数据模型转换为 JSON 与解析过程类似，将 JSONDecoder 更换为 JSONEncoder 即可：\n\n```swift\nlet data = try JSONEncoder().encode(xiaomin)\nlet json = String(data: data, encoding: .utf8)\n```\n\nJSONEncoder 有一个 outputFormatting 的属性，可以指定输出 JSON 的排版风格，看定义：\n\n```swift\npublic enum OutputFormatting {\n    \n    /// Produce JSON compacted by removing whitespace. This is the default formatting.\n    case compact\n    \n    /// Produce human-readable JSON with indented output.\n    case prettyPrinted\n}\n```\n\n- compact\n\n  默认的 compact 风格会移除 JSON 数据中的所有格式信息，比如换行、空格和缩紧等，以减小 JSON 数据所占的空间。如果导出的 JSON 数据用户程序间的通讯，对阅读要求不高时，推荐使用这个设置。\n\n- prettyPrinted\n\n  如果输出的 JSON 数据是用来阅读查看的，那么可以选择 prettyPrinted，这时候输出的 JSON 会自动进行格式化，添加换行、空格和缩进，以便于阅读。类似于上面文中使用的 JSON 排版风格。\n\n## 属性列表(PropertyList)\n\n**Codable** 协议并非只支持 JSON 格式的数据，它同样支持属性列表，即 mac 上常用的 `plist` 文件格式。这在我们做一些系统配置之类的工作时会很有用。\n\n属性列表的解析和归档秉承了苹果API一贯的简洁易用的特点，使用方式 JSON 格式一致，并不需要对已经实现的 **Codable** 协议作任何修改，只需要将 `JSONEncoder` 和 `JSONDecoder` 替换成对应的 `PropertyListEncoder` 和 `PropertyListDecoder` 即可。\n\n属性列表本质上是特殊格式标准的 `XML` 文档，所以理论上来说，我们可以参照系统提供的 Decoder/Encoder 自己实现任意格式的数据序列化与反序列化方案。同时苹果也随时可能通过实现新的 Decoder/Encoder 类来扩展其他数据格式的处理能力。这也正是文章开头所说的，**Codable** 的能力并不止于此，它具有很大的可扩展空间。\n\n## 结语\n\n到此 **Codable** 的核心用法基本讲完了。相比目前比较常用的几个框架：\n\n[**ObjectMapper**](https://github.com/Hearst-DD/ObjectMapper) 使用范型机制进行模型解析，但是需要手动对每一个属性写映射关系，比较繁琐。我自己项目中也是用的这个框架，后来自己对其做了些优化，利用反射机制对基本数据类型实现了自动解析，但是自定义类型仍然需要手动写映射，并且必须继承实现了自动解析的 Model 基类，限制较多。\n\n[**SwiftyJSON**](https://github.com/SwiftyJSON/SwiftyJSON) 简单了解过，其本质其实只是将 JSON 解析成了字典类型的数据，而实际使用时依然需要使用下标方式去取值，非常繁琐且容易出错，不易阅读和维护，个人认为这是很糟糕的设计。\n\n[**HandyJSON**](https://github.com/alibaba/HandyJSON) 是阿里推出的框架，思路与 **Codable** 殊途同归，之前也用过一阵，当时因为对枚举和 `Date` 等类型的支持还不够完善，最终还是用回了**ObjectMapper**。不过目前看来完善程度已经很高了，或许可以再次尝试踩下坑。\n\n总体来说，**Codable** 作为语言层面对模型解析的支持方案，有其自身的优势。不过在灵活性上稍有欠缺，对自定义字段的支持也还不够人性化，期待后续的完善。\n\n对于第三方库来说，**Codable** 的推出既是一种挑战，但同时也是一个机遇，相信这些框架的作者们都会从 Codaable 获得许多灵感来优化提升自己的框架，在不久的将来制造一个百家争鸣的局面。","source":"_posts/codable-swift-4.md","raw":"---\ntitle: Swift 4 踩坑之 Codable 协议\nabstract: Swift 由于类型安全的特性，对于像 JSON 这类弱类型的数据处理一直是一个比较头疼的问题，虽然市面上许多优秀的第三方库在这方面做了不少努力，但是依然存在着很多难以克服的缺陷，所以 Codable 协议的推出，一来打破了这样的僵局，二来也给我们解决类似问题提供了新的思路...\n---\n\n> WWDC 过去有一段时间了，最近终于有时间空闲，可以静下心来仔细研究一下相关内容。对于开发者来说，本届WWDC 最重要的消息还是得属 Swift 4 的推出。\n>\n> Swift 经过三年的发展，终于在 API 层面趋于稳定。从 Swift 3 迁移代码到 Swift 4 终于不用像 2 到 3 那样痛苦了。这对开发者来说实在是个重大利好，应该会吸引一大批对 Swift 仍然处于观望状态的开发者加入。\n>\n> 另外 Swift 4 引入了许多新的特性，像是 fileprivate 关键字的限制范围更加精确了；声明属性终于可以同时限制类型和协议了；新的 KeyPath API 等等，从这些改进我们可以看到，Swift 的生态越来越完善，Swift 本身也越来越强大。\n>\n> 而 Swift 4 带来的新特性中，最让人眼前一亮的，我觉得非 **Codable** 协议莫属，下面就来介绍下我自己对 **Codable** 协议踩坑的经验总结。\n\n## 简单介绍\n\nSwift 由于类型安全的特性，对于像 JSON 这类弱类型的数据处理一直是一个比较头疼的问题，虽然市面上许多优秀的第三方库在这方面做了不少努力，但是依然存在着很多难以克服的缺陷，所以 **Codable** 协议的推出，一来打破了这样的僵局，二来也给我们解决类似问题提供了新的思路。\n\n通过查看定义可以看到，**Codable** 其实是一个组合协议，由 `Decodable` 和 `Encodable` 两个协议组成：\n\n```swift\n/// A type that can convert itself into and out of an external representation.\npublic typealias Codable = Decodable & Encodable\n\n/// A type that can encode itself to an external representation.\npublic protocol Encodable {\n    public func encode(to encoder: Encoder) throws\n}\n\n/// A type that can decode itself from an external representation.\npublic protocol Decodable {\n    public init(from decoder: Decoder) throws\n}\n```\n`Encodable` 和 `Decodable` 分别定义了 `encode(to:)` 和 `init(from:)` 两个协议函数，分别用来实现数据模型的归档和外部数据的解析和实例化。最常用的场景就是接口 JSON 数据解析和模型创建。但是 **Codable** 的能力并不止于此，这个后面会说。\n\n## 解析 JSON 对象\n\n先来看 `Decodable` 对 JSON 数据对象的解析。Swift 为我们做了绝大部分的工作，Swift 中的基本数据类型比如 `String`、`Int`、`Float` 等都已经实现了 **Codable** 协议，因此如果你的数据类型只包含这些基本数据类型的属性，只需要在类型声明中加上 **Codable** 协议就可以了，不需要写任何实际实现的代码，这也是 **Codable** 最大的优势所在。\n\n比如我们有下面这样一个学生信息的 JSON 字符串：\n\n```swift\nlet jsonString =\n\"\"\"\n{\n    \"name\": \"小明\",\n    \"age\": 12,\n    \"weight\": 43.2\n}\n\"\"\"\n```\n\n这时候，只需要定义一个 `Student` 类型，声明实现 `Decodable` 协议即可，Swift 4 已经为我们提供了默认的实现：\n\n```swift\nstruct Student: Decodable {   \n    var name: String\n    var age: Int\n    var weight: Float\n}\n```\n\n然后，只需要一行代码就可以将 ***小明*** 解析出来了：\n\n```swift\nlet xiaoming = try JSONDecoder().decode(Student.self, from: jsonString.data(using: .utf8)!)\n```\n这里需要注意的是, `decode` 函数需要外部数据类型为 `Data` 类型，如果是字符串需要先转换为 `Data` 之后操作，不过像 [**Alamofire**](https://github.com/Alamofire/Alamofire) 之类的网络框架，返回数据原本就是 `Data` 类型的。\n另外 `decode` 函数是标记为 `throws` 的，如果解析失败，会抛出一个异常，为了保证程序的健壮性，需要使用 `do-catch` 对异常情况进行处理:\n\n```swift\ndo {\n    let xiaoming = try JSONDecoder().decode(Student.self, from: data)\n} catch {\n    // 异常处理\n}\n```\n\n### 特殊数据类型\n很多时候光靠基本数据类型并不能完成工作，往往我们需要用到一些特殊的数据类型。Swift 对许多特殊数据类型也提供了默认的 **Codable** 实现，但是有一些限制。\n\n#### 枚举\n\n```json\n{\n    ...\n    \"gender\": \"male\"\n    ...\n}\n```\n性别是一个很常用的信息，我们经常会把它定义成枚举：\n\n```swift\nenum Gender {\n    case male\n    case female\n    case other\n}\n```\n枚举类型也默认实现了 **Codable** 协议，但是如果我们直接声明 `Gender` 枚举支持 **Codable** 协议，编译器会提示没有提供实现：\n\n![](http://upload-images.jianshu.io/upload_images/619631-f5f9ada526a1538a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其实这里有一个限制：枚举类型要默认支持 **Codable** 协议，需要声明为具有原始值的形式，并且原始值的类型需要支持 **Codable** 协议：\n\n```swift\nenum Gender: String, Decodable {\n    case male\n    case female\n    case other\n}\n```\n由于枚举类型原始值隐式赋值特性的存在，如果枚举值的名称和对应的 JSON 中的值一致，不需要显式指定原始值即可完成解析。\n\n#### Bool\n\n我们的数据模型现在新增了一个字段，用来表示某个学生是否是少先队员：\n\n```json\n{\n    ...\n    \"isYoungPioneer\": true\n    ...\n}\n```\n这时候，直接声明对应的属性就可以了:\n\n```swift\nvar isYoungPioneer: Bool\n```\n`Bool` 类型原本没什么好讲的，不过因为踩到了坑，所以还是得说一说：\n目前发现的坑是：`Bool` 类型默认**只支持 `true`/`false` 形式的 `Bool` 值解析**。对于一些使用 `0`/`1` 形式来表示 `Bool` 值的后端框架，只能通过 `Int` 类型解析之后再做转换了，或者可以自定义实现 **Codable** 协议。\n\n#### 日期解析策略\n说了枚举和 `Bool`，另外一个常用的特殊类型就是 `Date` 了，`Date` 类型的特殊性在于它有着各种各样的格式标准和表示方式，从数字到字符串可以说是五花八门，解析 `Date` 类型是任何一个同类型的框架都必须面对的课题。\n\n对此，**Codable** 给出的解决方案是：定义解析策略。`JSONDecoder` 类声明了一个 `DateDecodingStrategy` 类型的属性，用来制定 `Date` 类型的解析策略，同样先看定义：\n\n```swift\n/// The strategy to use for decoding `Date` values.\npublic enum DateDecodingStrategy {\n    \n    /// Defer to `Date` for decoding. This is the default strategy.\n    case deferredToDate\n    \n    /// Decode the `Date` as a UNIX timestamp from a JSON number.\n    case secondsSince1970\n    \n    /// Decode the `Date` as UNIX millisecond timestamp from a JSON number.\n    case millisecondsSince1970\n    \n    /// Decode the `Date` as an ISO-8601-formatted string (in RFC 3339 format).\n    case iso8601\n    \n    /// Decode the `Date` as a string parsed by the given formatter.\n    case formatted(DateFormatter)\n    \n    /// Decode the `Date` as a custom value decoded by the given closure.\n    case custom((Decoder) throws -> Date)\n}\n```\n**Codable** 对几种常用格式标准进行了支持，默认启用的策略是 `deferredToDate`，即从 **UTC 时间2001年1月1日 **开始的秒数，对应 `Date` 类型中 `timeIntervalSinceReferenceDate` 这个属性。比如 `519751611.125429` 这个数字解析后的结果是 `2017-06-21 15:26:51 +0000`。\n\n另外可选的格式标准有 `secondsSince1970`、`millisecondsSince1970`、[`iso8601`](https://zh.wikipedia.org/wiki/ISO_8601) 等，这些都是有详细说明的通用标准，不清楚的自行谷歌吧 :)\n\n同时 **Codable** 提供了两种方自定义 `Date` 格式的策略：\n- `formatted(DateFormatter)`\n  这种策略通过设置 `DateFormatter` 来指定 `Date` 格式\n- `custom((Decoder) throws -> Date)`\n  `custom` 策略接受一个 `(Decoder) -> Date` 的闭包，基本上是把解析任务完全丢给我们自己去实现了，具有较高的自由度\n\n#### 小数解析策略\n小数类型（`Float`／`Double`） 默认也实现了 **Codable** 协议，但是小数类型在 Swift 中有许多特殊值，比如圆周率（`Float.pi`）等。这里要说的是另外两个属性，先看定义：\n\n```swift\n/// Positive infinity.\n///\n/// Infinity compares greater than all finite numbers and equal to other\n/// infinite values.\npublic static var infinity: Double { get }\n\n/// A quiet NaN (\"not a number\").\n///\n/// A NaN compares not equal, not greater than, and not less than every\n/// value, including itself. Passing a NaN to an operation generally results\n/// in NaN.\npublic static var nan: Double { get }\n```\n`infinity` 表示正无穷（负无穷写作：`-infinity`），`nan` 表示没有值，这些特殊值没有办法使用数字进行表示，但是在 Swift 中它们是确确实实的值，可以参与计算、比较等。\n不同的语言、框架对此会有类似的实现，但是表达方式可能不完全相同，因此如果在某些场景下需要解析这样的值，就需要做特殊转换了。\n\n**Codable** 的实现方式比较简单粗暴，`JSONDecoder` 类型有一个属性 `nonConformingFloatDecodingStrategy` ，用来指定不一致的小数转换策略，默认值为 `throw`， 即直接抛出异常，解析失败。另外一个选择就是自己指定 `infinity`、`-infinity`、`nan` 三个特殊值的表示方式：\n\n```swift\nlet decoder = JSONDecoder()\ndecoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: \"infinity\", negativeInfinity: \"-infinity\", nan: \"nan\")\n// 另外一种表示方式\n// decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: \"∞\", negativeInfinity: \"-∞\", nan: \"n/a\")\n```\n目前看来只支持这三个特殊值的转换，不过这种特殊值的使用场景应该非常有限，至少在我自己五六年的开发生涯中还没有遇到过。\n\n### 自定义数据类型\n\n纯粹的基本数据类型依然不能很好地工作，实际项目的数据结构往往是很复杂的，一个数据类型经常会包含另一个数据类型的属性。比如说我们这个例子中，每个学生信息中还包含了所在学校的信息：\n\n```json\n{\n    \"name\": \"小明\",\n    \"age\": 12,\n    \"weight\": 43.2\n    \"school\": {\n      \"name\": \"市第一中学\",\n      \"address\": \"XX市人民中路 66 号\"\n    }\n}\n```\n\n这时候就需要 Student 和 School 两个类型来组合表示：\n\n```swift\nstruct School: Decodable {\n\tvar name: String\n\tvar address: String\n}\nstruct Student: Decodable {   \n    var name: String\n    var age: Int\n    var weight: Float\n    var school: School\n}\n```\n\n由于所有基本类型都实现了 **Codable** 协议，因此 `School` 与 `Student` 一样，只要所有属性都实现了 **Codable** 协议，就不需要手动提供任何实现即可获得默认的 **Codable** 实现。由于 `School` 支持了 **Codable** 协议，保证了 `Student` 依然能够获得默认的 **Codable** 实现，因此，嵌套类型的解析同样不需要额外的代码了。\n\n### 自定义字段\n\n很多时候前后端不一定能完全步调一致，观念相同。所以往往后端给出的数据结构中会有一些比较个性的字段名，当然有时候是我们自己。另外有一些框架（比如我正在用的 Laravel）习惯使用蛇形命名法，而 iOS 的代码规范推荐使用驼峰命名法，为了保证代码风格和平台特色，这时候就必须要自行指定字段名了。\n\n在研究自定义字段之前我们需要深入底层，了解下 **Codable** 默认是怎么实现属性的名称识别及赋值的。通过研究底层的 C++ 源代码可以发现，**Codable** 通过巧（kai）妙（guà）的方式，在编译代码时根据类型的属性，自动生成了一个 `CodingKeys` 的枚举类型定义，这是一个以 `String` 类型作为原始值的枚举类型，对应每一个属性的名称。然后再给每一个声明实现 **Codable** 协议的类型自动生成 `init(from:)` 和 `encode(to:)` 两个函数的具体实现，最终完成了整个协议的实现。\n\n所以我们可以自己实现 `CodingKeys` 的类型定义，并且给属性指定不同的原始值来实现自定义字段的解析。这样编译器会直接采用我们已经实现好的方案而不再重新生成一个默认的。\n\n比如 `Student` 需要增加一个出生日期的属性，后端接口使用蛇形命名，JSON 数据如下：\n\n```json\n{\n    \"name\": \"小明\",\n    \"age\": 12,\n    \"weight\": 43.2\n    \"birth_date\": \"1992-12-25\"\n}\n```\n\n这时候在 Student 类型声明中需要增加 `CodingKeys` 定义，并且将 `birthday` 的原始值设置为 `birth_date`：\n\n```swift\nstruct Student: Codable {\n\t...\n\tvar birthday: Date\n\t\n\tenum CodingKeys: String, CodingKey {\n        case name\n        case age\n        case weight\n        case birthday = \"birth_date\"\n    }\n}\n```\n\n需要注意的是，即使属性名称与 JSON 中的字段名称一致，如果自定义了 `CodingKeys`，这些属性也是无法省略的，否则会得到一个 `Type 'Student' does not conform to protocol 'Codable'` 的编译错误，这一点还是有点坑的。不过在编译时给 `CodingKeys` 补全其他默认的属性的声明在理论上是可行的，期待苹果后续的优化了。\n\n### 可选值\n\n有些字段有可能会是空值。还是用学生的出生日期来举例，假设有些学生的出生日期没有统计到，这时候后台返回数据格式有两种选择，一种是对于没有出生日期的数据，直接不包含 `birth_date` 字段，另一种是指定为空值：`\"birth_date\": null`\n\n对于这两种形式，都只需要将 birthday 属性声明为可选值即可正常解析：\n\n```swift\n...\nvar birthday: Date?\n...\n```\n\n## 解析 JSON 数组\n\n**Codable** 协议同样支持数组类型，只需要满足一个前提：只要数组中的元素实现了 **Codable** 协议，数组将自动获得 **Codable** 协议的实现。\n\n使用 `JSONDecoder` 解析时只需要指定类型为对应的数组即可：\n\n```swift\ndo {\n    let students = try JSONDecoder().decode([Student].self, from: data)\n} catch {\n    // 异常处理\n}\n```\n\n## 归档数据\n\n归档数据使用 `Encodable` 协议，使用方式与 `Decodable` 一致。\n\n### 导出为 JSON\n\n将数据模型转换为 JSON 与解析过程类似，将 JSONDecoder 更换为 JSONEncoder 即可：\n\n```swift\nlet data = try JSONEncoder().encode(xiaomin)\nlet json = String(data: data, encoding: .utf8)\n```\n\nJSONEncoder 有一个 outputFormatting 的属性，可以指定输出 JSON 的排版风格，看定义：\n\n```swift\npublic enum OutputFormatting {\n    \n    /// Produce JSON compacted by removing whitespace. This is the default formatting.\n    case compact\n    \n    /// Produce human-readable JSON with indented output.\n    case prettyPrinted\n}\n```\n\n- compact\n\n  默认的 compact 风格会移除 JSON 数据中的所有格式信息，比如换行、空格和缩紧等，以减小 JSON 数据所占的空间。如果导出的 JSON 数据用户程序间的通讯，对阅读要求不高时，推荐使用这个设置。\n\n- prettyPrinted\n\n  如果输出的 JSON 数据是用来阅读查看的，那么可以选择 prettyPrinted，这时候输出的 JSON 会自动进行格式化，添加换行、空格和缩进，以便于阅读。类似于上面文中使用的 JSON 排版风格。\n\n## 属性列表(PropertyList)\n\n**Codable** 协议并非只支持 JSON 格式的数据，它同样支持属性列表，即 mac 上常用的 `plist` 文件格式。这在我们做一些系统配置之类的工作时会很有用。\n\n属性列表的解析和归档秉承了苹果API一贯的简洁易用的特点，使用方式 JSON 格式一致，并不需要对已经实现的 **Codable** 协议作任何修改，只需要将 `JSONEncoder` 和 `JSONDecoder` 替换成对应的 `PropertyListEncoder` 和 `PropertyListDecoder` 即可。\n\n属性列表本质上是特殊格式标准的 `XML` 文档，所以理论上来说，我们可以参照系统提供的 Decoder/Encoder 自己实现任意格式的数据序列化与反序列化方案。同时苹果也随时可能通过实现新的 Decoder/Encoder 类来扩展其他数据格式的处理能力。这也正是文章开头所说的，**Codable** 的能力并不止于此，它具有很大的可扩展空间。\n\n## 结语\n\n到此 **Codable** 的核心用法基本讲完了。相比目前比较常用的几个框架：\n\n[**ObjectMapper**](https://github.com/Hearst-DD/ObjectMapper) 使用范型机制进行模型解析，但是需要手动对每一个属性写映射关系，比较繁琐。我自己项目中也是用的这个框架，后来自己对其做了些优化，利用反射机制对基本数据类型实现了自动解析，但是自定义类型仍然需要手动写映射，并且必须继承实现了自动解析的 Model 基类，限制较多。\n\n[**SwiftyJSON**](https://github.com/SwiftyJSON/SwiftyJSON) 简单了解过，其本质其实只是将 JSON 解析成了字典类型的数据，而实际使用时依然需要使用下标方式去取值，非常繁琐且容易出错，不易阅读和维护，个人认为这是很糟糕的设计。\n\n[**HandyJSON**](https://github.com/alibaba/HandyJSON) 是阿里推出的框架，思路与 **Codable** 殊途同归，之前也用过一阵，当时因为对枚举和 `Date` 等类型的支持还不够完善，最终还是用回了**ObjectMapper**。不过目前看来完善程度已经很高了，或许可以再次尝试踩下坑。\n\n总体来说，**Codable** 作为语言层面对模型解析的支持方案，有其自身的优势。不过在灵活性上稍有欠缺，对自定义字段的支持也还不够人性化，期待后续的完善。\n\n对于第三方库来说，**Codable** 的推出既是一种挑战，但同时也是一个机遇，相信这些框架的作者们都会从 Codaable 获得许多灵感来优化提升自己的框架，在不久的将来制造一个百家争鸣的局面。","slug":"codable-swift-4","published":1,"date":"2017-07-05T02:46:46.000Z","updated":"2020-01-31T04:10:21.827Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck61tll2k0006ufqbh8nu10tg","content":"<blockquote>\n<p>WWDC 过去有一段时间了，最近终于有时间空闲，可以静下心来仔细研究一下相关内容。对于开发者来说，本届WWDC 最重要的消息还是得属 Swift 4 的推出。</p>\n<p>Swift 经过三年的发展，终于在 API 层面趋于稳定。从 Swift 3 迁移代码到 Swift 4 终于不用像 2 到 3 那样痛苦了。这对开发者来说实在是个重大利好，应该会吸引一大批对 Swift 仍然处于观望状态的开发者加入。</p>\n<p>另外 Swift 4 引入了许多新的特性，像是 fileprivate 关键字的限制范围更加精确了；声明属性终于可以同时限制类型和协议了；新的 KeyPath API 等等，从这些改进我们可以看到，Swift 的生态越来越完善，Swift 本身也越来越强大。</p>\n<p>而 Swift 4 带来的新特性中，最让人眼前一亮的，我觉得非 <strong>Codable</strong> 协议莫属，下面就来介绍下我自己对 <strong>Codable</strong> 协议踩坑的经验总结。</p>\n</blockquote>\n<h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><p>Swift 由于类型安全的特性，对于像 JSON 这类弱类型的数据处理一直是一个比较头疼的问题，虽然市面上许多优秀的第三方库在这方面做了不少努力，但是依然存在着很多难以克服的缺陷，所以 <strong>Codable</strong> 协议的推出，一来打破了这样的僵局，二来也给我们解决类似问题提供了新的思路。</p>\n<p>通过查看定义可以看到，<strong>Codable</strong> 其实是一个组合协议，由 <code>Decodable</code> 和 <code>Encodable</code> 两个协议组成：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// A type that can convert itself into and out of an external representation.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">Codable</span> = <span class=\"type\">Decodable</span> &amp; <span class=\"type\">Encodable</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// A type that can encode itself to an external representation.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">Encodable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">encode</span><span class=\"params\">(to encoder: Encoder)</span></span> <span class=\"keyword\">throws</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// A type that can decode itself from an external representation.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">Decodable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(from decoder: <span class=\"type\">Decoder</span>) <span class=\"keyword\">throws</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Encodable</code> 和 <code>Decodable</code> 分别定义了 <code>encode(to:)</code> 和 <code>init(from:)</code> 两个协议函数，分别用来实现数据模型的归档和外部数据的解析和实例化。最常用的场景就是接口 JSON 数据解析和模型创建。但是 <strong>Codable</strong> 的能力并不止于此，这个后面会说。</p>\n<h2 id=\"解析-JSON-对象\"><a href=\"#解析-JSON-对象\" class=\"headerlink\" title=\"解析 JSON 对象\"></a>解析 JSON 对象</h2><p>先来看 <code>Decodable</code> 对 JSON 数据对象的解析。Swift 为我们做了绝大部分的工作，Swift 中的基本数据类型比如 <code>String</code>、<code>Int</code>、<code>Float</code> 等都已经实现了 <strong>Codable</strong> 协议，因此如果你的数据类型只包含这些基本数据类型的属性，只需要在类型声明中加上 <strong>Codable</strong> 协议就可以了，不需要写任何实际实现的代码，这也是 <strong>Codable</strong> 最大的优势所在。</p>\n<p>比如我们有下面这样一个学生信息的 JSON 字符串：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> jsonString =</span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">    \"name\": \"小明\",</span></span><br><span class=\"line\"><span class=\"string\">    \"age\": 12,</span></span><br><span class=\"line\"><span class=\"string\">    \"weight\": 43.2</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br></pre></td></tr></table></figure>\n\n<p>这时候，只需要定义一个 <code>Student</code> 类型，声明实现 <code>Decodable</code> 协议即可，Swift 4 已经为我们提供了默认的实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span>: <span class=\"title\">Decodable</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> weight: <span class=\"type\">Float</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，只需要一行代码就可以将 <strong><em>小明</em></strong> 解析出来了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> xiaoming = <span class=\"keyword\">try</span> <span class=\"type\">JSONDecoder</span>().decode(<span class=\"type\">Student</span>.<span class=\"keyword\">self</span>, from: jsonString.data(using: .utf8)!)</span><br></pre></td></tr></table></figure>\n<p>这里需要注意的是, <code>decode</code> 函数需要外部数据类型为 <code>Data</code> 类型，如果是字符串需要先转换为 <code>Data</code> 之后操作，不过像 <a href=\"https://github.com/Alamofire/Alamofire\" target=\"_blank\" rel=\"noopener\"><strong>Alamofire</strong></a> 之类的网络框架，返回数据原本就是 <code>Data</code> 类型的。<br>另外 <code>decode</code> 函数是标记为 <code>throws</code> 的，如果解析失败，会抛出一个异常，为了保证程序的健壮性，需要使用 <code>do-catch</code> 对异常情况进行处理:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> xiaoming = <span class=\"keyword\">try</span> <span class=\"type\">JSONDecoder</span>().decode(<span class=\"type\">Student</span>.<span class=\"keyword\">self</span>, from: data)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 异常处理</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特殊数据类型\"><a href=\"#特殊数据类型\" class=\"headerlink\" title=\"特殊数据类型\"></a>特殊数据类型</h3><p>很多时候光靠基本数据类型并不能完成工作，往往我们需要用到一些特殊的数据类型。Swift 对许多特殊数据类型也提供了默认的 <strong>Codable</strong> 实现，但是有一些限制。</p>\n<h4 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h4><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    \"gender\": \"male\"</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>性别是一个很常用的信息，我们经常会把它定义成枚举：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Gender</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> male</span><br><span class=\"line\">    <span class=\"keyword\">case</span> female</span><br><span class=\"line\">    <span class=\"keyword\">case</span> other</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>枚举类型也默认实现了 <strong>Codable</strong> 协议，但是如果我们直接声明 <code>Gender</code> 枚举支持 <strong>Codable</strong> 协议，编译器会提示没有提供实现：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/619631-f5f9ada526a1538a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>其实这里有一个限制：枚举类型要默认支持 <strong>Codable</strong> 协议，需要声明为具有原始值的形式，并且原始值的类型需要支持 <strong>Codable</strong> 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Gender</span>: <span class=\"title\">String</span>, <span class=\"title\">Decodable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> male</span><br><span class=\"line\">    <span class=\"keyword\">case</span> female</span><br><span class=\"line\">    <span class=\"keyword\">case</span> other</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于枚举类型原始值隐式赋值特性的存在，如果枚举值的名称和对应的 JSON 中的值一致，不需要显式指定原始值即可完成解析。</p>\n<h4 id=\"Bool\"><a href=\"#Bool\" class=\"headerlink\" title=\"Bool\"></a>Bool</h4><p>我们的数据模型现在新增了一个字段，用来表示某个学生是否是少先队员：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    \"isYoungPioneer\": true</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时候，直接声明对应的属性就可以了:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> isYoungPioneer: <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n<p><code>Bool</code> 类型原本没什么好讲的，不过因为踩到了坑，所以还是得说一说：<br>目前发现的坑是：<code>Bool</code> 类型默认<strong>只支持 <code>true</code>/<code>false</code> 形式的 <code>Bool</code> 值解析</strong>。对于一些使用 <code>0</code>/<code>1</code> 形式来表示 <code>Bool</code> 值的后端框架，只能通过 <code>Int</code> 类型解析之后再做转换了，或者可以自定义实现 <strong>Codable</strong> 协议。</p>\n<h4 id=\"日期解析策略\"><a href=\"#日期解析策略\" class=\"headerlink\" title=\"日期解析策略\"></a>日期解析策略</h4><p>说了枚举和 <code>Bool</code>，另外一个常用的特殊类型就是 <code>Date</code> 了，<code>Date</code> 类型的特殊性在于它有着各种各样的格式标准和表示方式，从数字到字符串可以说是五花八门，解析 <code>Date</code> 类型是任何一个同类型的框架都必须面对的课题。</p>\n<p>对此，<strong>Codable</strong> 给出的解决方案是：定义解析策略。<code>JSONDecoder</code> 类声明了一个 <code>DateDecodingStrategy</code> 类型的属性，用来制定 <code>Date</code> 类型的解析策略，同样先看定义：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// The strategy to use for decoding `Date` values.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">DateDecodingStrategy</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// Defer to `Date` for decoding. This is the default strategy.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> deferredToDate</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// Decode the `Date` as a UNIX timestamp from a JSON number.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> secondsSince1970</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// Decode the `Date` as UNIX millisecond timestamp from a JSON number.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> millisecondsSince1970</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// Decode the `Date` as an ISO-8601-formatted string (in RFC 3339 format).</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> iso8601</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// Decode the `Date` as a string parsed by the given formatter.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> formatted(<span class=\"type\">DateFormatter</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// Decode the `Date` as a custom value decoded by the given closure.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> custom((<span class=\"type\">Decoder</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Date</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Codable</strong> 对几种常用格式标准进行了支持，默认启用的策略是 <code>deferredToDate</code>，即从 *<em>UTC 时间2001年1月1日 *</em>开始的秒数，对应 <code>Date</code> 类型中 <code>timeIntervalSinceReferenceDate</code> 这个属性。比如 <code>519751611.125429</code> 这个数字解析后的结果是 <code>2017-06-21 15:26:51 +0000</code>。</p>\n<p>另外可选的格式标准有 <code>secondsSince1970</code>、<code>millisecondsSince1970</code>、<a href=\"https://zh.wikipedia.org/wiki/ISO_8601\" target=\"_blank\" rel=\"noopener\"><code>iso8601</code></a> 等，这些都是有详细说明的通用标准，不清楚的自行谷歌吧 :)</p>\n<p>同时 <strong>Codable</strong> 提供了两种方自定义 <code>Date</code> 格式的策略：</p>\n<ul>\n<li><code>formatted(DateFormatter)</code><br>这种策略通过设置 <code>DateFormatter</code> 来指定 <code>Date</code> 格式</li>\n<li><code>custom((Decoder) throws -&gt; Date)</code><br><code>custom</code> 策略接受一个 <code>(Decoder) -&gt; Date</code> 的闭包，基本上是把解析任务完全丢给我们自己去实现了，具有较高的自由度</li>\n</ul>\n<h4 id=\"小数解析策略\"><a href=\"#小数解析策略\" class=\"headerlink\" title=\"小数解析策略\"></a>小数解析策略</h4><p>小数类型（<code>Float</code>／<code>Double</code>） 默认也实现了 <strong>Codable</strong> 协议，但是小数类型在 Swift 中有许多特殊值，比如圆周率（<code>Float.pi</code>）等。这里要说的是另外两个属性，先看定义：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Positive infinity.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// Infinity compares greater than all finite numbers and equal to other</span></span><br><span class=\"line\"><span class=\"comment\">/// infinite values.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> infinity: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// A quiet NaN (\"not a number\").</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// A NaN compares not equal, not greater than, and not less than every</span></span><br><span class=\"line\"><span class=\"comment\">/// value, including itself. Passing a NaN to an operation generally results</span></span><br><span class=\"line\"><span class=\"comment\">/// in NaN.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> nan: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br></pre></td></tr></table></figure>\n<p><code>infinity</code> 表示正无穷（负无穷写作：<code>-infinity</code>），<code>nan</code> 表示没有值，这些特殊值没有办法使用数字进行表示，但是在 Swift 中它们是确确实实的值，可以参与计算、比较等。<br>不同的语言、框架对此会有类似的实现，但是表达方式可能不完全相同，因此如果在某些场景下需要解析这样的值，就需要做特殊转换了。</p>\n<p><strong>Codable</strong> 的实现方式比较简单粗暴，<code>JSONDecoder</code> 类型有一个属性 <code>nonConformingFloatDecodingStrategy</code> ，用来指定不一致的小数转换策略，默认值为 <code>throw</code>， 即直接抛出异常，解析失败。另外一个选择就是自己指定 <code>infinity</code>、<code>-infinity</code>、<code>nan</code> 三个特殊值的表示方式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> decoder = <span class=\"type\">JSONDecoder</span>()</span><br><span class=\"line\">decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: <span class=\"string\">\"infinity\"</span>, negativeInfinity: <span class=\"string\">\"-infinity\"</span>, nan: <span class=\"string\">\"nan\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// 另外一种表示方式</span></span><br><span class=\"line\"><span class=\"comment\">// decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: \"∞\", negativeInfinity: \"-∞\", nan: \"n/a\")</span></span><br></pre></td></tr></table></figure>\n<p>目前看来只支持这三个特殊值的转换，不过这种特殊值的使用场景应该非常有限，至少在我自己五六年的开发生涯中还没有遇到过。</p>\n<h3 id=\"自定义数据类型\"><a href=\"#自定义数据类型\" class=\"headerlink\" title=\"自定义数据类型\"></a>自定义数据类型</h3><p>纯粹的基本数据类型依然不能很好地工作，实际项目的数据结构往往是很复杂的，一个数据类型经常会包含另一个数据类型的属性。比如说我们这个例子中，每个学生信息中还包含了所在学校的信息：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"小明\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"age\"</span>: <span class=\"number\">12</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"weight\"</span>: <span class=\"number\">43.2</span></span><br><span class=\"line\">    <span class=\"string\">\"school\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"市第一中学\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"address\"</span>: <span class=\"string\">\"XX市人民中路 66 号\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时候就需要 Student 和 School 两个类型来组合表示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">School</span>: <span class=\"title\">Decodable</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> address: <span class=\"type\">String</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span>: <span class=\"title\">Decodable</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> weight: <span class=\"type\">Float</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> school: <span class=\"type\">School</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于所有基本类型都实现了 <strong>Codable</strong> 协议，因此 <code>School</code> 与 <code>Student</code> 一样，只要所有属性都实现了 <strong>Codable</strong> 协议，就不需要手动提供任何实现即可获得默认的 <strong>Codable</strong> 实现。由于 <code>School</code> 支持了 <strong>Codable</strong> 协议，保证了 <code>Student</code> 依然能够获得默认的 <strong>Codable</strong> 实现，因此，嵌套类型的解析同样不需要额外的代码了。</p>\n<h3 id=\"自定义字段\"><a href=\"#自定义字段\" class=\"headerlink\" title=\"自定义字段\"></a>自定义字段</h3><p>很多时候前后端不一定能完全步调一致，观念相同。所以往往后端给出的数据结构中会有一些比较个性的字段名，当然有时候是我们自己。另外有一些框架（比如我正在用的 Laravel）习惯使用蛇形命名法，而 iOS 的代码规范推荐使用驼峰命名法，为了保证代码风格和平台特色，这时候就必须要自行指定字段名了。</p>\n<p>在研究自定义字段之前我们需要深入底层，了解下 <strong>Codable</strong> 默认是怎么实现属性的名称识别及赋值的。通过研究底层的 C++ 源代码可以发现，<strong>Codable</strong> 通过巧（kai）妙（guà）的方式，在编译代码时根据类型的属性，自动生成了一个 <code>CodingKeys</code> 的枚举类型定义，这是一个以 <code>String</code> 类型作为原始值的枚举类型，对应每一个属性的名称。然后再给每一个声明实现 <strong>Codable</strong> 协议的类型自动生成 <code>init(from:)</code> 和 <code>encode(to:)</code> 两个函数的具体实现，最终完成了整个协议的实现。</p>\n<p>所以我们可以自己实现 <code>CodingKeys</code> 的类型定义，并且给属性指定不同的原始值来实现自定义字段的解析。这样编译器会直接采用我们已经实现好的方案而不再重新生成一个默认的。</p>\n<p>比如 <code>Student</code> 需要增加一个出生日期的属性，后端接口使用蛇形命名，JSON 数据如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"小明\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"age\"</span>: <span class=\"number\">12</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"weight\"</span>: <span class=\"number\">43.2</span></span><br><span class=\"line\">    <span class=\"string\">\"birth_date\"</span>: <span class=\"string\">\"1992-12-25\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时候在 Student 类型声明中需要增加 <code>CodingKeys</code> 定义，并且将 <code>birthday</code> 的原始值设置为 <code>birth_date</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span>: <span class=\"title\">Codable</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> birthday: <span class=\"type\">Date</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CodingKeys</span>: <span class=\"title\">String</span>, <span class=\"title\">CodingKey</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> name</span><br><span class=\"line\">        <span class=\"keyword\">case</span> age</span><br><span class=\"line\">        <span class=\"keyword\">case</span> weight</span><br><span class=\"line\">        <span class=\"keyword\">case</span> birthday = <span class=\"string\">\"birth_date\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，即使属性名称与 JSON 中的字段名称一致，如果自定义了 <code>CodingKeys</code>，这些属性也是无法省略的，否则会得到一个 <code>Type &#39;Student&#39; does not conform to protocol &#39;Codable&#39;</code> 的编译错误，这一点还是有点坑的。不过在编译时给 <code>CodingKeys</code> 补全其他默认的属性的声明在理论上是可行的，期待苹果后续的优化了。</p>\n<h3 id=\"可选值\"><a href=\"#可选值\" class=\"headerlink\" title=\"可选值\"></a>可选值</h3><p>有些字段有可能会是空值。还是用学生的出生日期来举例，假设有些学生的出生日期没有统计到，这时候后台返回数据格式有两种选择，一种是对于没有出生日期的数据，直接不包含 <code>birth_date</code> 字段，另一种是指定为空值：<code>&quot;birth_date&quot;: null</code></p>\n<p>对于这两种形式，都只需要将 birthday 属性声明为可选值即可正常解析：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">var</span> birthday: <span class=\"type\">Date?</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解析-JSON-数组\"><a href=\"#解析-JSON-数组\" class=\"headerlink\" title=\"解析 JSON 数组\"></a>解析 JSON 数组</h2><p><strong>Codable</strong> 协议同样支持数组类型，只需要满足一个前提：只要数组中的元素实现了 <strong>Codable</strong> 协议，数组将自动获得 <strong>Codable</strong> 协议的实现。</p>\n<p>使用 <code>JSONDecoder</code> 解析时只需要指定类型为对应的数组即可：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> students = <span class=\"keyword\">try</span> <span class=\"type\">JSONDecoder</span>().decode([<span class=\"type\">Student</span>].<span class=\"keyword\">self</span>, from: data)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 异常处理</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"归档数据\"><a href=\"#归档数据\" class=\"headerlink\" title=\"归档数据\"></a>归档数据</h2><p>归档数据使用 <code>Encodable</code> 协议，使用方式与 <code>Decodable</code> 一致。</p>\n<h3 id=\"导出为-JSON\"><a href=\"#导出为-JSON\" class=\"headerlink\" title=\"导出为 JSON\"></a>导出为 JSON</h3><p>将数据模型转换为 JSON 与解析过程类似，将 JSONDecoder 更换为 JSONEncoder 即可：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> data = <span class=\"keyword\">try</span> <span class=\"type\">JSONEncoder</span>().encode(xiaomin)</span><br><span class=\"line\"><span class=\"keyword\">let</span> json = <span class=\"type\">String</span>(data: data, encoding: .utf8)</span><br></pre></td></tr></table></figure>\n\n<p>JSONEncoder 有一个 outputFormatting 的属性，可以指定输出 JSON 的排版风格，看定义：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">OutputFormatting</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// Produce JSON compacted by removing whitespace. This is the default formatting.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> compact</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// Produce human-readable JSON with indented output.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> prettyPrinted</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>compact</p>\n<p>默认的 compact 风格会移除 JSON 数据中的所有格式信息，比如换行、空格和缩紧等，以减小 JSON 数据所占的空间。如果导出的 JSON 数据用户程序间的通讯，对阅读要求不高时，推荐使用这个设置。</p>\n</li>\n<li><p>prettyPrinted</p>\n<p>如果输出的 JSON 数据是用来阅读查看的，那么可以选择 prettyPrinted，这时候输出的 JSON 会自动进行格式化，添加换行、空格和缩进，以便于阅读。类似于上面文中使用的 JSON 排版风格。</p>\n</li>\n</ul>\n<h2 id=\"属性列表-PropertyList\"><a href=\"#属性列表-PropertyList\" class=\"headerlink\" title=\"属性列表(PropertyList)\"></a>属性列表(PropertyList)</h2><p><strong>Codable</strong> 协议并非只支持 JSON 格式的数据，它同样支持属性列表，即 mac 上常用的 <code>plist</code> 文件格式。这在我们做一些系统配置之类的工作时会很有用。</p>\n<p>属性列表的解析和归档秉承了苹果API一贯的简洁易用的特点，使用方式 JSON 格式一致，并不需要对已经实现的 <strong>Codable</strong> 协议作任何修改，只需要将 <code>JSONEncoder</code> 和 <code>JSONDecoder</code> 替换成对应的 <code>PropertyListEncoder</code> 和 <code>PropertyListDecoder</code> 即可。</p>\n<p>属性列表本质上是特殊格式标准的 <code>XML</code> 文档，所以理论上来说，我们可以参照系统提供的 Decoder/Encoder 自己实现任意格式的数据序列化与反序列化方案。同时苹果也随时可能通过实现新的 Decoder/Encoder 类来扩展其他数据格式的处理能力。这也正是文章开头所说的，<strong>Codable</strong> 的能力并不止于此，它具有很大的可扩展空间。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>到此 <strong>Codable</strong> 的核心用法基本讲完了。相比目前比较常用的几个框架：</p>\n<p><a href=\"https://github.com/Hearst-DD/ObjectMapper\" target=\"_blank\" rel=\"noopener\"><strong>ObjectMapper</strong></a> 使用范型机制进行模型解析，但是需要手动对每一个属性写映射关系，比较繁琐。我自己项目中也是用的这个框架，后来自己对其做了些优化，利用反射机制对基本数据类型实现了自动解析，但是自定义类型仍然需要手动写映射，并且必须继承实现了自动解析的 Model 基类，限制较多。</p>\n<p><a href=\"https://github.com/SwiftyJSON/SwiftyJSON\" target=\"_blank\" rel=\"noopener\"><strong>SwiftyJSON</strong></a> 简单了解过，其本质其实只是将 JSON 解析成了字典类型的数据，而实际使用时依然需要使用下标方式去取值，非常繁琐且容易出错，不易阅读和维护，个人认为这是很糟糕的设计。</p>\n<p><a href=\"https://github.com/alibaba/HandyJSON\" target=\"_blank\" rel=\"noopener\"><strong>HandyJSON</strong></a> 是阿里推出的框架，思路与 <strong>Codable</strong> 殊途同归，之前也用过一阵，当时因为对枚举和 <code>Date</code> 等类型的支持还不够完善，最终还是用回了<strong>ObjectMapper</strong>。不过目前看来完善程度已经很高了，或许可以再次尝试踩下坑。</p>\n<p>总体来说，<strong>Codable</strong> 作为语言层面对模型解析的支持方案，有其自身的优势。不过在灵活性上稍有欠缺，对自定义字段的支持也还不够人性化，期待后续的完善。</p>\n<p>对于第三方库来说，<strong>Codable</strong> 的推出既是一种挑战，但同时也是一个机遇，相信这些框架的作者们都会从 Codaable 获得许多灵感来优化提升自己的框架，在不久的将来制造一个百家争鸣的局面。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>WWDC 过去有一段时间了，最近终于有时间空闲，可以静下心来仔细研究一下相关内容。对于开发者来说，本届WWDC 最重要的消息还是得属 Swift 4 的推出。</p>\n<p>Swift 经过三年的发展，终于在 API 层面趋于稳定。从 Swift 3 迁移代码到 Swift 4 终于不用像 2 到 3 那样痛苦了。这对开发者来说实在是个重大利好，应该会吸引一大批对 Swift 仍然处于观望状态的开发者加入。</p>\n<p>另外 Swift 4 引入了许多新的特性，像是 fileprivate 关键字的限制范围更加精确了；声明属性终于可以同时限制类型和协议了；新的 KeyPath API 等等，从这些改进我们可以看到，Swift 的生态越来越完善，Swift 本身也越来越强大。</p>\n<p>而 Swift 4 带来的新特性中，最让人眼前一亮的，我觉得非 <strong>Codable</strong> 协议莫属，下面就来介绍下我自己对 <strong>Codable</strong> 协议踩坑的经验总结。</p>\n</blockquote>\n<h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><p>Swift 由于类型安全的特性，对于像 JSON 这类弱类型的数据处理一直是一个比较头疼的问题，虽然市面上许多优秀的第三方库在这方面做了不少努力，但是依然存在着很多难以克服的缺陷，所以 <strong>Codable</strong> 协议的推出，一来打破了这样的僵局，二来也给我们解决类似问题提供了新的思路。</p>\n<p>通过查看定义可以看到，<strong>Codable</strong> 其实是一个组合协议，由 <code>Decodable</code> 和 <code>Encodable</code> 两个协议组成：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// A type that can convert itself into and out of an external representation.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">Codable</span> = <span class=\"type\">Decodable</span> &amp; <span class=\"type\">Encodable</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// A type that can encode itself to an external representation.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">Encodable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">encode</span><span class=\"params\">(to encoder: Encoder)</span></span> <span class=\"keyword\">throws</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// A type that can decode itself from an external representation.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">Decodable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(from decoder: <span class=\"type\">Decoder</span>) <span class=\"keyword\">throws</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Encodable</code> 和 <code>Decodable</code> 分别定义了 <code>encode(to:)</code> 和 <code>init(from:)</code> 两个协议函数，分别用来实现数据模型的归档和外部数据的解析和实例化。最常用的场景就是接口 JSON 数据解析和模型创建。但是 <strong>Codable</strong> 的能力并不止于此，这个后面会说。</p>\n<h2 id=\"解析-JSON-对象\"><a href=\"#解析-JSON-对象\" class=\"headerlink\" title=\"解析 JSON 对象\"></a>解析 JSON 对象</h2><p>先来看 <code>Decodable</code> 对 JSON 数据对象的解析。Swift 为我们做了绝大部分的工作，Swift 中的基本数据类型比如 <code>String</code>、<code>Int</code>、<code>Float</code> 等都已经实现了 <strong>Codable</strong> 协议，因此如果你的数据类型只包含这些基本数据类型的属性，只需要在类型声明中加上 <strong>Codable</strong> 协议就可以了，不需要写任何实际实现的代码，这也是 <strong>Codable</strong> 最大的优势所在。</p>\n<p>比如我们有下面这样一个学生信息的 JSON 字符串：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> jsonString =</span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">    \"name\": \"小明\",</span></span><br><span class=\"line\"><span class=\"string\">    \"age\": 12,</span></span><br><span class=\"line\"><span class=\"string\">    \"weight\": 43.2</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br></pre></td></tr></table></figure>\n\n<p>这时候，只需要定义一个 <code>Student</code> 类型，声明实现 <code>Decodable</code> 协议即可，Swift 4 已经为我们提供了默认的实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span>: <span class=\"title\">Decodable</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> weight: <span class=\"type\">Float</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，只需要一行代码就可以将 <strong><em>小明</em></strong> 解析出来了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> xiaoming = <span class=\"keyword\">try</span> <span class=\"type\">JSONDecoder</span>().decode(<span class=\"type\">Student</span>.<span class=\"keyword\">self</span>, from: jsonString.data(using: .utf8)!)</span><br></pre></td></tr></table></figure>\n<p>这里需要注意的是, <code>decode</code> 函数需要外部数据类型为 <code>Data</code> 类型，如果是字符串需要先转换为 <code>Data</code> 之后操作，不过像 <a href=\"https://github.com/Alamofire/Alamofire\" target=\"_blank\" rel=\"noopener\"><strong>Alamofire</strong></a> 之类的网络框架，返回数据原本就是 <code>Data</code> 类型的。<br>另外 <code>decode</code> 函数是标记为 <code>throws</code> 的，如果解析失败，会抛出一个异常，为了保证程序的健壮性，需要使用 <code>do-catch</code> 对异常情况进行处理:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> xiaoming = <span class=\"keyword\">try</span> <span class=\"type\">JSONDecoder</span>().decode(<span class=\"type\">Student</span>.<span class=\"keyword\">self</span>, from: data)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 异常处理</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特殊数据类型\"><a href=\"#特殊数据类型\" class=\"headerlink\" title=\"特殊数据类型\"></a>特殊数据类型</h3><p>很多时候光靠基本数据类型并不能完成工作，往往我们需要用到一些特殊的数据类型。Swift 对许多特殊数据类型也提供了默认的 <strong>Codable</strong> 实现，但是有一些限制。</p>\n<h4 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h4><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    \"gender\": \"male\"</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>性别是一个很常用的信息，我们经常会把它定义成枚举：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Gender</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> male</span><br><span class=\"line\">    <span class=\"keyword\">case</span> female</span><br><span class=\"line\">    <span class=\"keyword\">case</span> other</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>枚举类型也默认实现了 <strong>Codable</strong> 协议，但是如果我们直接声明 <code>Gender</code> 枚举支持 <strong>Codable</strong> 协议，编译器会提示没有提供实现：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/619631-f5f9ada526a1538a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>其实这里有一个限制：枚举类型要默认支持 <strong>Codable</strong> 协议，需要声明为具有原始值的形式，并且原始值的类型需要支持 <strong>Codable</strong> 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Gender</span>: <span class=\"title\">String</span>, <span class=\"title\">Decodable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> male</span><br><span class=\"line\">    <span class=\"keyword\">case</span> female</span><br><span class=\"line\">    <span class=\"keyword\">case</span> other</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于枚举类型原始值隐式赋值特性的存在，如果枚举值的名称和对应的 JSON 中的值一致，不需要显式指定原始值即可完成解析。</p>\n<h4 id=\"Bool\"><a href=\"#Bool\" class=\"headerlink\" title=\"Bool\"></a>Bool</h4><p>我们的数据模型现在新增了一个字段，用来表示某个学生是否是少先队员：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    \"isYoungPioneer\": true</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时候，直接声明对应的属性就可以了:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> isYoungPioneer: <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n<p><code>Bool</code> 类型原本没什么好讲的，不过因为踩到了坑，所以还是得说一说：<br>目前发现的坑是：<code>Bool</code> 类型默认<strong>只支持 <code>true</code>/<code>false</code> 形式的 <code>Bool</code> 值解析</strong>。对于一些使用 <code>0</code>/<code>1</code> 形式来表示 <code>Bool</code> 值的后端框架，只能通过 <code>Int</code> 类型解析之后再做转换了，或者可以自定义实现 <strong>Codable</strong> 协议。</p>\n<h4 id=\"日期解析策略\"><a href=\"#日期解析策略\" class=\"headerlink\" title=\"日期解析策略\"></a>日期解析策略</h4><p>说了枚举和 <code>Bool</code>，另外一个常用的特殊类型就是 <code>Date</code> 了，<code>Date</code> 类型的特殊性在于它有着各种各样的格式标准和表示方式，从数字到字符串可以说是五花八门，解析 <code>Date</code> 类型是任何一个同类型的框架都必须面对的课题。</p>\n<p>对此，<strong>Codable</strong> 给出的解决方案是：定义解析策略。<code>JSONDecoder</code> 类声明了一个 <code>DateDecodingStrategy</code> 类型的属性，用来制定 <code>Date</code> 类型的解析策略，同样先看定义：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// The strategy to use for decoding `Date` values.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">DateDecodingStrategy</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// Defer to `Date` for decoding. This is the default strategy.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> deferredToDate</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// Decode the `Date` as a UNIX timestamp from a JSON number.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> secondsSince1970</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// Decode the `Date` as UNIX millisecond timestamp from a JSON number.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> millisecondsSince1970</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// Decode the `Date` as an ISO-8601-formatted string (in RFC 3339 format).</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> iso8601</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// Decode the `Date` as a string parsed by the given formatter.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> formatted(<span class=\"type\">DateFormatter</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// Decode the `Date` as a custom value decoded by the given closure.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> custom((<span class=\"type\">Decoder</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Date</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Codable</strong> 对几种常用格式标准进行了支持，默认启用的策略是 <code>deferredToDate</code>，即从 *<em>UTC 时间2001年1月1日 *</em>开始的秒数，对应 <code>Date</code> 类型中 <code>timeIntervalSinceReferenceDate</code> 这个属性。比如 <code>519751611.125429</code> 这个数字解析后的结果是 <code>2017-06-21 15:26:51 +0000</code>。</p>\n<p>另外可选的格式标准有 <code>secondsSince1970</code>、<code>millisecondsSince1970</code>、<a href=\"https://zh.wikipedia.org/wiki/ISO_8601\" target=\"_blank\" rel=\"noopener\"><code>iso8601</code></a> 等，这些都是有详细说明的通用标准，不清楚的自行谷歌吧 :)</p>\n<p>同时 <strong>Codable</strong> 提供了两种方自定义 <code>Date</code> 格式的策略：</p>\n<ul>\n<li><code>formatted(DateFormatter)</code><br>这种策略通过设置 <code>DateFormatter</code> 来指定 <code>Date</code> 格式</li>\n<li><code>custom((Decoder) throws -&gt; Date)</code><br><code>custom</code> 策略接受一个 <code>(Decoder) -&gt; Date</code> 的闭包，基本上是把解析任务完全丢给我们自己去实现了，具有较高的自由度</li>\n</ul>\n<h4 id=\"小数解析策略\"><a href=\"#小数解析策略\" class=\"headerlink\" title=\"小数解析策略\"></a>小数解析策略</h4><p>小数类型（<code>Float</code>／<code>Double</code>） 默认也实现了 <strong>Codable</strong> 协议，但是小数类型在 Swift 中有许多特殊值，比如圆周率（<code>Float.pi</code>）等。这里要说的是另外两个属性，先看定义：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Positive infinity.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// Infinity compares greater than all finite numbers and equal to other</span></span><br><span class=\"line\"><span class=\"comment\">/// infinite values.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> infinity: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// A quiet NaN (\"not a number\").</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// A NaN compares not equal, not greater than, and not less than every</span></span><br><span class=\"line\"><span class=\"comment\">/// value, including itself. Passing a NaN to an operation generally results</span></span><br><span class=\"line\"><span class=\"comment\">/// in NaN.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> nan: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br></pre></td></tr></table></figure>\n<p><code>infinity</code> 表示正无穷（负无穷写作：<code>-infinity</code>），<code>nan</code> 表示没有值，这些特殊值没有办法使用数字进行表示，但是在 Swift 中它们是确确实实的值，可以参与计算、比较等。<br>不同的语言、框架对此会有类似的实现，但是表达方式可能不完全相同，因此如果在某些场景下需要解析这样的值，就需要做特殊转换了。</p>\n<p><strong>Codable</strong> 的实现方式比较简单粗暴，<code>JSONDecoder</code> 类型有一个属性 <code>nonConformingFloatDecodingStrategy</code> ，用来指定不一致的小数转换策略，默认值为 <code>throw</code>， 即直接抛出异常，解析失败。另外一个选择就是自己指定 <code>infinity</code>、<code>-infinity</code>、<code>nan</code> 三个特殊值的表示方式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> decoder = <span class=\"type\">JSONDecoder</span>()</span><br><span class=\"line\">decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: <span class=\"string\">\"infinity\"</span>, negativeInfinity: <span class=\"string\">\"-infinity\"</span>, nan: <span class=\"string\">\"nan\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// 另外一种表示方式</span></span><br><span class=\"line\"><span class=\"comment\">// decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: \"∞\", negativeInfinity: \"-∞\", nan: \"n/a\")</span></span><br></pre></td></tr></table></figure>\n<p>目前看来只支持这三个特殊值的转换，不过这种特殊值的使用场景应该非常有限，至少在我自己五六年的开发生涯中还没有遇到过。</p>\n<h3 id=\"自定义数据类型\"><a href=\"#自定义数据类型\" class=\"headerlink\" title=\"自定义数据类型\"></a>自定义数据类型</h3><p>纯粹的基本数据类型依然不能很好地工作，实际项目的数据结构往往是很复杂的，一个数据类型经常会包含另一个数据类型的属性。比如说我们这个例子中，每个学生信息中还包含了所在学校的信息：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"小明\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"age\"</span>: <span class=\"number\">12</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"weight\"</span>: <span class=\"number\">43.2</span></span><br><span class=\"line\">    <span class=\"string\">\"school\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"市第一中学\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"address\"</span>: <span class=\"string\">\"XX市人民中路 66 号\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时候就需要 Student 和 School 两个类型来组合表示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">School</span>: <span class=\"title\">Decodable</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> address: <span class=\"type\">String</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span>: <span class=\"title\">Decodable</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> weight: <span class=\"type\">Float</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> school: <span class=\"type\">School</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于所有基本类型都实现了 <strong>Codable</strong> 协议，因此 <code>School</code> 与 <code>Student</code> 一样，只要所有属性都实现了 <strong>Codable</strong> 协议，就不需要手动提供任何实现即可获得默认的 <strong>Codable</strong> 实现。由于 <code>School</code> 支持了 <strong>Codable</strong> 协议，保证了 <code>Student</code> 依然能够获得默认的 <strong>Codable</strong> 实现，因此，嵌套类型的解析同样不需要额外的代码了。</p>\n<h3 id=\"自定义字段\"><a href=\"#自定义字段\" class=\"headerlink\" title=\"自定义字段\"></a>自定义字段</h3><p>很多时候前后端不一定能完全步调一致，观念相同。所以往往后端给出的数据结构中会有一些比较个性的字段名，当然有时候是我们自己。另外有一些框架（比如我正在用的 Laravel）习惯使用蛇形命名法，而 iOS 的代码规范推荐使用驼峰命名法，为了保证代码风格和平台特色，这时候就必须要自行指定字段名了。</p>\n<p>在研究自定义字段之前我们需要深入底层，了解下 <strong>Codable</strong> 默认是怎么实现属性的名称识别及赋值的。通过研究底层的 C++ 源代码可以发现，<strong>Codable</strong> 通过巧（kai）妙（guà）的方式，在编译代码时根据类型的属性，自动生成了一个 <code>CodingKeys</code> 的枚举类型定义，这是一个以 <code>String</code> 类型作为原始值的枚举类型，对应每一个属性的名称。然后再给每一个声明实现 <strong>Codable</strong> 协议的类型自动生成 <code>init(from:)</code> 和 <code>encode(to:)</code> 两个函数的具体实现，最终完成了整个协议的实现。</p>\n<p>所以我们可以自己实现 <code>CodingKeys</code> 的类型定义，并且给属性指定不同的原始值来实现自定义字段的解析。这样编译器会直接采用我们已经实现好的方案而不再重新生成一个默认的。</p>\n<p>比如 <code>Student</code> 需要增加一个出生日期的属性，后端接口使用蛇形命名，JSON 数据如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"小明\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"age\"</span>: <span class=\"number\">12</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"weight\"</span>: <span class=\"number\">43.2</span></span><br><span class=\"line\">    <span class=\"string\">\"birth_date\"</span>: <span class=\"string\">\"1992-12-25\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时候在 Student 类型声明中需要增加 <code>CodingKeys</code> 定义，并且将 <code>birthday</code> 的原始值设置为 <code>birth_date</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span>: <span class=\"title\">Codable</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> birthday: <span class=\"type\">Date</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CodingKeys</span>: <span class=\"title\">String</span>, <span class=\"title\">CodingKey</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> name</span><br><span class=\"line\">        <span class=\"keyword\">case</span> age</span><br><span class=\"line\">        <span class=\"keyword\">case</span> weight</span><br><span class=\"line\">        <span class=\"keyword\">case</span> birthday = <span class=\"string\">\"birth_date\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，即使属性名称与 JSON 中的字段名称一致，如果自定义了 <code>CodingKeys</code>，这些属性也是无法省略的，否则会得到一个 <code>Type &#39;Student&#39; does not conform to protocol &#39;Codable&#39;</code> 的编译错误，这一点还是有点坑的。不过在编译时给 <code>CodingKeys</code> 补全其他默认的属性的声明在理论上是可行的，期待苹果后续的优化了。</p>\n<h3 id=\"可选值\"><a href=\"#可选值\" class=\"headerlink\" title=\"可选值\"></a>可选值</h3><p>有些字段有可能会是空值。还是用学生的出生日期来举例，假设有些学生的出生日期没有统计到，这时候后台返回数据格式有两种选择，一种是对于没有出生日期的数据，直接不包含 <code>birth_date</code> 字段，另一种是指定为空值：<code>&quot;birth_date&quot;: null</code></p>\n<p>对于这两种形式，都只需要将 birthday 属性声明为可选值即可正常解析：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">var</span> birthday: <span class=\"type\">Date?</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解析-JSON-数组\"><a href=\"#解析-JSON-数组\" class=\"headerlink\" title=\"解析 JSON 数组\"></a>解析 JSON 数组</h2><p><strong>Codable</strong> 协议同样支持数组类型，只需要满足一个前提：只要数组中的元素实现了 <strong>Codable</strong> 协议，数组将自动获得 <strong>Codable</strong> 协议的实现。</p>\n<p>使用 <code>JSONDecoder</code> 解析时只需要指定类型为对应的数组即可：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> students = <span class=\"keyword\">try</span> <span class=\"type\">JSONDecoder</span>().decode([<span class=\"type\">Student</span>].<span class=\"keyword\">self</span>, from: data)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 异常处理</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"归档数据\"><a href=\"#归档数据\" class=\"headerlink\" title=\"归档数据\"></a>归档数据</h2><p>归档数据使用 <code>Encodable</code> 协议，使用方式与 <code>Decodable</code> 一致。</p>\n<h3 id=\"导出为-JSON\"><a href=\"#导出为-JSON\" class=\"headerlink\" title=\"导出为 JSON\"></a>导出为 JSON</h3><p>将数据模型转换为 JSON 与解析过程类似，将 JSONDecoder 更换为 JSONEncoder 即可：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> data = <span class=\"keyword\">try</span> <span class=\"type\">JSONEncoder</span>().encode(xiaomin)</span><br><span class=\"line\"><span class=\"keyword\">let</span> json = <span class=\"type\">String</span>(data: data, encoding: .utf8)</span><br></pre></td></tr></table></figure>\n\n<p>JSONEncoder 有一个 outputFormatting 的属性，可以指定输出 JSON 的排版风格，看定义：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">OutputFormatting</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// Produce JSON compacted by removing whitespace. This is the default formatting.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> compact</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// Produce human-readable JSON with indented output.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> prettyPrinted</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>compact</p>\n<p>默认的 compact 风格会移除 JSON 数据中的所有格式信息，比如换行、空格和缩紧等，以减小 JSON 数据所占的空间。如果导出的 JSON 数据用户程序间的通讯，对阅读要求不高时，推荐使用这个设置。</p>\n</li>\n<li><p>prettyPrinted</p>\n<p>如果输出的 JSON 数据是用来阅读查看的，那么可以选择 prettyPrinted，这时候输出的 JSON 会自动进行格式化，添加换行、空格和缩进，以便于阅读。类似于上面文中使用的 JSON 排版风格。</p>\n</li>\n</ul>\n<h2 id=\"属性列表-PropertyList\"><a href=\"#属性列表-PropertyList\" class=\"headerlink\" title=\"属性列表(PropertyList)\"></a>属性列表(PropertyList)</h2><p><strong>Codable</strong> 协议并非只支持 JSON 格式的数据，它同样支持属性列表，即 mac 上常用的 <code>plist</code> 文件格式。这在我们做一些系统配置之类的工作时会很有用。</p>\n<p>属性列表的解析和归档秉承了苹果API一贯的简洁易用的特点，使用方式 JSON 格式一致，并不需要对已经实现的 <strong>Codable</strong> 协议作任何修改，只需要将 <code>JSONEncoder</code> 和 <code>JSONDecoder</code> 替换成对应的 <code>PropertyListEncoder</code> 和 <code>PropertyListDecoder</code> 即可。</p>\n<p>属性列表本质上是特殊格式标准的 <code>XML</code> 文档，所以理论上来说，我们可以参照系统提供的 Decoder/Encoder 自己实现任意格式的数据序列化与反序列化方案。同时苹果也随时可能通过实现新的 Decoder/Encoder 类来扩展其他数据格式的处理能力。这也正是文章开头所说的，<strong>Codable</strong> 的能力并不止于此，它具有很大的可扩展空间。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>到此 <strong>Codable</strong> 的核心用法基本讲完了。相比目前比较常用的几个框架：</p>\n<p><a href=\"https://github.com/Hearst-DD/ObjectMapper\" target=\"_blank\" rel=\"noopener\"><strong>ObjectMapper</strong></a> 使用范型机制进行模型解析，但是需要手动对每一个属性写映射关系，比较繁琐。我自己项目中也是用的这个框架，后来自己对其做了些优化，利用反射机制对基本数据类型实现了自动解析，但是自定义类型仍然需要手动写映射，并且必须继承实现了自动解析的 Model 基类，限制较多。</p>\n<p><a href=\"https://github.com/SwiftyJSON/SwiftyJSON\" target=\"_blank\" rel=\"noopener\"><strong>SwiftyJSON</strong></a> 简单了解过，其本质其实只是将 JSON 解析成了字典类型的数据，而实际使用时依然需要使用下标方式去取值，非常繁琐且容易出错，不易阅读和维护，个人认为这是很糟糕的设计。</p>\n<p><a href=\"https://github.com/alibaba/HandyJSON\" target=\"_blank\" rel=\"noopener\"><strong>HandyJSON</strong></a> 是阿里推出的框架，思路与 <strong>Codable</strong> 殊途同归，之前也用过一阵，当时因为对枚举和 <code>Date</code> 等类型的支持还不够完善，最终还是用回了<strong>ObjectMapper</strong>。不过目前看来完善程度已经很高了，或许可以再次尝试踩下坑。</p>\n<p>总体来说，<strong>Codable</strong> 作为语言层面对模型解析的支持方案，有其自身的优势。不过在灵活性上稍有欠缺，对自定义字段的支持也还不够人性化，期待后续的完善。</p>\n<p>对于第三方库来说，<strong>Codable</strong> 的推出既是一种挑战，但同时也是一个机遇，相信这些框架的作者们都会从 Codaable 获得许多灵感来优化提升自己的框架，在不久的将来制造一个百家争鸣的局面。</p>\n"},{"title":"实现 UITableViewCell 侧滑操作列表","abstract":"我们都知道 `UITableView` 支持实现侧滑操作，一般用来实现删除一个项目，实现起来也很简单，只需要实现 `UITableView` 的三个代理方法","_content":"\n## 曾经\n\n我们都知道 `UITableView` 支持实现侧滑操作，一般用来实现删除一个项目，实现起来也很简单，只需要实现 `UITableView` 的三个代理方法：\n\n- 首先告诉`UITableView`我们需要实现的操作类型，比如返回一个`.delete`\n\n```swift\npublic func tableView(_ tableView: UITableView, editingStyleForRowAt indexPath: IndexPath) -> UITableViewCellEditingStyle {\n    return .delete\n}\n```\n\n- 然后告诉 UITableView 侧滑时删除按钮上显示的文字\n\n```swift\nfunc tableView(_ tableView: UITableView, titleForDeleteConfirmationButtonForRowAt indexPath: IndexPath) -> String? {\n    return \"Delete\"\n}\n```\n\n- 最后实现按钮触发后执行的操作\n\n```swift\npublic func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) {\n    // Do somthing\n}\n```\n\n几个项目下来，我们对这个三部曲早就是滚瓜烂熟了。不过有时候会想，一个简单的操作按钮，需要实现三个 Delegate 方法来达到效果，会不会太繁琐了。。。\n\n更何况还有一件更坑的事情：`editingStyleForRow`和`titleForDeleteConfirmationButton`这两个方法属于`UITableViewDelegate`协议，而`commit editingStyle`这个方法属于`UITableViewDataSource`协议。\n这意味着，如果你为`UITableView`实现了通用的`DataSource`协议，那么要实现侧滑操作就不可避免要破坏代码结构了。。。\n\n另外，侧滑支持多项操作的需求越来越旺盛，而此时我们的经典三部曲已经无法胜任工作了。\n\n这时候要么选择第三方的实现方案，做好随时被坑的准备；要么，自己去实现一个更大的。。。坑？\n\n## iOS 8 之后\n\n估计苹果的工程师也为自己这个天才的设计折服了吧，于是在 iOS 8 引入了一个新的 API：`UITableViewRowAction`，先来看一看定义压压惊：\n\n```swift\n@available(iOS 8.0, *)\nopen class UITableViewRowAction : NSObject, NSCopying {\n\n    public convenience init(style: UITableViewRowActionStyle, title: String?, handler: @escaping (UITableViewRowAction, IndexPath) -> Swift.Void)\n\n    open var style: UITableViewRowActionStyle { get }\n\n    open var title: String?\n\n    @NSCopying open var backgroundColor: UIColor? // default background color is dependent on style\n\n    @NSCopying open var backgroundEffect: UIVisualEffect?\n}\n```\n\n先来看构造器，便利构造器接受三个属性：`style`、`title`、`handler`。\n\n`title`这个不用说了，肯定就是按钮显示的标题了。\n\n`style`通过定义可以看到，是一个`UITableViewRowActionStyle`类型的枚举值，通过构造器传入之后便不可更改了，想来是决定操作按钮的显示样式的吧，`destructive`这个单词是不是很熟悉？\n\n```swift\n@available(iOS 8.0, *)\npublic enum UITableViewRowActionStyle : Int {\n    case `default`\n    case destructive\n    case normal\n}\n```\n\n继续往下看到`handler`，这是一个闭包，显然是用来响应按钮点击事件的了，终于不用另外实现一个`Delegate`方法去响应操作事件了么？自从 iOS 4 之后引入了 block，苹果已经一发不可收拾了，API 改造大军正在路上。。。\n\nclass 定义里面还有两个属性：\n\n首先看到`backgroundColor`，字面意思很好理解，就是背景颜色了，后面注释了一行小字：***default background color is dependent on style***。\n\n这证实了我们的猜想：`style`属性决定了按钮的样式，也就是背景颜色，当然，我们也可以通过`backgroundColor`自己另外指定背景色。\n\n最后一个属性是`backgroundEffect`，是`UIVisualEffect`类型的。`UIVisualEffect`？！这是啥？有经验的同学都知道，这是 iOS 7 之后引入的毛玻璃特效啊，不过研究了半天发现并没有卵用😂。也可能是我打开的方式不对？有知道的同学可以指点下。。。\n\n## 实践\n\n好了，看完了类定义，赶紧来看看怎么使用吧。先看一下`UITableViewDelegate`的定义，关于`UITableViewRowAction`只定义了一个方法：\n\n```swift\nfunc tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -> [UITableViewRowAction]?\n```\n\n终于决定抛弃三部曲了么😳，返回值是个数组，这是支持多个操作项的节奏啊，废话少说上代码：\n\n```swift\nfunc tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -> [UITableViewRowAction]? {\n    let defaultAction = UITableViewRowAction(style: .default, title: \"Default\") \t{ (action, indexPath) in\n        self.alertTitle(\"Default action at \\(indexPath)\")\n    }\n    let normalAction = UITableViewRowAction(style: .normal, title: \"Normal\") { (action, indexPath) in\n        self.alertTitle(\"Normal action at \\(indexPath)\")\n    }\n    let destructiveAction = UITableViewRowAction(style: .destructive, title: \"Delete\") { (action, indexPath) in\n        self.alertTitle(\"Delete action at \\(indexPath)\")\n    }\n    return [defaultAction, normalAction, destructiveAction]\n}\n\nfunc alertTitle(_ title: String) {\n    let alert = UIAlertController(title: title, message: nil, preferredStyle: .alert)\n    alert.addAction(UIAlertAction(title: \"Cancel\", style: .cancel))\n    present(alert, animated: true)\n}\n```\n\n这里定义了三个`UITableViewRowAction`，分别对应不同的`style`，运行之后可以发现，`default`和`destructive`默认都是红色，`normal`默认是灰色。这里只是简单定义了一个`alertTitle`方法用来响应点击反馈，实际项目中需要替换成特定的业务逻辑。\n\n## 结语\n\n至此终于水完了`UITableViewRowAction`相关的内容，虽然这是个 iOS 8 就出来的特性了，不过最近才被我注意到，而且还没有把`backgroundEffect`属性的特性摸清，实在是惭愧。\n\n好消息是现在大多数 App 都是至少支持 iOS 8 + 了吧？可以再也不用写繁琐的三部曲了。\n","source":"_posts/tableview-cell-row-actions.md","raw":"---\ntitle: 实现 UITableViewCell 侧滑操作列表\nabstract: 我们都知道 `UITableView` 支持实现侧滑操作，一般用来实现删除一个项目，实现起来也很简单，只需要实现 `UITableView` 的三个代理方法\n---\n\n## 曾经\n\n我们都知道 `UITableView` 支持实现侧滑操作，一般用来实现删除一个项目，实现起来也很简单，只需要实现 `UITableView` 的三个代理方法：\n\n- 首先告诉`UITableView`我们需要实现的操作类型，比如返回一个`.delete`\n\n```swift\npublic func tableView(_ tableView: UITableView, editingStyleForRowAt indexPath: IndexPath) -> UITableViewCellEditingStyle {\n    return .delete\n}\n```\n\n- 然后告诉 UITableView 侧滑时删除按钮上显示的文字\n\n```swift\nfunc tableView(_ tableView: UITableView, titleForDeleteConfirmationButtonForRowAt indexPath: IndexPath) -> String? {\n    return \"Delete\"\n}\n```\n\n- 最后实现按钮触发后执行的操作\n\n```swift\npublic func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) {\n    // Do somthing\n}\n```\n\n几个项目下来，我们对这个三部曲早就是滚瓜烂熟了。不过有时候会想，一个简单的操作按钮，需要实现三个 Delegate 方法来达到效果，会不会太繁琐了。。。\n\n更何况还有一件更坑的事情：`editingStyleForRow`和`titleForDeleteConfirmationButton`这两个方法属于`UITableViewDelegate`协议，而`commit editingStyle`这个方法属于`UITableViewDataSource`协议。\n这意味着，如果你为`UITableView`实现了通用的`DataSource`协议，那么要实现侧滑操作就不可避免要破坏代码结构了。。。\n\n另外，侧滑支持多项操作的需求越来越旺盛，而此时我们的经典三部曲已经无法胜任工作了。\n\n这时候要么选择第三方的实现方案，做好随时被坑的准备；要么，自己去实现一个更大的。。。坑？\n\n## iOS 8 之后\n\n估计苹果的工程师也为自己这个天才的设计折服了吧，于是在 iOS 8 引入了一个新的 API：`UITableViewRowAction`，先来看一看定义压压惊：\n\n```swift\n@available(iOS 8.0, *)\nopen class UITableViewRowAction : NSObject, NSCopying {\n\n    public convenience init(style: UITableViewRowActionStyle, title: String?, handler: @escaping (UITableViewRowAction, IndexPath) -> Swift.Void)\n\n    open var style: UITableViewRowActionStyle { get }\n\n    open var title: String?\n\n    @NSCopying open var backgroundColor: UIColor? // default background color is dependent on style\n\n    @NSCopying open var backgroundEffect: UIVisualEffect?\n}\n```\n\n先来看构造器，便利构造器接受三个属性：`style`、`title`、`handler`。\n\n`title`这个不用说了，肯定就是按钮显示的标题了。\n\n`style`通过定义可以看到，是一个`UITableViewRowActionStyle`类型的枚举值，通过构造器传入之后便不可更改了，想来是决定操作按钮的显示样式的吧，`destructive`这个单词是不是很熟悉？\n\n```swift\n@available(iOS 8.0, *)\npublic enum UITableViewRowActionStyle : Int {\n    case `default`\n    case destructive\n    case normal\n}\n```\n\n继续往下看到`handler`，这是一个闭包，显然是用来响应按钮点击事件的了，终于不用另外实现一个`Delegate`方法去响应操作事件了么？自从 iOS 4 之后引入了 block，苹果已经一发不可收拾了，API 改造大军正在路上。。。\n\nclass 定义里面还有两个属性：\n\n首先看到`backgroundColor`，字面意思很好理解，就是背景颜色了，后面注释了一行小字：***default background color is dependent on style***。\n\n这证实了我们的猜想：`style`属性决定了按钮的样式，也就是背景颜色，当然，我们也可以通过`backgroundColor`自己另外指定背景色。\n\n最后一个属性是`backgroundEffect`，是`UIVisualEffect`类型的。`UIVisualEffect`？！这是啥？有经验的同学都知道，这是 iOS 7 之后引入的毛玻璃特效啊，不过研究了半天发现并没有卵用😂。也可能是我打开的方式不对？有知道的同学可以指点下。。。\n\n## 实践\n\n好了，看完了类定义，赶紧来看看怎么使用吧。先看一下`UITableViewDelegate`的定义，关于`UITableViewRowAction`只定义了一个方法：\n\n```swift\nfunc tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -> [UITableViewRowAction]?\n```\n\n终于决定抛弃三部曲了么😳，返回值是个数组，这是支持多个操作项的节奏啊，废话少说上代码：\n\n```swift\nfunc tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -> [UITableViewRowAction]? {\n    let defaultAction = UITableViewRowAction(style: .default, title: \"Default\") \t{ (action, indexPath) in\n        self.alertTitle(\"Default action at \\(indexPath)\")\n    }\n    let normalAction = UITableViewRowAction(style: .normal, title: \"Normal\") { (action, indexPath) in\n        self.alertTitle(\"Normal action at \\(indexPath)\")\n    }\n    let destructiveAction = UITableViewRowAction(style: .destructive, title: \"Delete\") { (action, indexPath) in\n        self.alertTitle(\"Delete action at \\(indexPath)\")\n    }\n    return [defaultAction, normalAction, destructiveAction]\n}\n\nfunc alertTitle(_ title: String) {\n    let alert = UIAlertController(title: title, message: nil, preferredStyle: .alert)\n    alert.addAction(UIAlertAction(title: \"Cancel\", style: .cancel))\n    present(alert, animated: true)\n}\n```\n\n这里定义了三个`UITableViewRowAction`，分别对应不同的`style`，运行之后可以发现，`default`和`destructive`默认都是红色，`normal`默认是灰色。这里只是简单定义了一个`alertTitle`方法用来响应点击反馈，实际项目中需要替换成特定的业务逻辑。\n\n## 结语\n\n至此终于水完了`UITableViewRowAction`相关的内容，虽然这是个 iOS 8 就出来的特性了，不过最近才被我注意到，而且还没有把`backgroundEffect`属性的特性摸清，实在是惭愧。\n\n好消息是现在大多数 App 都是至少支持 iOS 8 + 了吧？可以再也不用写繁琐的三部曲了。\n","slug":"tableview-cell-row-actions","published":1,"date":"2017-04-07T06:24:36.000Z","updated":"2020-01-31T03:37:49.645Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck61tll2m0008ufqb0p0ybb6p","content":"<h2 id=\"曾经\"><a href=\"#曾经\" class=\"headerlink\" title=\"曾经\"></a>曾经</h2><p>我们都知道 <code>UITableView</code> 支持实现侧滑操作，一般用来实现删除一个项目，实现起来也很简单，只需要实现 <code>UITableView</code> 的三个代理方法：</p>\n<ul>\n<li>首先告诉<code>UITableView</code>我们需要实现的操作类型，比如返回一个<code>.delete</code></li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, editingStyleForRowAt indexPath: IndexPath)</span></span> -&gt; <span class=\"type\">UITableViewCellEditingStyle</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> .delete</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后告诉 UITableView 侧滑时删除按钮上显示的文字</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, titleForDeleteConfirmationButtonForRowAt indexPath: IndexPath)</span></span> -&gt; <span class=\"type\">String?</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Delete\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>最后实现按钮触发后执行的操作</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Do somthing</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>几个项目下来，我们对这个三部曲早就是滚瓜烂熟了。不过有时候会想，一个简单的操作按钮，需要实现三个 Delegate 方法来达到效果，会不会太繁琐了。。。</p>\n<p>更何况还有一件更坑的事情：<code>editingStyleForRow</code>和<code>titleForDeleteConfirmationButton</code>这两个方法属于<code>UITableViewDelegate</code>协议，而<code>commit editingStyle</code>这个方法属于<code>UITableViewDataSource</code>协议。<br>这意味着，如果你为<code>UITableView</code>实现了通用的<code>DataSource</code>协议，那么要实现侧滑操作就不可避免要破坏代码结构了。。。</p>\n<p>另外，侧滑支持多项操作的需求越来越旺盛，而此时我们的经典三部曲已经无法胜任工作了。</p>\n<p>这时候要么选择第三方的实现方案，做好随时被坑的准备；要么，自己去实现一个更大的。。。坑？</p>\n<h2 id=\"iOS-8-之后\"><a href=\"#iOS-8-之后\" class=\"headerlink\" title=\"iOS 8 之后\"></a>iOS 8 之后</h2><p>估计苹果的工程师也为自己这个天才的设计折服了吧，于是在 iOS 8 引入了一个新的 API：<code>UITableViewRowAction</code>，先来看一看定义压压惊：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">8.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UITableViewRowAction</span> : <span class=\"title\">NSObject</span>, <span class=\"title\">NSCopying</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">convenience</span> <span class=\"keyword\">init</span>(style: <span class=\"type\">UITableViewRowActionStyle</span>, title: <span class=\"type\">String?</span>, handler: @escaping (<span class=\"type\">UITableViewRowAction</span>, <span class=\"type\">IndexPath</span>) -&gt; <span class=\"type\">Swift</span>.<span class=\"type\">Void</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">var</span> style: <span class=\"type\">UITableViewRowActionStyle</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">var</span> title: <span class=\"type\">String?</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NSCopying</span> <span class=\"keyword\">open</span> <span class=\"keyword\">var</span> backgroundColor: <span class=\"type\">UIColor?</span> <span class=\"comment\">// default background color is dependent on style</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NSCopying</span> <span class=\"keyword\">open</span> <span class=\"keyword\">var</span> backgroundEffect: <span class=\"type\">UIVisualEffect?</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先来看构造器，便利构造器接受三个属性：<code>style</code>、<code>title</code>、<code>handler</code>。</p>\n<p><code>title</code>这个不用说了，肯定就是按钮显示的标题了。</p>\n<p><code>style</code>通过定义可以看到，是一个<code>UITableViewRowActionStyle</code>类型的枚举值，通过构造器传入之后便不可更改了，想来是决定操作按钮的显示样式的吧，<code>destructive</code>这个单词是不是很熟悉？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">8.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">UITableViewRowActionStyle</span> : <span class=\"title\">Int</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> `<span class=\"keyword\">default</span>`</span><br><span class=\"line\">    <span class=\"keyword\">case</span> destructive</span><br><span class=\"line\">    <span class=\"keyword\">case</span> normal</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>继续往下看到<code>handler</code>，这是一个闭包，显然是用来响应按钮点击事件的了，终于不用另外实现一个<code>Delegate</code>方法去响应操作事件了么？自从 iOS 4 之后引入了 block，苹果已经一发不可收拾了，API 改造大军正在路上。。。</p>\n<p>class 定义里面还有两个属性：</p>\n<p>首先看到<code>backgroundColor</code>，字面意思很好理解，就是背景颜色了，后面注释了一行小字：<strong><em>default background color is dependent on style</em></strong>。</p>\n<p>这证实了我们的猜想：<code>style</code>属性决定了按钮的样式，也就是背景颜色，当然，我们也可以通过<code>backgroundColor</code>自己另外指定背景色。</p>\n<p>最后一个属性是<code>backgroundEffect</code>，是<code>UIVisualEffect</code>类型的。<code>UIVisualEffect</code>？！这是啥？有经验的同学都知道，这是 iOS 7 之后引入的毛玻璃特效啊，不过研究了半天发现并没有卵用😂。也可能是我打开的方式不对？有知道的同学可以指点下。。。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>好了，看完了类定义，赶紧来看看怎么使用吧。先看一下<code>UITableViewDelegate</code>的定义，关于<code>UITableViewRowAction</code>只定义了一个方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, editActionsForRowAt indexPath: IndexPath)</span></span> -&gt; [<span class=\"type\">UITableViewRowAction</span>]?</span><br></pre></td></tr></table></figure>\n\n<p>终于决定抛弃三部曲了么😳，返回值是个数组，这是支持多个操作项的节奏啊，废话少说上代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, editActionsForRowAt indexPath: IndexPath)</span></span> -&gt; [<span class=\"type\">UITableViewRowAction</span>]? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> defaultAction = <span class=\"type\">UITableViewRowAction</span>(style: .<span class=\"keyword\">default</span>, title: <span class=\"string\">\"Default\"</span>) \t&#123; (action, indexPath) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.alertTitle(<span class=\"string\">\"Default action at \\(indexPath)\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> normalAction = <span class=\"type\">UITableViewRowAction</span>(style: .normal, title: <span class=\"string\">\"Normal\"</span>) &#123; (action, indexPath) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.alertTitle(<span class=\"string\">\"Normal action at \\(indexPath)\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> destructiveAction = <span class=\"type\">UITableViewRowAction</span>(style: .destructive, title: <span class=\"string\">\"Delete\"</span>) &#123; (action, indexPath) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.alertTitle(<span class=\"string\">\"Delete action at \\(indexPath)\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [defaultAction, normalAction, destructiveAction]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">alertTitle</span><span class=\"params\">(<span class=\"number\">_</span> title: String)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> alert = <span class=\"type\">UIAlertController</span>(title: title, message: <span class=\"literal\">nil</span>, preferredStyle: .alert)</span><br><span class=\"line\">    alert.addAction(<span class=\"type\">UIAlertAction</span>(title: <span class=\"string\">\"Cancel\"</span>, style: .cancel))</span><br><span class=\"line\">    present(alert, animated: <span class=\"literal\">true</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里定义了三个<code>UITableViewRowAction</code>，分别对应不同的<code>style</code>，运行之后可以发现，<code>default</code>和<code>destructive</code>默认都是红色，<code>normal</code>默认是灰色。这里只是简单定义了一个<code>alertTitle</code>方法用来响应点击反馈，实际项目中需要替换成特定的业务逻辑。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>至此终于水完了<code>UITableViewRowAction</code>相关的内容，虽然这是个 iOS 8 就出来的特性了，不过最近才被我注意到，而且还没有把<code>backgroundEffect</code>属性的特性摸清，实在是惭愧。</p>\n<p>好消息是现在大多数 App 都是至少支持 iOS 8 + 了吧？可以再也不用写繁琐的三部曲了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"曾经\"><a href=\"#曾经\" class=\"headerlink\" title=\"曾经\"></a>曾经</h2><p>我们都知道 <code>UITableView</code> 支持实现侧滑操作，一般用来实现删除一个项目，实现起来也很简单，只需要实现 <code>UITableView</code> 的三个代理方法：</p>\n<ul>\n<li>首先告诉<code>UITableView</code>我们需要实现的操作类型，比如返回一个<code>.delete</code></li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, editingStyleForRowAt indexPath: IndexPath)</span></span> -&gt; <span class=\"type\">UITableViewCellEditingStyle</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> .delete</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后告诉 UITableView 侧滑时删除按钮上显示的文字</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, titleForDeleteConfirmationButtonForRowAt indexPath: IndexPath)</span></span> -&gt; <span class=\"type\">String?</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Delete\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>最后实现按钮触发后执行的操作</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Do somthing</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>几个项目下来，我们对这个三部曲早就是滚瓜烂熟了。不过有时候会想，一个简单的操作按钮，需要实现三个 Delegate 方法来达到效果，会不会太繁琐了。。。</p>\n<p>更何况还有一件更坑的事情：<code>editingStyleForRow</code>和<code>titleForDeleteConfirmationButton</code>这两个方法属于<code>UITableViewDelegate</code>协议，而<code>commit editingStyle</code>这个方法属于<code>UITableViewDataSource</code>协议。<br>这意味着，如果你为<code>UITableView</code>实现了通用的<code>DataSource</code>协议，那么要实现侧滑操作就不可避免要破坏代码结构了。。。</p>\n<p>另外，侧滑支持多项操作的需求越来越旺盛，而此时我们的经典三部曲已经无法胜任工作了。</p>\n<p>这时候要么选择第三方的实现方案，做好随时被坑的准备；要么，自己去实现一个更大的。。。坑？</p>\n<h2 id=\"iOS-8-之后\"><a href=\"#iOS-8-之后\" class=\"headerlink\" title=\"iOS 8 之后\"></a>iOS 8 之后</h2><p>估计苹果的工程师也为自己这个天才的设计折服了吧，于是在 iOS 8 引入了一个新的 API：<code>UITableViewRowAction</code>，先来看一看定义压压惊：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">8.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UITableViewRowAction</span> : <span class=\"title\">NSObject</span>, <span class=\"title\">NSCopying</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">convenience</span> <span class=\"keyword\">init</span>(style: <span class=\"type\">UITableViewRowActionStyle</span>, title: <span class=\"type\">String?</span>, handler: @escaping (<span class=\"type\">UITableViewRowAction</span>, <span class=\"type\">IndexPath</span>) -&gt; <span class=\"type\">Swift</span>.<span class=\"type\">Void</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">var</span> style: <span class=\"type\">UITableViewRowActionStyle</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">var</span> title: <span class=\"type\">String?</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NSCopying</span> <span class=\"keyword\">open</span> <span class=\"keyword\">var</span> backgroundColor: <span class=\"type\">UIColor?</span> <span class=\"comment\">// default background color is dependent on style</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NSCopying</span> <span class=\"keyword\">open</span> <span class=\"keyword\">var</span> backgroundEffect: <span class=\"type\">UIVisualEffect?</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先来看构造器，便利构造器接受三个属性：<code>style</code>、<code>title</code>、<code>handler</code>。</p>\n<p><code>title</code>这个不用说了，肯定就是按钮显示的标题了。</p>\n<p><code>style</code>通过定义可以看到，是一个<code>UITableViewRowActionStyle</code>类型的枚举值，通过构造器传入之后便不可更改了，想来是决定操作按钮的显示样式的吧，<code>destructive</code>这个单词是不是很熟悉？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">8.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">UITableViewRowActionStyle</span> : <span class=\"title\">Int</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> `<span class=\"keyword\">default</span>`</span><br><span class=\"line\">    <span class=\"keyword\">case</span> destructive</span><br><span class=\"line\">    <span class=\"keyword\">case</span> normal</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>继续往下看到<code>handler</code>，这是一个闭包，显然是用来响应按钮点击事件的了，终于不用另外实现一个<code>Delegate</code>方法去响应操作事件了么？自从 iOS 4 之后引入了 block，苹果已经一发不可收拾了，API 改造大军正在路上。。。</p>\n<p>class 定义里面还有两个属性：</p>\n<p>首先看到<code>backgroundColor</code>，字面意思很好理解，就是背景颜色了，后面注释了一行小字：<strong><em>default background color is dependent on style</em></strong>。</p>\n<p>这证实了我们的猜想：<code>style</code>属性决定了按钮的样式，也就是背景颜色，当然，我们也可以通过<code>backgroundColor</code>自己另外指定背景色。</p>\n<p>最后一个属性是<code>backgroundEffect</code>，是<code>UIVisualEffect</code>类型的。<code>UIVisualEffect</code>？！这是啥？有经验的同学都知道，这是 iOS 7 之后引入的毛玻璃特效啊，不过研究了半天发现并没有卵用😂。也可能是我打开的方式不对？有知道的同学可以指点下。。。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>好了，看完了类定义，赶紧来看看怎么使用吧。先看一下<code>UITableViewDelegate</code>的定义，关于<code>UITableViewRowAction</code>只定义了一个方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, editActionsForRowAt indexPath: IndexPath)</span></span> -&gt; [<span class=\"type\">UITableViewRowAction</span>]?</span><br></pre></td></tr></table></figure>\n\n<p>终于决定抛弃三部曲了么😳，返回值是个数组，这是支持多个操作项的节奏啊，废话少说上代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, editActionsForRowAt indexPath: IndexPath)</span></span> -&gt; [<span class=\"type\">UITableViewRowAction</span>]? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> defaultAction = <span class=\"type\">UITableViewRowAction</span>(style: .<span class=\"keyword\">default</span>, title: <span class=\"string\">\"Default\"</span>) \t&#123; (action, indexPath) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.alertTitle(<span class=\"string\">\"Default action at \\(indexPath)\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> normalAction = <span class=\"type\">UITableViewRowAction</span>(style: .normal, title: <span class=\"string\">\"Normal\"</span>) &#123; (action, indexPath) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.alertTitle(<span class=\"string\">\"Normal action at \\(indexPath)\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> destructiveAction = <span class=\"type\">UITableViewRowAction</span>(style: .destructive, title: <span class=\"string\">\"Delete\"</span>) &#123; (action, indexPath) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.alertTitle(<span class=\"string\">\"Delete action at \\(indexPath)\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [defaultAction, normalAction, destructiveAction]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">alertTitle</span><span class=\"params\">(<span class=\"number\">_</span> title: String)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> alert = <span class=\"type\">UIAlertController</span>(title: title, message: <span class=\"literal\">nil</span>, preferredStyle: .alert)</span><br><span class=\"line\">    alert.addAction(<span class=\"type\">UIAlertAction</span>(title: <span class=\"string\">\"Cancel\"</span>, style: .cancel))</span><br><span class=\"line\">    present(alert, animated: <span class=\"literal\">true</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里定义了三个<code>UITableViewRowAction</code>，分别对应不同的<code>style</code>，运行之后可以发现，<code>default</code>和<code>destructive</code>默认都是红色，<code>normal</code>默认是灰色。这里只是简单定义了一个<code>alertTitle</code>方法用来响应点击反馈，实际项目中需要替换成特定的业务逻辑。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>至此终于水完了<code>UITableViewRowAction</code>相关的内容，虽然这是个 iOS 8 就出来的特性了，不过最近才被我注意到，而且还没有把<code>backgroundEffect</code>属性的特性摸清，实在是惭愧。</p>\n<p>好消息是现在大多数 App 都是至少支持 iOS 8 + 了吧？可以再也不用写繁琐的三部曲了。</p>\n"},{"title":"使用 SwiftLint 进行 Swift 代码规范检查","abstract":"SwiftLint 是 Realm 推出的一款 Swift 代码规范检查工具，基于 Github 公布的 Swift 代码规范进行代码检查，并且能够很好的和 Xcode 整合。配置好所有的设置之后，在 Xcode 中执行编译时，SwiftLint 会自动运行检查，不符合规范的代码会通过警告或者 error 的形式指示出来，并且拥有丰富的配置项，可以进行大量的自定义，相当方便。","_content":"\n> 最近跟着公司大佬在做 Laravel 后端开发，要求使用 php lint 进行代码规范检查之后才能 push 代码，保证所有人写出风格统一的代码，方便后期的维护和 Review，于是开始往老本行上反思。\n> 想想自己写了五六年的 iOS ，虽然自认代码还是写的很规整的，但是写 high 了之后还是会忽略很多细节上的东西，虽说无伤大雅，但是软件开发作为一门工程性质的东东，始终觉得规范化是一件很重要的事情。\n>在之前的公司也曾经在 iOS 组内部推行过代码规范的实施，但那时候还只是停留在弄个 Word 文档，把各条规范列一列，然后开个小会普及下的程度上。现在接触了不少其他开发领域的东西，越来越觉得对于开发者来说提高视角去了解各个方面是多么重要的一件事情。不同领域的经验、做事的方式、思路，都可以相互借鉴与融合。 \n>于是开始寻找在 iOS 下实行类似方案的可能性。说来也巧，最近在看 iOS 相关资料的时候发现了 SwiftLint 这玩意儿，遂打算来实践下。\n\n## 简介\n\n[SwiftLint](https://github.com/realm/SwiftLint) 是 [Realm](https://realm.io/) 推出的一款 Swift 代码规范检查工具，Realm 就不用介绍了，他们家推出的移动端跨平台数据库在业内的名气还是很大的，就算没有用过，相信大多数人也是听过的。\n**SwiftLint** 基于 Github 公布的 [Swift 代码规范](https://github.com/github/swift-style-guide)进行代码检查，并且能够很好的和 Xcode 整合。配置好所有的设置之后，在 Xcode 中执行编译时，SwiftLint 会自动运行检查，不符合规范的代码会通过警告或者 error 的形式指示出来，并且拥有丰富的配置项，可以进行大量的自定义，相当方便。\n\n## 安装\n\n**SwiftLint** 有多种不同的安装方式，可以根据自己的喜好选择。\n\n### 使用 Homebrew 安装\n\n**Homebrew** 是 macOS 自带的包管理工具，使用这种方式安装也是最简单的：\n\n```bash\nbrew install swiftlint\n```\n\n### 使用 CocoaPods 安装\n\n通过 CocoaPods 安装同样很简单，只需要在 Podfile 中添加依赖：\n\n```bash\npod 'SwiftLint'\n```\n\n之后执行 `pod install` 就可以自动安装了，这种方式会将 **SwiftLint** 安装到项目的 `Pods/` 目录下。如果你想要针对不同的项目使用不同的 **SwiftLint** 版本，这是一种很好的解决方案（**Homebrew** 会自动安装最新版本）。\n\n需要注意的是使用这种方案会将整个 ** SwiftLint** 以及他的依赖包的完整资源文件都安装到 `Pods/` 目录中去，所以在使用版本管理工具比如 `git` 时要注意设置忽略相关目录。\n\n### 使用安装包\n\n**SwiftLint** 还支持使用 `pkg` 安装包进行安装，在官方的 Github 页面可以找到最新发布的[安装包](https://github.com/realm/SwiftLint/releases/tag/0.17.0)。\n\n### 编译源代码\n\n**SwiftLint** 完全使用 Swift 开发，并且它是基于 [MIT License](https://github.com/realm/SwiftLint/blob/master/LICENSE) 开源的，所以你可以下载它的源代码，然后通过以下命令编译安装：\n\n```bash\ngit submodule update --init --recursive; make install\n```\n\n### 安装完成\n\n等待安装完成，输入 `swiftlint help` 可以查看所有可用的命令：\n\n```bash\n➜  ~ swiftlint help\nAvailable commands:\n\n   autocorrect   Automatically correct warnings and errors\n   help          Display general or command-specific help\n   lint          Print lint warnings and errors (default command)\n   rules         Display the list of rules and their identifiers\n   version       Display the current version of SwiftLint\n```\n\n到此 **SwiftLint** 就安装完成了\n\n## 配置\n\n### Xcode\n\n接下来需要在工程中配置相关编译选项，才能使 **SwiftLint** 在 Xcode 中运行起来。配置也很简单，只需要在 Xcode 的 `Build Phases` 中新建一个 `Run Script Phase` 配置项，在里面添加如下代码：\n\n```bash\nif which swiftlint >/dev/null; then\n  swiftlint\nelse\n  echo \"warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint\"\nfi\n```\n\n如图所示：\n\n![](https://github.com/realm/SwiftLint/blob/master/assets/runscript.png?raw=true)\n\n如果是通过 CocoaPods 安装的 **SwiftLint** 需要将 `swiftlint` 替换为 CocoaPods 中的路径： `\"${PODS_ROOT}/SwiftLint/swiftlint\"`。\n这里其实是设置了一个自动编译脚本，每次运行编译都会自动执行这个脚本，如果正确安装了 **SwiftLint**，就会执行 **SwiftLint** 中的代码规范检查，如果没有安装，脚本会抛出一个没有安装 **SwiftLint** 并提示下载的警告，方便提醒团队团队中没有安装的成员。\n当然，你也可以设置为强制要求安装，这时如果没有安装则无法通过编译。只需要在脚本中 `echo \"warning: ...\"` 之后添加一行代码：`exit 1`，这样一来，如果没有安装 **SwiftLint**，编译时会直接抛出一个编译错误而非警告，提示需要安装 **SwiftLint**。\n到此配置就完成了，是不是很简单。\n\n### 自定义配置\n\n现在编译一下项目看看，是不是很可怕😨：\n\n![](https://upload-images.jianshu.io/upload_images/619631-bd69d1a1ac765844.png)\n\n不要被 999+ 吓到了，仔细看一下具体的错误，会发现好多都是第三方库的代码规范问题，而且好多问题的级别被设置成为了 error\n这样子可不行，第三方库的代码规范问题不能让我们自己的项目来背锅，接下来需要做一些配置，让 **SwiftLint** 在做代码规范检查的时候自动忽略 CocoaPods、Carthage 等包管理器引入的第三方库（当然，手动导入的第三方库也能设置忽略）\n\n首先需要在项目的根目录下新建一个名为 `.swiftlint.yml` 的配置文件，输入如下内容：\n\n```yaml\nexcluded:\n  - Pods\n```\n\n`excluded` 配置项用来设置忽略代码规范检查的路径，可以指定整个文件夹，也可以指定精确路径下的文件，通过 `- xxxx` 的形式列在下面就可以了，比如如果你的项目使用 Carthage 管理第三方库的话，可以将 `Carthage` 目录添加到忽略列表：\n\n```yaml\nexcluded:\n  - Pods\n  - Carthage\n```\n\n保存之后再来编译下，少了很多编译错误了，至少第三方库的编译错误都被干掉了，oh yeah~\n\n![](http://upload-images.jianshu.io/upload_images/619631-ef9dd3879b1f6d5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n不过错误和警告依然很多，继续往下看，发现大量的 `trailing_whitespace` 的警告，这个是之前写代码不注意留下的，在空行中包含了空格，虽然肉眼看不出来，但是 **SwiftLint** 火眼金睛啊。\n![](http://upload-images.jianshu.io/upload_images/619631-d4fca7a4c8043732.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n你可以选择更正所有这些不规范的问题，不过如果这个这个项目是遗留下来的老项目，可能存在大量类似的问题，手动更正这些问题需要相当多的精力，这时候可以选择开启忽略这类问题，只需要在 `.swiftlint.yml` 文件中加入如下代码：\n\n```yaml\ndisabled_rules:\n  - trailing_whitespace\n```\n\n再次编译，发现 `trailing_whitespace` 的问题已经不再提示了，你可以用同样的方法配置忽略特定的规则。\n\n#### 其他规则\n\nXcode自动生成的代码经常包含大段的注视，我们经常会选择保留这些注释。不过 **SwiftLint** 有一个 `line_length` 的规则，默认是会检查注释的长度的，可以在 `.swiftlint.yml` 中设置忽略检查注释的长度：\n\n```yaml\nline_length:\n  warning: 110\n  ignores_function_declarations: true\n  ignores_comments: true\n```\n\n这段代码设置了 `line_length ` 的检查规则：\n`warning: 110 ` 表示单行字符数超过 110 时抛出警告，你也可以设置为其他的值。\n`ignores_function_declarations` 表示是否忽略检查函数定义的长度\n`ignores_comments` 设置是否忽略检查注释的长度\n当然，你也可以在 `disabled_rules` 中设置忽略单行长度规则\n\n[这里](https://github.com/realm/SwiftLint/tree/master/Source/SwiftLintFramework/Rules)有所有目前已经实现了的规则。你也可以实现自己的规则，然后给他们发 Pull requests。\n\n本文的[最后](#SwiftLint)附上了我自己的 `.swiftlint.yml` 文件，你可以在 **SwiftLint** 的[官方文档](https://github.com/realm/SwiftLint#configuration)找到更多关于自定义规则的说明。\n\n设置完所有配置之后，再次编译代码，之后就可以根据错误提示去更正不规范的代码了。\n\n#### `.swiftlint.yml` 的嵌套\n\n`.swiftlint.yml` 配置文件支持嵌套，因此\n\n- 你可以给每个文件夹下的代码单独指定不同的规则设置\n- 每个文件会匹配距离自己层级最近的父文件夹中的配置文件\n- 嵌套的配置文件中的 `excluded ` 和 `included` 配置会被忽略\n\n## 结语\n\n终于写完了第一篇技术博客，深感写文章的不易，希望能保持下去。\n这篇文章是我在初步研究了 **SwiftLint** 之后写的，一定有很多谬误和不足之处，各位轻喷- -\n\n------\n<a name=\"SwiftLint\">`.swiftlint.yml`</a>\n\n```yaml\ndisabled_rules: # rule identifiers to exclude from running\n  - force_cast\n  - trailing_whitespace\n  - cyclomatic_complexity\n  - unused_closure_parameter\n#   - colon\n#   - comma\n#   - control_statement\n# opt_in_rules: # some rules are only opt-in\n#   - empty_count\n#   - missing_docs\n#   # Find all the available rules by running:\n#   # swiftlint rules\n# included: # paths to include during linting. `--path` is ignored if present.\n#   - Docs.M/*/*.swift\nexcluded: # paths to ignore during linting. Takes precedence over `included`.\n  - Carthage\n  - Pods\n  # - Source/ExcludedFolder\n  # - Source/ExcludedFile.swift\n\n# configurable rules can be customized from this configuration file\n# binary rules can set their severity level\n# force_cast: warning # implicitly\nforce_try:\n  severity: warning # explicitly\n# rules that have both warning and error levels, can set just the warning level\n# implicitly\nline_length:\n  warning: 200\n  ignores_function_declarations: true\n  ignores_comments: true\n\n# they can set both implicitly with an array\ntype_body_length:\n  - 300 # warning\n  - 400 # error\n# or they can set both explicitly\nfile_length:\n  warning: 500\n  error: 1200\n# naming rules can set warnings/errors for min_length and max_length\n# additionally they can set excluded names\n# type_name:\n#   min_length: 4 # only warning\n#   max_length: # warning and error\n#     warning: 40\n#     error: 50\n#   excluded: iPhone # excluded via string\nidentifier_name:\n  min_length: # only min_length\n    error: 3 # only error\n  excluded: # excluded via string array\n    - id\n#     - URL\n#     - GlobalAPIKey\nreporter: \"xcode\" # reporter type (xcode, json, csv, checkstyle, junit, html, emoji)\n```\n","source":"_posts/swift-lint.md","raw":"---\ntitle: 使用 SwiftLint 进行 Swift 代码规范检查\nabstract: SwiftLint 是 Realm 推出的一款 Swift 代码规范检查工具，基于 Github 公布的 Swift 代码规范进行代码检查，并且能够很好的和 Xcode 整合。配置好所有的设置之后，在 Xcode 中执行编译时，SwiftLint 会自动运行检查，不符合规范的代码会通过警告或者 error 的形式指示出来，并且拥有丰富的配置项，可以进行大量的自定义，相当方便。\n---\n\n> 最近跟着公司大佬在做 Laravel 后端开发，要求使用 php lint 进行代码规范检查之后才能 push 代码，保证所有人写出风格统一的代码，方便后期的维护和 Review，于是开始往老本行上反思。\n> 想想自己写了五六年的 iOS ，虽然自认代码还是写的很规整的，但是写 high 了之后还是会忽略很多细节上的东西，虽说无伤大雅，但是软件开发作为一门工程性质的东东，始终觉得规范化是一件很重要的事情。\n>在之前的公司也曾经在 iOS 组内部推行过代码规范的实施，但那时候还只是停留在弄个 Word 文档，把各条规范列一列，然后开个小会普及下的程度上。现在接触了不少其他开发领域的东西，越来越觉得对于开发者来说提高视角去了解各个方面是多么重要的一件事情。不同领域的经验、做事的方式、思路，都可以相互借鉴与融合。 \n>于是开始寻找在 iOS 下实行类似方案的可能性。说来也巧，最近在看 iOS 相关资料的时候发现了 SwiftLint 这玩意儿，遂打算来实践下。\n\n## 简介\n\n[SwiftLint](https://github.com/realm/SwiftLint) 是 [Realm](https://realm.io/) 推出的一款 Swift 代码规范检查工具，Realm 就不用介绍了，他们家推出的移动端跨平台数据库在业内的名气还是很大的，就算没有用过，相信大多数人也是听过的。\n**SwiftLint** 基于 Github 公布的 [Swift 代码规范](https://github.com/github/swift-style-guide)进行代码检查，并且能够很好的和 Xcode 整合。配置好所有的设置之后，在 Xcode 中执行编译时，SwiftLint 会自动运行检查，不符合规范的代码会通过警告或者 error 的形式指示出来，并且拥有丰富的配置项，可以进行大量的自定义，相当方便。\n\n## 安装\n\n**SwiftLint** 有多种不同的安装方式，可以根据自己的喜好选择。\n\n### 使用 Homebrew 安装\n\n**Homebrew** 是 macOS 自带的包管理工具，使用这种方式安装也是最简单的：\n\n```bash\nbrew install swiftlint\n```\n\n### 使用 CocoaPods 安装\n\n通过 CocoaPods 安装同样很简单，只需要在 Podfile 中添加依赖：\n\n```bash\npod 'SwiftLint'\n```\n\n之后执行 `pod install` 就可以自动安装了，这种方式会将 **SwiftLint** 安装到项目的 `Pods/` 目录下。如果你想要针对不同的项目使用不同的 **SwiftLint** 版本，这是一种很好的解决方案（**Homebrew** 会自动安装最新版本）。\n\n需要注意的是使用这种方案会将整个 ** SwiftLint** 以及他的依赖包的完整资源文件都安装到 `Pods/` 目录中去，所以在使用版本管理工具比如 `git` 时要注意设置忽略相关目录。\n\n### 使用安装包\n\n**SwiftLint** 还支持使用 `pkg` 安装包进行安装，在官方的 Github 页面可以找到最新发布的[安装包](https://github.com/realm/SwiftLint/releases/tag/0.17.0)。\n\n### 编译源代码\n\n**SwiftLint** 完全使用 Swift 开发，并且它是基于 [MIT License](https://github.com/realm/SwiftLint/blob/master/LICENSE) 开源的，所以你可以下载它的源代码，然后通过以下命令编译安装：\n\n```bash\ngit submodule update --init --recursive; make install\n```\n\n### 安装完成\n\n等待安装完成，输入 `swiftlint help` 可以查看所有可用的命令：\n\n```bash\n➜  ~ swiftlint help\nAvailable commands:\n\n   autocorrect   Automatically correct warnings and errors\n   help          Display general or command-specific help\n   lint          Print lint warnings and errors (default command)\n   rules         Display the list of rules and their identifiers\n   version       Display the current version of SwiftLint\n```\n\n到此 **SwiftLint** 就安装完成了\n\n## 配置\n\n### Xcode\n\n接下来需要在工程中配置相关编译选项，才能使 **SwiftLint** 在 Xcode 中运行起来。配置也很简单，只需要在 Xcode 的 `Build Phases` 中新建一个 `Run Script Phase` 配置项，在里面添加如下代码：\n\n```bash\nif which swiftlint >/dev/null; then\n  swiftlint\nelse\n  echo \"warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint\"\nfi\n```\n\n如图所示：\n\n![](https://github.com/realm/SwiftLint/blob/master/assets/runscript.png?raw=true)\n\n如果是通过 CocoaPods 安装的 **SwiftLint** 需要将 `swiftlint` 替换为 CocoaPods 中的路径： `\"${PODS_ROOT}/SwiftLint/swiftlint\"`。\n这里其实是设置了一个自动编译脚本，每次运行编译都会自动执行这个脚本，如果正确安装了 **SwiftLint**，就会执行 **SwiftLint** 中的代码规范检查，如果没有安装，脚本会抛出一个没有安装 **SwiftLint** 并提示下载的警告，方便提醒团队团队中没有安装的成员。\n当然，你也可以设置为强制要求安装，这时如果没有安装则无法通过编译。只需要在脚本中 `echo \"warning: ...\"` 之后添加一行代码：`exit 1`，这样一来，如果没有安装 **SwiftLint**，编译时会直接抛出一个编译错误而非警告，提示需要安装 **SwiftLint**。\n到此配置就完成了，是不是很简单。\n\n### 自定义配置\n\n现在编译一下项目看看，是不是很可怕😨：\n\n![](https://upload-images.jianshu.io/upload_images/619631-bd69d1a1ac765844.png)\n\n不要被 999+ 吓到了，仔细看一下具体的错误，会发现好多都是第三方库的代码规范问题，而且好多问题的级别被设置成为了 error\n这样子可不行，第三方库的代码规范问题不能让我们自己的项目来背锅，接下来需要做一些配置，让 **SwiftLint** 在做代码规范检查的时候自动忽略 CocoaPods、Carthage 等包管理器引入的第三方库（当然，手动导入的第三方库也能设置忽略）\n\n首先需要在项目的根目录下新建一个名为 `.swiftlint.yml` 的配置文件，输入如下内容：\n\n```yaml\nexcluded:\n  - Pods\n```\n\n`excluded` 配置项用来设置忽略代码规范检查的路径，可以指定整个文件夹，也可以指定精确路径下的文件，通过 `- xxxx` 的形式列在下面就可以了，比如如果你的项目使用 Carthage 管理第三方库的话，可以将 `Carthage` 目录添加到忽略列表：\n\n```yaml\nexcluded:\n  - Pods\n  - Carthage\n```\n\n保存之后再来编译下，少了很多编译错误了，至少第三方库的编译错误都被干掉了，oh yeah~\n\n![](http://upload-images.jianshu.io/upload_images/619631-ef9dd3879b1f6d5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n不过错误和警告依然很多，继续往下看，发现大量的 `trailing_whitespace` 的警告，这个是之前写代码不注意留下的，在空行中包含了空格，虽然肉眼看不出来，但是 **SwiftLint** 火眼金睛啊。\n![](http://upload-images.jianshu.io/upload_images/619631-d4fca7a4c8043732.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n你可以选择更正所有这些不规范的问题，不过如果这个这个项目是遗留下来的老项目，可能存在大量类似的问题，手动更正这些问题需要相当多的精力，这时候可以选择开启忽略这类问题，只需要在 `.swiftlint.yml` 文件中加入如下代码：\n\n```yaml\ndisabled_rules:\n  - trailing_whitespace\n```\n\n再次编译，发现 `trailing_whitespace` 的问题已经不再提示了，你可以用同样的方法配置忽略特定的规则。\n\n#### 其他规则\n\nXcode自动生成的代码经常包含大段的注视，我们经常会选择保留这些注释。不过 **SwiftLint** 有一个 `line_length` 的规则，默认是会检查注释的长度的，可以在 `.swiftlint.yml` 中设置忽略检查注释的长度：\n\n```yaml\nline_length:\n  warning: 110\n  ignores_function_declarations: true\n  ignores_comments: true\n```\n\n这段代码设置了 `line_length ` 的检查规则：\n`warning: 110 ` 表示单行字符数超过 110 时抛出警告，你也可以设置为其他的值。\n`ignores_function_declarations` 表示是否忽略检查函数定义的长度\n`ignores_comments` 设置是否忽略检查注释的长度\n当然，你也可以在 `disabled_rules` 中设置忽略单行长度规则\n\n[这里](https://github.com/realm/SwiftLint/tree/master/Source/SwiftLintFramework/Rules)有所有目前已经实现了的规则。你也可以实现自己的规则，然后给他们发 Pull requests。\n\n本文的[最后](#SwiftLint)附上了我自己的 `.swiftlint.yml` 文件，你可以在 **SwiftLint** 的[官方文档](https://github.com/realm/SwiftLint#configuration)找到更多关于自定义规则的说明。\n\n设置完所有配置之后，再次编译代码，之后就可以根据错误提示去更正不规范的代码了。\n\n#### `.swiftlint.yml` 的嵌套\n\n`.swiftlint.yml` 配置文件支持嵌套，因此\n\n- 你可以给每个文件夹下的代码单独指定不同的规则设置\n- 每个文件会匹配距离自己层级最近的父文件夹中的配置文件\n- 嵌套的配置文件中的 `excluded ` 和 `included` 配置会被忽略\n\n## 结语\n\n终于写完了第一篇技术博客，深感写文章的不易，希望能保持下去。\n这篇文章是我在初步研究了 **SwiftLint** 之后写的，一定有很多谬误和不足之处，各位轻喷- -\n\n------\n<a name=\"SwiftLint\">`.swiftlint.yml`</a>\n\n```yaml\ndisabled_rules: # rule identifiers to exclude from running\n  - force_cast\n  - trailing_whitespace\n  - cyclomatic_complexity\n  - unused_closure_parameter\n#   - colon\n#   - comma\n#   - control_statement\n# opt_in_rules: # some rules are only opt-in\n#   - empty_count\n#   - missing_docs\n#   # Find all the available rules by running:\n#   # swiftlint rules\n# included: # paths to include during linting. `--path` is ignored if present.\n#   - Docs.M/*/*.swift\nexcluded: # paths to ignore during linting. Takes precedence over `included`.\n  - Carthage\n  - Pods\n  # - Source/ExcludedFolder\n  # - Source/ExcludedFile.swift\n\n# configurable rules can be customized from this configuration file\n# binary rules can set their severity level\n# force_cast: warning # implicitly\nforce_try:\n  severity: warning # explicitly\n# rules that have both warning and error levels, can set just the warning level\n# implicitly\nline_length:\n  warning: 200\n  ignores_function_declarations: true\n  ignores_comments: true\n\n# they can set both implicitly with an array\ntype_body_length:\n  - 300 # warning\n  - 400 # error\n# or they can set both explicitly\nfile_length:\n  warning: 500\n  error: 1200\n# naming rules can set warnings/errors for min_length and max_length\n# additionally they can set excluded names\n# type_name:\n#   min_length: 4 # only warning\n#   max_length: # warning and error\n#     warning: 40\n#     error: 50\n#   excluded: iPhone # excluded via string\nidentifier_name:\n  min_length: # only min_length\n    error: 3 # only error\n  excluded: # excluded via string array\n    - id\n#     - URL\n#     - GlobalAPIKey\nreporter: \"xcode\" # reporter type (xcode, json, csv, checkstyle, junit, html, emoji)\n```\n","slug":"swift-lint","published":1,"date":"2017-04-04T11:47:33.000Z","updated":"2020-01-31T03:00:01.453Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck61tll2n0009ufqb0vd127pe","content":"<blockquote>\n<p>最近跟着公司大佬在做 Laravel 后端开发，要求使用 php lint 进行代码规范检查之后才能 push 代码，保证所有人写出风格统一的代码，方便后期的维护和 Review，于是开始往老本行上反思。<br>想想自己写了五六年的 iOS ，虽然自认代码还是写的很规整的，但是写 high 了之后还是会忽略很多细节上的东西，虽说无伤大雅，但是软件开发作为一门工程性质的东东，始终觉得规范化是一件很重要的事情。<br>在之前的公司也曾经在 iOS 组内部推行过代码规范的实施，但那时候还只是停留在弄个 Word 文档，把各条规范列一列，然后开个小会普及下的程度上。现在接触了不少其他开发领域的东西，越来越觉得对于开发者来说提高视角去了解各个方面是多么重要的一件事情。不同领域的经验、做事的方式、思路，都可以相互借鉴与融合。<br>于是开始寻找在 iOS 下实行类似方案的可能性。说来也巧，最近在看 iOS 相关资料的时候发现了 SwiftLint 这玩意儿，遂打算来实践下。</p>\n</blockquote>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><a href=\"https://github.com/realm/SwiftLint\" target=\"_blank\" rel=\"noopener\">SwiftLint</a> 是 <a href=\"https://realm.io/\" target=\"_blank\" rel=\"noopener\">Realm</a> 推出的一款 Swift 代码规范检查工具，Realm 就不用介绍了，他们家推出的移动端跨平台数据库在业内的名气还是很大的，就算没有用过，相信大多数人也是听过的。<br><strong>SwiftLint</strong> 基于 Github 公布的 <a href=\"https://github.com/github/swift-style-guide\" target=\"_blank\" rel=\"noopener\">Swift 代码规范</a>进行代码检查，并且能够很好的和 Xcode 整合。配置好所有的设置之后，在 Xcode 中执行编译时，SwiftLint 会自动运行检查，不符合规范的代码会通过警告或者 error 的形式指示出来，并且拥有丰富的配置项，可以进行大量的自定义，相当方便。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p><strong>SwiftLint</strong> 有多种不同的安装方式，可以根据自己的喜好选择。</p>\n<h3 id=\"使用-Homebrew-安装\"><a href=\"#使用-Homebrew-安装\" class=\"headerlink\" title=\"使用 Homebrew 安装\"></a>使用 Homebrew 安装</h3><p><strong>Homebrew</strong> 是 macOS 自带的包管理工具，使用这种方式安装也是最简单的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install swiftlint</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-CocoaPods-安装\"><a href=\"#使用-CocoaPods-安装\" class=\"headerlink\" title=\"使用 CocoaPods 安装\"></a>使用 CocoaPods 安装</h3><p>通过 CocoaPods 安装同样很简单，只需要在 Podfile 中添加依赖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod <span class=\"string\">'SwiftLint'</span></span><br></pre></td></tr></table></figure>\n\n<p>之后执行 <code>pod install</code> 就可以自动安装了，这种方式会将 <strong>SwiftLint</strong> 安装到项目的 <code>Pods/</code> 目录下。如果你想要针对不同的项目使用不同的 <strong>SwiftLint</strong> 版本，这是一种很好的解决方案（<strong>Homebrew</strong> 会自动安装最新版本）。</p>\n<p>需要注意的是使用这种方案会将整个 ** SwiftLint** 以及他的依赖包的完整资源文件都安装到 <code>Pods/</code> 目录中去，所以在使用版本管理工具比如 <code>git</code> 时要注意设置忽略相关目录。</p>\n<h3 id=\"使用安装包\"><a href=\"#使用安装包\" class=\"headerlink\" title=\"使用安装包\"></a>使用安装包</h3><p><strong>SwiftLint</strong> 还支持使用 <code>pkg</code> 安装包进行安装，在官方的 Github 页面可以找到最新发布的<a href=\"https://github.com/realm/SwiftLint/releases/tag/0.17.0\" target=\"_blank\" rel=\"noopener\">安装包</a>。</p>\n<h3 id=\"编译源代码\"><a href=\"#编译源代码\" class=\"headerlink\" title=\"编译源代码\"></a>编译源代码</h3><p><strong>SwiftLint</strong> 完全使用 Swift 开发，并且它是基于 <a href=\"https://github.com/realm/SwiftLint/blob/master/LICENSE\" target=\"_blank\" rel=\"noopener\">MIT License</a> 开源的，所以你可以下载它的源代码，然后通过以下命令编译安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule update --init --recursive; make install</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装完成\"><a href=\"#安装完成\" class=\"headerlink\" title=\"安装完成\"></a>安装完成</h3><p>等待安装完成，输入 <code>swiftlint help</code> 可以查看所有可用的命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ swiftlint <span class=\"built_in\">help</span></span><br><span class=\"line\">Available commands:</span><br><span class=\"line\"></span><br><span class=\"line\">   autocorrect   Automatically correct warnings and errors</span><br><span class=\"line\">   <span class=\"built_in\">help</span>          Display general or <span class=\"built_in\">command</span>-specific <span class=\"built_in\">help</span></span><br><span class=\"line\">   lint          Print lint warnings and errors (default <span class=\"built_in\">command</span>)</span><br><span class=\"line\">   rules         Display the list of rules and their identifiers</span><br><span class=\"line\">   version       Display the current version of SwiftLint</span><br></pre></td></tr></table></figure>\n\n<p>到此 <strong>SwiftLint</strong> 就安装完成了</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><h3 id=\"Xcode\"><a href=\"#Xcode\" class=\"headerlink\" title=\"Xcode\"></a>Xcode</h3><p>接下来需要在工程中配置相关编译选项，才能使 <strong>SwiftLint</strong> 在 Xcode 中运行起来。配置也很简单，只需要在 Xcode 的 <code>Build Phases</code> 中新建一个 <code>Run Script Phase</code> 配置项，在里面添加如下代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">which</span> swiftlint &gt;/dev/null; <span class=\"keyword\">then</span></span><br><span class=\"line\">  swiftlint</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">\"warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"https://github.com/realm/SwiftLint/blob/master/assets/runscript.png?raw=true\" alt=\"\"></p>\n<p>如果是通过 CocoaPods 安装的 <strong>SwiftLint</strong> 需要将 <code>swiftlint</code> 替换为 CocoaPods 中的路径： <code>&quot;${PODS_ROOT}/SwiftLint/swiftlint&quot;</code>。<br>这里其实是设置了一个自动编译脚本，每次运行编译都会自动执行这个脚本，如果正确安装了 <strong>SwiftLint</strong>，就会执行 <strong>SwiftLint</strong> 中的代码规范检查，如果没有安装，脚本会抛出一个没有安装 <strong>SwiftLint</strong> 并提示下载的警告，方便提醒团队团队中没有安装的成员。<br>当然，你也可以设置为强制要求安装，这时如果没有安装则无法通过编译。只需要在脚本中 <code>echo &quot;warning: ...&quot;</code> 之后添加一行代码：<code>exit 1</code>，这样一来，如果没有安装 <strong>SwiftLint</strong>，编译时会直接抛出一个编译错误而非警告，提示需要安装 <strong>SwiftLint</strong>。<br>到此配置就完成了，是不是很简单。</p>\n<h3 id=\"自定义配置\"><a href=\"#自定义配置\" class=\"headerlink\" title=\"自定义配置\"></a>自定义配置</h3><p>现在编译一下项目看看，是不是很可怕😨：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/619631-bd69d1a1ac765844.png\" alt=\"\"></p>\n<p>不要被 999+ 吓到了，仔细看一下具体的错误，会发现好多都是第三方库的代码规范问题，而且好多问题的级别被设置成为了 error<br>这样子可不行，第三方库的代码规范问题不能让我们自己的项目来背锅，接下来需要做一些配置，让 <strong>SwiftLint</strong> 在做代码规范检查的时候自动忽略 CocoaPods、Carthage 等包管理器引入的第三方库（当然，手动导入的第三方库也能设置忽略）</p>\n<p>首先需要在项目的根目录下新建一个名为 <code>.swiftlint.yml</code> 的配置文件，输入如下内容：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">excluded:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">Pods</span></span><br></pre></td></tr></table></figure>\n\n<p><code>excluded</code> 配置项用来设置忽略代码规范检查的路径，可以指定整个文件夹，也可以指定精确路径下的文件，通过 <code>- xxxx</code> 的形式列在下面就可以了，比如如果你的项目使用 Carthage 管理第三方库的话，可以将 <code>Carthage</code> 目录添加到忽略列表：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">excluded:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">Pods</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">Carthage</span></span><br></pre></td></tr></table></figure>\n\n<p>保存之后再来编译下，少了很多编译错误了，至少第三方库的编译错误都被干掉了，oh yeah~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/619631-ef9dd3879b1f6d5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>不过错误和警告依然很多，继续往下看，发现大量的 <code>trailing_whitespace</code> 的警告，这个是之前写代码不注意留下的，在空行中包含了空格，虽然肉眼看不出来，但是 <strong>SwiftLint</strong> 火眼金睛啊。<br><img src=\"http://upload-images.jianshu.io/upload_images/619631-d4fca7a4c8043732.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>你可以选择更正所有这些不规范的问题，不过如果这个这个项目是遗留下来的老项目，可能存在大量类似的问题，手动更正这些问题需要相当多的精力，这时候可以选择开启忽略这类问题，只需要在 <code>.swiftlint.yml</code> 文件中加入如下代码：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">disabled_rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">trailing_whitespace</span></span><br></pre></td></tr></table></figure>\n\n<p>再次编译，发现 <code>trailing_whitespace</code> 的问题已经不再提示了，你可以用同样的方法配置忽略特定的规则。</p>\n<h4 id=\"其他规则\"><a href=\"#其他规则\" class=\"headerlink\" title=\"其他规则\"></a>其他规则</h4><p>Xcode自动生成的代码经常包含大段的注视，我们经常会选择保留这些注释。不过 <strong>SwiftLint</strong> 有一个 <code>line_length</code> 的规则，默认是会检查注释的长度的，可以在 <code>.swiftlint.yml</code> 中设置忽略检查注释的长度：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">line_length:</span></span><br><span class=\"line\">  <span class=\"attr\">warning:</span> <span class=\"number\">110</span></span><br><span class=\"line\">  <span class=\"attr\">ignores_function_declarations:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">ignores_comments:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>这段代码设置了 <code>line_length</code> 的检查规则：<br><code>warning: 110</code> 表示单行字符数超过 110 时抛出警告，你也可以设置为其他的值。<br><code>ignores_function_declarations</code> 表示是否忽略检查函数定义的长度<br><code>ignores_comments</code> 设置是否忽略检查注释的长度<br>当然，你也可以在 <code>disabled_rules</code> 中设置忽略单行长度规则</p>\n<p><a href=\"https://github.com/realm/SwiftLint/tree/master/Source/SwiftLintFramework/Rules\" target=\"_blank\" rel=\"noopener\">这里</a>有所有目前已经实现了的规则。你也可以实现自己的规则，然后给他们发 Pull requests。</p>\n<p>本文的<a href=\"#SwiftLint\">最后</a>附上了我自己的 <code>.swiftlint.yml</code> 文件，你可以在 <strong>SwiftLint</strong> 的<a href=\"https://github.com/realm/SwiftLint#configuration\" target=\"_blank\" rel=\"noopener\">官方文档</a>找到更多关于自定义规则的说明。</p>\n<p>设置完所有配置之后，再次编译代码，之后就可以根据错误提示去更正不规范的代码了。</p>\n<h4 id=\"swiftlint-yml-的嵌套\"><a href=\"#swiftlint-yml-的嵌套\" class=\"headerlink\" title=\".swiftlint.yml 的嵌套\"></a><code>.swiftlint.yml</code> 的嵌套</h4><p><code>.swiftlint.yml</code> 配置文件支持嵌套，因此</p>\n<ul>\n<li>你可以给每个文件夹下的代码单独指定不同的规则设置</li>\n<li>每个文件会匹配距离自己层级最近的父文件夹中的配置文件</li>\n<li>嵌套的配置文件中的 <code>excluded</code> 和 <code>included</code> 配置会被忽略</li>\n</ul>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>终于写完了第一篇技术博客，深感写文章的不易，希望能保持下去。<br>这篇文章是我在初步研究了 <strong>SwiftLint</strong> 之后写的，一定有很多谬误和不足之处，各位轻喷- -</p>\n<hr>\n<p><a name=\"SwiftLint\"><code>.swiftlint.yml</code></a></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">disabled_rules:</span> <span class=\"comment\"># rule identifiers to exclude from running</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">force_cast</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">trailing_whitespace</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">cyclomatic_complexity</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">unused_closure_parameter</span></span><br><span class=\"line\"><span class=\"comment\">#   - colon</span></span><br><span class=\"line\"><span class=\"comment\">#   - comma</span></span><br><span class=\"line\"><span class=\"comment\">#   - control_statement</span></span><br><span class=\"line\"><span class=\"comment\"># opt_in_rules: # some rules are only opt-in</span></span><br><span class=\"line\"><span class=\"comment\">#   - empty_count</span></span><br><span class=\"line\"><span class=\"comment\">#   - missing_docs</span></span><br><span class=\"line\"><span class=\"comment\">#   # Find all the available rules by running:</span></span><br><span class=\"line\"><span class=\"comment\">#   # swiftlint rules</span></span><br><span class=\"line\"><span class=\"comment\"># included: # paths to include during linting. `--path` is ignored if present.</span></span><br><span class=\"line\"><span class=\"comment\">#   - Docs.M/*/*.swift</span></span><br><span class=\"line\"><span class=\"attr\">excluded:</span> <span class=\"comment\"># paths to ignore during linting. Takes precedence over `included`.</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">Carthage</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">Pods</span></span><br><span class=\"line\">  <span class=\"comment\"># - Source/ExcludedFolder</span></span><br><span class=\"line\">  <span class=\"comment\"># - Source/ExcludedFile.swift</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># configurable rules can be customized from this configuration file</span></span><br><span class=\"line\"><span class=\"comment\"># binary rules can set their severity level</span></span><br><span class=\"line\"><span class=\"comment\"># force_cast: warning # implicitly</span></span><br><span class=\"line\"><span class=\"attr\">force_try:</span></span><br><span class=\"line\">  <span class=\"attr\">severity:</span> <span class=\"string\">warning</span> <span class=\"comment\"># explicitly</span></span><br><span class=\"line\"><span class=\"comment\"># rules that have both warning and error levels, can set just the warning level</span></span><br><span class=\"line\"><span class=\"comment\"># implicitly</span></span><br><span class=\"line\"><span class=\"attr\">line_length:</span></span><br><span class=\"line\">  <span class=\"attr\">warning:</span> <span class=\"number\">200</span></span><br><span class=\"line\">  <span class=\"attr\">ignores_function_declarations:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">ignores_comments:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># they can set both implicitly with an array</span></span><br><span class=\"line\"><span class=\"attr\">type_body_length:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"number\">300</span> <span class=\"comment\"># warning</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"number\">400</span> <span class=\"comment\"># error</span></span><br><span class=\"line\"><span class=\"comment\"># or they can set both explicitly</span></span><br><span class=\"line\"><span class=\"attr\">file_length:</span></span><br><span class=\"line\">  <span class=\"attr\">warning:</span> <span class=\"number\">500</span></span><br><span class=\"line\">  <span class=\"attr\">error:</span> <span class=\"number\">1200</span></span><br><span class=\"line\"><span class=\"comment\"># naming rules can set warnings/errors for min_length and max_length</span></span><br><span class=\"line\"><span class=\"comment\"># additionally they can set excluded names</span></span><br><span class=\"line\"><span class=\"comment\"># type_name:</span></span><br><span class=\"line\"><span class=\"comment\">#   min_length: 4 # only warning</span></span><br><span class=\"line\"><span class=\"comment\">#   max_length: # warning and error</span></span><br><span class=\"line\"><span class=\"comment\">#     warning: 40</span></span><br><span class=\"line\"><span class=\"comment\">#     error: 50</span></span><br><span class=\"line\"><span class=\"comment\">#   excluded: iPhone # excluded via string</span></span><br><span class=\"line\"><span class=\"attr\">identifier_name:</span></span><br><span class=\"line\">  <span class=\"attr\">min_length:</span> <span class=\"comment\"># only min_length</span></span><br><span class=\"line\">    <span class=\"attr\">error:</span> <span class=\"number\">3</span> <span class=\"comment\"># only error</span></span><br><span class=\"line\">  <span class=\"attr\">excluded:</span> <span class=\"comment\"># excluded via string array</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">id</span></span><br><span class=\"line\"><span class=\"comment\">#     - URL</span></span><br><span class=\"line\"><span class=\"comment\">#     - GlobalAPIKey</span></span><br><span class=\"line\"><span class=\"attr\">reporter:</span> <span class=\"string\">\"xcode\"</span> <span class=\"comment\"># reporter type (xcode, json, csv, checkstyle, junit, html, emoji)</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近跟着公司大佬在做 Laravel 后端开发，要求使用 php lint 进行代码规范检查之后才能 push 代码，保证所有人写出风格统一的代码，方便后期的维护和 Review，于是开始往老本行上反思。<br>想想自己写了五六年的 iOS ，虽然自认代码还是写的很规整的，但是写 high 了之后还是会忽略很多细节上的东西，虽说无伤大雅，但是软件开发作为一门工程性质的东东，始终觉得规范化是一件很重要的事情。<br>在之前的公司也曾经在 iOS 组内部推行过代码规范的实施，但那时候还只是停留在弄个 Word 文档，把各条规范列一列，然后开个小会普及下的程度上。现在接触了不少其他开发领域的东西，越来越觉得对于开发者来说提高视角去了解各个方面是多么重要的一件事情。不同领域的经验、做事的方式、思路，都可以相互借鉴与融合。<br>于是开始寻找在 iOS 下实行类似方案的可能性。说来也巧，最近在看 iOS 相关资料的时候发现了 SwiftLint 这玩意儿，遂打算来实践下。</p>\n</blockquote>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><a href=\"https://github.com/realm/SwiftLint\" target=\"_blank\" rel=\"noopener\">SwiftLint</a> 是 <a href=\"https://realm.io/\" target=\"_blank\" rel=\"noopener\">Realm</a> 推出的一款 Swift 代码规范检查工具，Realm 就不用介绍了，他们家推出的移动端跨平台数据库在业内的名气还是很大的，就算没有用过，相信大多数人也是听过的。<br><strong>SwiftLint</strong> 基于 Github 公布的 <a href=\"https://github.com/github/swift-style-guide\" target=\"_blank\" rel=\"noopener\">Swift 代码规范</a>进行代码检查，并且能够很好的和 Xcode 整合。配置好所有的设置之后，在 Xcode 中执行编译时，SwiftLint 会自动运行检查，不符合规范的代码会通过警告或者 error 的形式指示出来，并且拥有丰富的配置项，可以进行大量的自定义，相当方便。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p><strong>SwiftLint</strong> 有多种不同的安装方式，可以根据自己的喜好选择。</p>\n<h3 id=\"使用-Homebrew-安装\"><a href=\"#使用-Homebrew-安装\" class=\"headerlink\" title=\"使用 Homebrew 安装\"></a>使用 Homebrew 安装</h3><p><strong>Homebrew</strong> 是 macOS 自带的包管理工具，使用这种方式安装也是最简单的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install swiftlint</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-CocoaPods-安装\"><a href=\"#使用-CocoaPods-安装\" class=\"headerlink\" title=\"使用 CocoaPods 安装\"></a>使用 CocoaPods 安装</h3><p>通过 CocoaPods 安装同样很简单，只需要在 Podfile 中添加依赖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod <span class=\"string\">'SwiftLint'</span></span><br></pre></td></tr></table></figure>\n\n<p>之后执行 <code>pod install</code> 就可以自动安装了，这种方式会将 <strong>SwiftLint</strong> 安装到项目的 <code>Pods/</code> 目录下。如果你想要针对不同的项目使用不同的 <strong>SwiftLint</strong> 版本，这是一种很好的解决方案（<strong>Homebrew</strong> 会自动安装最新版本）。</p>\n<p>需要注意的是使用这种方案会将整个 ** SwiftLint** 以及他的依赖包的完整资源文件都安装到 <code>Pods/</code> 目录中去，所以在使用版本管理工具比如 <code>git</code> 时要注意设置忽略相关目录。</p>\n<h3 id=\"使用安装包\"><a href=\"#使用安装包\" class=\"headerlink\" title=\"使用安装包\"></a>使用安装包</h3><p><strong>SwiftLint</strong> 还支持使用 <code>pkg</code> 安装包进行安装，在官方的 Github 页面可以找到最新发布的<a href=\"https://github.com/realm/SwiftLint/releases/tag/0.17.0\" target=\"_blank\" rel=\"noopener\">安装包</a>。</p>\n<h3 id=\"编译源代码\"><a href=\"#编译源代码\" class=\"headerlink\" title=\"编译源代码\"></a>编译源代码</h3><p><strong>SwiftLint</strong> 完全使用 Swift 开发，并且它是基于 <a href=\"https://github.com/realm/SwiftLint/blob/master/LICENSE\" target=\"_blank\" rel=\"noopener\">MIT License</a> 开源的，所以你可以下载它的源代码，然后通过以下命令编译安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule update --init --recursive; make install</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装完成\"><a href=\"#安装完成\" class=\"headerlink\" title=\"安装完成\"></a>安装完成</h3><p>等待安装完成，输入 <code>swiftlint help</code> 可以查看所有可用的命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ swiftlint <span class=\"built_in\">help</span></span><br><span class=\"line\">Available commands:</span><br><span class=\"line\"></span><br><span class=\"line\">   autocorrect   Automatically correct warnings and errors</span><br><span class=\"line\">   <span class=\"built_in\">help</span>          Display general or <span class=\"built_in\">command</span>-specific <span class=\"built_in\">help</span></span><br><span class=\"line\">   lint          Print lint warnings and errors (default <span class=\"built_in\">command</span>)</span><br><span class=\"line\">   rules         Display the list of rules and their identifiers</span><br><span class=\"line\">   version       Display the current version of SwiftLint</span><br></pre></td></tr></table></figure>\n\n<p>到此 <strong>SwiftLint</strong> 就安装完成了</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><h3 id=\"Xcode\"><a href=\"#Xcode\" class=\"headerlink\" title=\"Xcode\"></a>Xcode</h3><p>接下来需要在工程中配置相关编译选项，才能使 <strong>SwiftLint</strong> 在 Xcode 中运行起来。配置也很简单，只需要在 Xcode 的 <code>Build Phases</code> 中新建一个 <code>Run Script Phase</code> 配置项，在里面添加如下代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">which</span> swiftlint &gt;/dev/null; <span class=\"keyword\">then</span></span><br><span class=\"line\">  swiftlint</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">\"warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<p>如图所示：</p>\n<p><img src=\"https://github.com/realm/SwiftLint/blob/master/assets/runscript.png?raw=true\" alt=\"\"></p>\n<p>如果是通过 CocoaPods 安装的 <strong>SwiftLint</strong> 需要将 <code>swiftlint</code> 替换为 CocoaPods 中的路径： <code>&quot;${PODS_ROOT}/SwiftLint/swiftlint&quot;</code>。<br>这里其实是设置了一个自动编译脚本，每次运行编译都会自动执行这个脚本，如果正确安装了 <strong>SwiftLint</strong>，就会执行 <strong>SwiftLint</strong> 中的代码规范检查，如果没有安装，脚本会抛出一个没有安装 <strong>SwiftLint</strong> 并提示下载的警告，方便提醒团队团队中没有安装的成员。<br>当然，你也可以设置为强制要求安装，这时如果没有安装则无法通过编译。只需要在脚本中 <code>echo &quot;warning: ...&quot;</code> 之后添加一行代码：<code>exit 1</code>，这样一来，如果没有安装 <strong>SwiftLint</strong>，编译时会直接抛出一个编译错误而非警告，提示需要安装 <strong>SwiftLint</strong>。<br>到此配置就完成了，是不是很简单。</p>\n<h3 id=\"自定义配置\"><a href=\"#自定义配置\" class=\"headerlink\" title=\"自定义配置\"></a>自定义配置</h3><p>现在编译一下项目看看，是不是很可怕😨：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/619631-bd69d1a1ac765844.png\" alt=\"\"></p>\n<p>不要被 999+ 吓到了，仔细看一下具体的错误，会发现好多都是第三方库的代码规范问题，而且好多问题的级别被设置成为了 error<br>这样子可不行，第三方库的代码规范问题不能让我们自己的项目来背锅，接下来需要做一些配置，让 <strong>SwiftLint</strong> 在做代码规范检查的时候自动忽略 CocoaPods、Carthage 等包管理器引入的第三方库（当然，手动导入的第三方库也能设置忽略）</p>\n<p>首先需要在项目的根目录下新建一个名为 <code>.swiftlint.yml</code> 的配置文件，输入如下内容：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">excluded:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">Pods</span></span><br></pre></td></tr></table></figure>\n\n<p><code>excluded</code> 配置项用来设置忽略代码规范检查的路径，可以指定整个文件夹，也可以指定精确路径下的文件，通过 <code>- xxxx</code> 的形式列在下面就可以了，比如如果你的项目使用 Carthage 管理第三方库的话，可以将 <code>Carthage</code> 目录添加到忽略列表：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">excluded:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">Pods</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">Carthage</span></span><br></pre></td></tr></table></figure>\n\n<p>保存之后再来编译下，少了很多编译错误了，至少第三方库的编译错误都被干掉了，oh yeah~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/619631-ef9dd3879b1f6d5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>不过错误和警告依然很多，继续往下看，发现大量的 <code>trailing_whitespace</code> 的警告，这个是之前写代码不注意留下的，在空行中包含了空格，虽然肉眼看不出来，但是 <strong>SwiftLint</strong> 火眼金睛啊。<br><img src=\"http://upload-images.jianshu.io/upload_images/619631-d4fca7a4c8043732.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>你可以选择更正所有这些不规范的问题，不过如果这个这个项目是遗留下来的老项目，可能存在大量类似的问题，手动更正这些问题需要相当多的精力，这时候可以选择开启忽略这类问题，只需要在 <code>.swiftlint.yml</code> 文件中加入如下代码：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">disabled_rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">trailing_whitespace</span></span><br></pre></td></tr></table></figure>\n\n<p>再次编译，发现 <code>trailing_whitespace</code> 的问题已经不再提示了，你可以用同样的方法配置忽略特定的规则。</p>\n<h4 id=\"其他规则\"><a href=\"#其他规则\" class=\"headerlink\" title=\"其他规则\"></a>其他规则</h4><p>Xcode自动生成的代码经常包含大段的注视，我们经常会选择保留这些注释。不过 <strong>SwiftLint</strong> 有一个 <code>line_length</code> 的规则，默认是会检查注释的长度的，可以在 <code>.swiftlint.yml</code> 中设置忽略检查注释的长度：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">line_length:</span></span><br><span class=\"line\">  <span class=\"attr\">warning:</span> <span class=\"number\">110</span></span><br><span class=\"line\">  <span class=\"attr\">ignores_function_declarations:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">ignores_comments:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>这段代码设置了 <code>line_length</code> 的检查规则：<br><code>warning: 110</code> 表示单行字符数超过 110 时抛出警告，你也可以设置为其他的值。<br><code>ignores_function_declarations</code> 表示是否忽略检查函数定义的长度<br><code>ignores_comments</code> 设置是否忽略检查注释的长度<br>当然，你也可以在 <code>disabled_rules</code> 中设置忽略单行长度规则</p>\n<p><a href=\"https://github.com/realm/SwiftLint/tree/master/Source/SwiftLintFramework/Rules\" target=\"_blank\" rel=\"noopener\">这里</a>有所有目前已经实现了的规则。你也可以实现自己的规则，然后给他们发 Pull requests。</p>\n<p>本文的<a href=\"#SwiftLint\">最后</a>附上了我自己的 <code>.swiftlint.yml</code> 文件，你可以在 <strong>SwiftLint</strong> 的<a href=\"https://github.com/realm/SwiftLint#configuration\" target=\"_blank\" rel=\"noopener\">官方文档</a>找到更多关于自定义规则的说明。</p>\n<p>设置完所有配置之后，再次编译代码，之后就可以根据错误提示去更正不规范的代码了。</p>\n<h4 id=\"swiftlint-yml-的嵌套\"><a href=\"#swiftlint-yml-的嵌套\" class=\"headerlink\" title=\".swiftlint.yml 的嵌套\"></a><code>.swiftlint.yml</code> 的嵌套</h4><p><code>.swiftlint.yml</code> 配置文件支持嵌套，因此</p>\n<ul>\n<li>你可以给每个文件夹下的代码单独指定不同的规则设置</li>\n<li>每个文件会匹配距离自己层级最近的父文件夹中的配置文件</li>\n<li>嵌套的配置文件中的 <code>excluded</code> 和 <code>included</code> 配置会被忽略</li>\n</ul>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>终于写完了第一篇技术博客，深感写文章的不易，希望能保持下去。<br>这篇文章是我在初步研究了 <strong>SwiftLint</strong> 之后写的，一定有很多谬误和不足之处，各位轻喷- -</p>\n<hr>\n<p><a name=\"SwiftLint\"><code>.swiftlint.yml</code></a></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">disabled_rules:</span> <span class=\"comment\"># rule identifiers to exclude from running</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">force_cast</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">trailing_whitespace</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">cyclomatic_complexity</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">unused_closure_parameter</span></span><br><span class=\"line\"><span class=\"comment\">#   - colon</span></span><br><span class=\"line\"><span class=\"comment\">#   - comma</span></span><br><span class=\"line\"><span class=\"comment\">#   - control_statement</span></span><br><span class=\"line\"><span class=\"comment\"># opt_in_rules: # some rules are only opt-in</span></span><br><span class=\"line\"><span class=\"comment\">#   - empty_count</span></span><br><span class=\"line\"><span class=\"comment\">#   - missing_docs</span></span><br><span class=\"line\"><span class=\"comment\">#   # Find all the available rules by running:</span></span><br><span class=\"line\"><span class=\"comment\">#   # swiftlint rules</span></span><br><span class=\"line\"><span class=\"comment\"># included: # paths to include during linting. `--path` is ignored if present.</span></span><br><span class=\"line\"><span class=\"comment\">#   - Docs.M/*/*.swift</span></span><br><span class=\"line\"><span class=\"attr\">excluded:</span> <span class=\"comment\"># paths to ignore during linting. Takes precedence over `included`.</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">Carthage</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">Pods</span></span><br><span class=\"line\">  <span class=\"comment\"># - Source/ExcludedFolder</span></span><br><span class=\"line\">  <span class=\"comment\"># - Source/ExcludedFile.swift</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># configurable rules can be customized from this configuration file</span></span><br><span class=\"line\"><span class=\"comment\"># binary rules can set their severity level</span></span><br><span class=\"line\"><span class=\"comment\"># force_cast: warning # implicitly</span></span><br><span class=\"line\"><span class=\"attr\">force_try:</span></span><br><span class=\"line\">  <span class=\"attr\">severity:</span> <span class=\"string\">warning</span> <span class=\"comment\"># explicitly</span></span><br><span class=\"line\"><span class=\"comment\"># rules that have both warning and error levels, can set just the warning level</span></span><br><span class=\"line\"><span class=\"comment\"># implicitly</span></span><br><span class=\"line\"><span class=\"attr\">line_length:</span></span><br><span class=\"line\">  <span class=\"attr\">warning:</span> <span class=\"number\">200</span></span><br><span class=\"line\">  <span class=\"attr\">ignores_function_declarations:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">ignores_comments:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># they can set both implicitly with an array</span></span><br><span class=\"line\"><span class=\"attr\">type_body_length:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"number\">300</span> <span class=\"comment\"># warning</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"number\">400</span> <span class=\"comment\"># error</span></span><br><span class=\"line\"><span class=\"comment\"># or they can set both explicitly</span></span><br><span class=\"line\"><span class=\"attr\">file_length:</span></span><br><span class=\"line\">  <span class=\"attr\">warning:</span> <span class=\"number\">500</span></span><br><span class=\"line\">  <span class=\"attr\">error:</span> <span class=\"number\">1200</span></span><br><span class=\"line\"><span class=\"comment\"># naming rules can set warnings/errors for min_length and max_length</span></span><br><span class=\"line\"><span class=\"comment\"># additionally they can set excluded names</span></span><br><span class=\"line\"><span class=\"comment\"># type_name:</span></span><br><span class=\"line\"><span class=\"comment\">#   min_length: 4 # only warning</span></span><br><span class=\"line\"><span class=\"comment\">#   max_length: # warning and error</span></span><br><span class=\"line\"><span class=\"comment\">#     warning: 40</span></span><br><span class=\"line\"><span class=\"comment\">#     error: 50</span></span><br><span class=\"line\"><span class=\"comment\">#   excluded: iPhone # excluded via string</span></span><br><span class=\"line\"><span class=\"attr\">identifier_name:</span></span><br><span class=\"line\">  <span class=\"attr\">min_length:</span> <span class=\"comment\"># only min_length</span></span><br><span class=\"line\">    <span class=\"attr\">error:</span> <span class=\"number\">3</span> <span class=\"comment\"># only error</span></span><br><span class=\"line\">  <span class=\"attr\">excluded:</span> <span class=\"comment\"># excluded via string array</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">id</span></span><br><span class=\"line\"><span class=\"comment\">#     - URL</span></span><br><span class=\"line\"><span class=\"comment\">#     - GlobalAPIKey</span></span><br><span class=\"line\"><span class=\"attr\">reporter:</span> <span class=\"string\">\"xcode\"</span> <span class=\"comment\"># reporter type (xcode, json, csv, checkstyle, junit, html, emoji)</span></span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck61tll2e0001ufqb5omv0rdo","tag_id":"ck61tll2h0003ufqb27m2fr3k","_id":"ck61tll2o000bufqb93vk1ne5"},{"post_id":"ck61tll2e0001ufqb5omv0rdo","tag_id":"ck61tll2l0007ufqb9tszbykm","_id":"ck61tll2p000cufqbc4we2i2m"},{"post_id":"ck61tll2e0001ufqb5omv0rdo","tag_id":"ck61tll2n000aufqb42azaeqf","_id":"ck61tll2p000dufqb8w9hh80h"}],"Tag":[{"name":"iOS","_id":"ck61tll2h0003ufqb27m2fr3k"},{"name":"Swift","_id":"ck61tll2l0007ufqb9tszbykm"},{"name":"Cookiecutter","_id":"ck61tll2n000aufqb42azaeqf"}]}}